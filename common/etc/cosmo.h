#ifndef COSMOPOLITAN_H_
#define COSMOPOLITAN_H_


/*!BEGIN libc/integral/normalize.inc */

#define __COSMOPOLITAN__ 1

#ifndef __COUNTER__
#define __COUNTER__ __LINE__
#endif

#if __GNUC__ + 0 < 2
#undef __GNUC__
#elif defined(__GNUC__) && defined(SWIG) /* lool */
#undef __GNUC__
#elif defined(__GNUC__) && defined(__NVCC__) /* lool */
#undef __GNUC__
#elif !defined(__GNUC__) && defined(__APPLE__) /* modesty */
#define __GNUC__            4
#define __GNUC_MINOR__      2
#define __GNUC_PATCHLEVEL__ 1
#elif !defined(__GNUC__) && defined(__TINYC__)
#define __GNUC__            2
#define __GNUC_MINOR__      0
#define __GNUC_PATCHLEVEL__ 0
#endif

#if !defined(__x86_64__) && \
    (defined(__amd64__) || (defined(_M_AMD64) && defined(_M_X64)))
#define __x86_64__ 1
#elif !defined(__i386__) && ((defined(__i486__) || defined(__i586__) ||  \
                              defined(__i686__) || defined(__i786__)) || \
                             _M_IX86 + 0 >= 400)
#define __i386__ 1
#elif !defined(__ia16__) && (defined(__MSDOS__) || defined(__BCC__))
#define __ia16__ 1
#endif
#if __ia16__ + __i386__ + __x86_64__ + 0
#define __x86__ 1
#endif

#ifdef _MSC_VER
#define __STRICT_ANSI__
#ifndef __STDC__
#define __STDC__
#endif
#endif

#ifndef __has_attribute
#define __has_attribute(x) 0
#endif
#ifndef __has_builtin
#define __has_builtin(x) 0
#endif
#ifndef __has_cpp_attribute
#define __has_cpp_attribute(x) 0
#endif

#ifdef unix
#undef unix
#endif

#ifdef linux
#undef linux
#endif

#ifndef __BIGGEST_ALIGNMENT__
#define __BIGGEST_ALIGNMENT__ 16
#endif

#define BIGPAGESIZE 0x200000
#define STACKSIZE   0x100000
#define FRAMESIZE   0x10000 /* 8086 */
#define PAGESIZE    0x1000  /* i386+ */
#define BUFSIZ      0x1000  /* best stdio default */
#define CACHELINE   0x40    /* nexgen32e */
#define CHAR_BIT    8       /* b/c von neumann */
#define ARG_MAX     0x8000  /* b/c windows */
#define PATH_MAX    248     /* b/c win32 apis limit ~248..260 */
#define NAME_MAX    63      /* b/c dns */
#define CHILD_MAX   25      /* only if malloc isn't linked */
#define OPEN_MAX    16      /* only if malloc isn't linked */
#define ATEXIT_MAX  32      /* only if malloc isn't linked */
#define NSIG        128     /* it's complicated */

#if defined(__LP64__) && !defined(__INT64_TYPE__)


/*!BEGIN libc/integral/lp64.inc */

#define __INT8_MAX__    0x7f
#define __UINT8_MAX__   0xff
#define __INT16_MAX__   0x7fff
#define __UINT16_MAX__  0xffff
#define __SHRT_MAX__    0x7fff
#define __INT_MAX__     0x7fffffff
#define __INT32_MAX__   0x7fffffff
#define __UINT32_MAX__  0xffffffffu
#define __INT64_MAX__   0x7fffffffffffffffl
#define __UINT64_MAX__  0xfffffffffffffffful
#define __SIZE_MAX__    0xfffffffffffffffful
#define __INTPTR_MAX__  0x7fffffffffffffffl
#define __UINTPTR_MAX__ 0xfffffffffffffffful
#define __WINT_MAX__    0xffffffffu

#define __SIZEOF_SHORT__       2
#define __SIZEOF_INT__         4
#define __SIZEOF_LONG__        8
#define __SIZEOF_LONG_LONG__   8
#define __SIZEOF_POINTER__     8
#define __SIZEOF_PTRDIFF_T__   8
#define __SIZEOF_SIZE_T__      8
#define __SIZEOF_WCHAR_T__     4
#define __SIZEOF_WINT_T__      4
#define __SIZEOF_FLOAT__       4
#define __SIZEOF_FLOAT128__    16
#define __SIZEOF_DOUBLE__      8
#define __SIZEOF_FLOAT80__     16
#define __SIZEOF_LONG_DOUBLE__ 16

#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define __INT8_TYPE__    signed char
#define __UINT8_TYPE__   unsigned char
#define __INT16_TYPE__   short int
#define __UINT16_TYPE__  short unsigned int
#define __INT32_TYPE__   int
#define __UINT32_TYPE__  unsigned int
#define __INT64_TYPE__   long int
#define __UINT64_TYPE__  long unsigned int
#define __INTPTR_TYPE__  long int
#define __UINTPTR_TYPE__ long unsigned int
#define __PTRDIFF_TYPE__ long int
#define __SIZE_TYPE__    long unsigned int
#define __WCHAR_TYPE__   int
#define __CHAR16_TYPE__  short unsigned int
#define __CHAR32_TYPE__  unsigned int
#define __WINT_TYPE__    unsigned int
#define __CHAR16_TYPE__  short unsigned int
#define __WCHAR_TYPE__   int
#define __CHAR32_TYPE__  unsigned int

#define __INT_LEAST8_TYPE__   __INT8_TYPE__
#define __UINT_LEAST8_TYPE__  __UINT8_TYPE__
#define __INT_LEAST16_TYPE__  __INT32_TYPE__
#define __UINT_LEAST16_TYPE__ __UINT16_TYPE__
#define __INT_LEAST32_TYPE__  __INT16_TYPE__
#define __UINT_LEAST32_TYPE__ __UINT32_TYPE__
#define __INT_LEAST64_TYPE__  __INT64_TYPE__
#define __UINT_LEAST64_TYPE__ __UINT64_TYPE__
#define __INT_FAST8_TYPE__    __INT8_TYPE__
#define __UINT_FAST8_TYPE__   __UINT8_TYPE__
#define __INT_FAST16_TYPE__   __INT32_TYPE__
#define __UINT_FAST16_TYPE__  __UINT32_TYPE__
#define __INT_FAST32_TYPE__   __INT32_TYPE__
#define __UINT_FAST32_TYPE__  __UINT32_TYPE__
#define __INT_FAST64_TYPE__   __INT64_TYPE__
#define __UINT_FAST64_TYPE__  __UINT64_TYPE__

#endif
#elif defined(_MSC_VER) && !defined(__INT64_TYPE__)


/*!BEGIN libc/integral/llp64.inc */

#define __INT8_MAX__    0x7f
#define __UINT8_MAX__   0xff
#define __INT16_MAX__   0x7fff
#define __UINT16_MAX__  0xffff
#define __SHRT_MAX__    0x7fff
#define __INT_MAX__     0x7fffffff
#define __INT32_MAX__   0x7fffffff
#define __UINT32_MAX__  0xffffffffu
#define __INT64_MAX__   0x7fffffffffffffffl
#define __UINT64_MAX__  0xffffffffffffffffull
#define __SIZE_MAX__    0xffffffffffffffffull
#define __INTPTR_MAX__  0x7fffffffffffffffll
#define __UINTPTR_MAX__ 0xffffffffffffffffull
#define __WINT_MAX__    0xffffffffu

#define __SIZEOF_SHORT__       2
#define __SIZEOF_INT__         4
#define __SIZEOF_LONG__        4
#define __SIZEOF_LONG_LONG__   8
#define __SIZEOF_POINTER__     8
#define __SIZEOF_PTRDIFF_T__   8
#define __SIZEOF_SIZE_T__      4
#define __SIZEOF_WCHAR_T__     4
#define __SIZEOF_WINT_T__      4
#define __SIZEOF_FLOAT__       4
#define __SIZEOF_FLOAT128__    16
#define __SIZEOF_DOUBLE__      8
#define __SIZEOF_FLOAT80__     16
#define __SIZEOF_LONG_DOUBLE__ 16

#define __INT8_C(c)   c
#define __UINT8_C(c)  c
#define __INT16_C(c)  c
#define __UINT16_C(c) c
#define __INT32_C(c)  c
#define __UINT32_C(c) c##U
#define __INT64_C(c)  c##LL
#define __UINT64_C(c) c##ULL

#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define __INT8_TYPE__    signed char
#define __UINT8_TYPE__   unsigned char
#define __INT16_TYPE__   short int
#define __UINT16_TYPE__  short unsigned int
#define __INT32_TYPE__   int
#define __UINT32_TYPE__  unsigned int
#define __INT64_TYPE__   long long int
#define __UINT64_TYPE__  long long unsigned int
#define __INTPTR_TYPE__  long long int
#define __UINTPTR_TYPE__ long long unsigned int
#define __PTRDIFF_TYPE__ long long int
#define __SIZE_TYPE__    unsigned int
#define __WCHAR_TYPE__   int
#define __CHAR16_TYPE__  short unsigned int
#define __CHAR32_TYPE__  unsigned int
#define __WINT_TYPE__    unsigned int
#define __CHAR16_TYPE__  short unsigned int
#define __WCHAR_TYPE__   int
#define __CHAR32_TYPE__  unsigned int

#define __INT_LEAST8_TYPE__   __INT8_TYPE__
#define __UINT_LEAST8_TYPE__  __UINT8_TYPE__
#define __INT_LEAST16_TYPE__  __INT32_TYPE__
#define __UINT_LEAST16_TYPE__ __UINT16_TYPE__
#define __INT_LEAST32_TYPE__  __INT16_TYPE__
#define __UINT_LEAST32_TYPE__ __UINT32_TYPE__
#define __INT_LEAST64_TYPE__  __INT64_TYPE__
#define __UINT_LEAST64_TYPE__ __UINT64_TYPE__
#define __INT_FAST8_TYPE__    __INT8_TYPE__
#define __UINT_FAST8_TYPE__   __UINT8_TYPE__
#define __INT_FAST16_TYPE__   __INT32_TYPE__
#define __UINT_FAST16_TYPE__  __UINT32_TYPE__
#define __INT_FAST32_TYPE__   __INT32_TYPE__
#define __UINT_FAST32_TYPE__  __UINT32_TYPE__
#define __INT_FAST64_TYPE__   __INT64_TYPE__
#define __UINT_FAST64_TYPE__  __UINT64_TYPE__

#endif
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
#ifdef __STDC__


/*!BEGIN libc/integral/c.inc */

#if __GNUC__ + 0 < 2
#define __attribute__(x)
#endif

#ifndef __cplusplus
#define COSMOPOLITAN_C_START_
#define COSMOPOLITAN_C_END_
#define COSMOPOLITAN_CXX_START_
#define COSMOPOLITAN_CXX_END_
#define COSMOPOLITAN_CXX_USING_
#endif

#ifndef __ia16__
#define __far
#endif

#if !defined(__GNUC__) && __cplusplus + 0 >= 201103L
#define typeof(x) decltype(x)
#elif (defined(__STRICT_ANSI__) || !defined(__GNUC__)) && \
    __STDC_VERSION__ + 0 < 201112
#define typeof(x) __typeof(x)
#endif

#ifdef __cplusplus
#if __cplusplus >= 201103L
#define _Alignof(x) alignof(x)
#endif /* C++11 */
#else  /* __cplusplus */
#define alignof(x) _Alignof(x)
#if __STDC_VERSION__ + 0 < 201112
#if __GNUC__ + _MSC_VER + 0 && !defined(__STRICT_ANSI__)
#define _Alignof(x) __alignof(x)
#else
#define _Alignof(x) /* basically all it ever did lool */ sizeof(x)
#endif /* GNU/MSVC/!ANSI */
#endif /* C11 */
#endif /* __cplusplus */

#if !defined(__cplusplus) && !defined(inline) && __STDC_VERSION__ + 0 < 199901
#if !defined(__STRICT_ANSI__) && (defined(__GNUC__) || defined(_MSC_VER))
#define inline __inline
#else
#define inline
#define __inline
#endif
#endif

#if __STDC_VERSION__ + 0 < 201112
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define _Alignas(x) __attribute__((__aligned__(x)))
#elif defined(_MSC_VER)
#define _Alignas(x) __declspec(align(x))
#endif
#endif

#if defined(__STRICT_ANSI__) || \
    (!defined(__GNUC__) && !__has_builtin(unreachable))
#define __builtin_unreachable() \
  for (;;) {                    \
  }
#endif

#if defined(__STRICT_ANSI__) || (!defined(__llvm__) && !__has_builtin(assume))
#define __builtin_assume(x)            \
  do {                                 \
    if (!(x)) __builtin_unreachable(); \
  } while (0)
#endif

#if __STDC_VERSION__ + 0 < 201112 && defined(__x86__)
#define _Atomic(TYPE) TYPE
#endif

#ifdef __llvm__
#define __gnu_printf__ __printf__
#define __gnu_scanf__  __scanf__
#endif

#if __cplusplus + 0 >= 201103L
#define NULL nullptr
#elif !defined(__cplusplus)
#define NULL ((void *)0)
#else
#define NULL 0
#endif

#ifndef __cplusplus
#if __STDC_VERSION__ + 0 >= 201112
typedef _Bool bool;
#define true ((bool)+1)
#define false ((bool)+0)
#else
#define bool int
#define true 1
#define false 0
#endif
#endif

#ifndef __cplusplus
typedef __WCHAR_TYPE__ wchar_t;
typedef __CHAR16_TYPE__ char16_t;
typedef __CHAR32_TYPE__ char32_t;
#endif

typedef int errno_t;
typedef __SIZE_TYPE__ size_t;
typedef __PTRDIFF_TYPE__ ssize_t;
typedef __INTPTR_TYPE__ intptr_t;
typedef __UINTPTR_TYPE__ uintptr_t;
typedef __PTRDIFF_TYPE__ ptrdiff_t;
typedef __WINT_TYPE__ wint_t; /* uint32_t on linux but int32_t on xnu */
typedef __INT32_TYPE__ bool32;
typedef __INT8_TYPE__ int8_t;
typedef __UINT8_TYPE__ uint8_t;
typedef __INT16_TYPE__ int16_t;
typedef __UINT16_TYPE__ uint16_t;
typedef __INT32_TYPE__ int32_t;
typedef __UINT32_TYPE__ uint32_t;
typedef __INT64_TYPE__ int64_t;
typedef __UINT64_TYPE__ uint64_t;

typedef struct {
  intptr_t ax, dx;
} axdx_t;

#ifdef __SIZEOF_INTMAX__
#undef __SIZEOF_INTMAX__
#endif
#if !defined(__STRICT_ANSI__) && __SIZEOF_POINTER__ == 8 && \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 406 || defined(__llvm__))
#define __SIZEOF_INTMAX__ 16
#else
#define __SIZEOF_INTMAX__ __SIZEOF_POINTER__
#endif
#if __SIZEOF_INTMAX__ == 16
typedef signed __int128 int128_t;
typedef unsigned __int128 uint128_t;
typedef int128_t intmax_t;
typedef uint128_t uintmax_t;
#elif __SIZEOF_INTMAX__ == 8
typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
#endif

#ifndef __chibicc__
#define va_list            __builtin_va_list
#define va_arg(ap, type)   __builtin_va_arg(ap, type)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#define va_end(ap)         __builtin_va_end(ap)
#define va_start(ap, last) __builtin_va_start(ap, last)
#else


/*!BEGIN libc/integral/lp64arg.inc */



/*!BEGIN libc/runtime/valist.h */

#define COSMOPOLITAN_LIBC_RUNTIME_VALIST_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct __va_list {
  uint32_t gp_offset;
  uint32_t fp_offset;
  void *overflow_arg_area;
  void *reg_save_area;
};

void *__va_arg(struct __va_list *, size_t, unsigned, unsigned);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define __GNUC_VA_LIST 1
#define __gnuc_va_list va_list

#define va_end(AP)
#define va_copy(DST, SRC) ((DST)[0] = (SRC)[0])
#define va_start(AP, LAST)                    \
  do {                                        \
    *(AP) = *(struct __va_list *)__va_area__; \
  } while (0)

#define va_arg(AP, TYPE)                               \
  (*(TYPE *)__va_arg(AP, sizeof(TYPE), _Alignof(TYPE), \
                     __builtin_reg_class(TYPE)))

typedef struct __va_list va_list[1];
#endif

#define libcesque   nothrow nocallback
#define memcpyesque libcesque
#define strlenesque libcesque nosideeffect paramsnonnull()
#define vallocesque \
  libcesque nodiscard returnsaligned((PAGESIZE)) returnspointerwithnoaliases
#define reallocesque libcesque returnsaligned((__BIGGEST_ALIGNMENT__))
#define mallocesque  reallocesque returnspointerwithnoaliases
#define interruptfn  nocallersavedregisters forcealignargpointer

#ifndef pureconst
#ifndef __STRICT_ANSI__
#define pureconst __attribute__((__const__))
#else
#define pureconst
#endif
#endif

#ifndef forcealign
#ifndef __STRICT_ANSI__
#define forcealign(bytes) __attribute__((__aligned__(bytes)))
#else
#define forcealign(bytes)
#endif
#endif

#ifndef __STRICT_ANSI__
#define thatispacked __attribute__((__packed__))
#else
#define thatispacked
#endif

#ifndef __STRICT_ANSI__
#define printfesque(n)   __attribute__((__format__(__gnu_printf__, n, n + 1)))
#define scanfesque(n)    __attribute__((__format__(__gnu_scanf__, n, n + 1)))
#define strftimeesque(n) __attribute__((__format__(__strftime__, n, 0)))
#else
#define printfesque(n)
#define scanfesque(n)
#define strftimeesque(n)
#endif

#ifndef hidden
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__visibility__) || defined(__GNUC__)) && !defined(_WIN32)
#define hidden __attribute__((__visibility__("hidden")))
#else
#define hidden
#endif
#endif

#ifndef privileged
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__visibility__) || defined(__GNUC__))
#define privileged _Section(".privileged") noinstrument
#else
#define privileged _Section(".privileged") noinstrument
#endif
#endif

#ifndef noinstrument
#if !defined(__STRICT_ANSI__) &&                    \
    (__has_attribute(__no_instrument_function__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 204)
#define noinstrument __attribute__((__no_instrument_function__))
#else
#define noinstrument
#endif
#endif

#ifndef wontreturn
#if !defined(__STRICT_ANSI__) &&      \
    (__has_attribute(__noreturn__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 208)
#define wontreturn __attribute__((__noreturn__))
#else
#define wontreturn
#endif
#endif

#ifndef nosideeffect
#if !defined(__STRICT_ANSI__) &&  \
    (__has_attribute(__pure__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 296)
#define nosideeffect __attribute__((__pure__))
#else
#define nosideeffect
#endif
#endif

#ifndef noinline
#if !defined(__STRICT_ANSI__) &&      \
    (__has_attribute(__noinline__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 301)
#define noinline __attribute__((__noinline__))
#else
#define noinline
#endif
#endif

#ifndef noclone
#if !defined(__STRICT_ANSI__) &&     \
    (__has_attribute(__noclone__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 405)
#define noclone __attribute__((__noclone__))
#else
#define noclone
#endif
#endif

#ifndef forceinline
#ifdef __cplusplus
#define forceinline inline
#else
#if !defined(__STRICT_ANSI__) && \
    (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 302
#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403 || \
    !defined(__cplusplus) ||                              \
    (defined(__clang__) &&                                \
     (defined(__GNUC_STDC_INLINE__) || defined(__GNUC_GNU_INLINE__)))
#if defined(__GNUC_STDC_INLINE__) || defined(__cplusplus)
#define forceinline                                                 \
  static __inline __attribute__((__always_inline__, __gnu_inline__, \
                                 __no_instrument_function__, __unused__))
#else
#define forceinline              \
  static __inline __attribute__( \
      (__always_inline__, __no_instrument_function__, __unused__))
#endif /* __GNUC_STDC_INLINE__ */
#endif /* GCC >= 4.3 */
#elif defined(_MSC_VER)
#define forceinline __forceinline
#else
#define forceinline static inline
#endif /* !ANSI && GCC >= 3.2 */
#endif /* __cplusplus */
#endif /* forceinline */

#ifndef mayalias
#if !defined(__STRICT_ANSI__) &&       \
    (__has_attribute(__may_alias__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 303)
#define mayalias __attribute__((__may_alias__))
#else
#define mayalias
#endif
#endif

#ifndef nodiscard
#if !defined(__STRICT_ANSI__) &&                           \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 304 || \
     __has_attribute(__warn_unused_result__))
#define nodiscard __attribute__((__warn_unused_result__))
#else
#define nodiscard
#endif
#endif

#ifndef nullterminated
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__sentinel__) || __GNUC__ + 0 >= 4)
#define nullterminated(x) __attribute__((__sentinel__ x))
#else
#define nullterminated(x)
#endif
#endif

#ifndef flattenout
#if __has_attribute(__flatten__) || \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 401 && !defined(__llvm__))
#define flattenout __attribute__((__flatten__))
#else
#define flattenout
#endif
#endif

#ifndef externinline
#if !defined(__STRICT_ANSI__) &&                           \
    (!defined(__cplusplus) ||                              \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403 || \
     (defined(__clang__) &&                                \
      (defined(__GNUC_STDC_INLINE__) || defined(__GNUC_GNU_INLINE__))))
#if defined(__GNUC_STDC_INLINE__) || defined(__cplusplus)
#define externinline extern __inline __attribute__((__gnu_inline__))
#else
#define externinline extern __inline __attribute__((__always_inline__))
#endif
#else
#define externinline inline
#endif
#endif

#ifndef relegated
#if !defined(__STRICT_ANSI__) &&  \
    (__has_attribute(__cold__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define relegated __attribute__((__cold__))
#else
#define relegated
#endif
#endif

#if !defined(__STRICT_ANSI__) &&     \
    (__has_attribute(__warning__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define warnifused(s) __attribute__((__warning__(s)))
#else
#define warnifused(s)
#endif

#ifndef firstclass
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__hot__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define firstclass __attribute__((__hot__))
#else
#define firstclass
#endif
#endif

#ifndef paramsnonnull
#if !defined(__STRICT_ANSI__) &&     \
    (__has_attribute(__nonnull__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define paramsnonnull(opt_1idxs) __attribute__((__nonnull__ opt_1idxs))
#else
#define paramsnonnull(opt_1idxs)
#endif
#endif

#if __STDC_VERSION__ + 0 >= 199901L
#define hasatleast static
#else
#define hasatleast
#endif

#if __STDC_VERSION__ + 0 < 199901L && !defined(restrict)
#if !defined(__STRICT_ANSI__) && !defined(__cplusplus) && \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 301 || defined(_MSC_VER))
#define restrict __restrict__
#else
#define restrict
#define __restrict
#endif
#endif

#ifndef nocallback
#if !defined(__STRICT_ANSI__) &&  \
    (__has_attribute(__leaf__) || \
     (!defined(__llvm__) &&       \
      (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 406))
#define nocallback __attribute__((__leaf__))
#else
#define nocallback
#endif
#endif

#ifndef nothrow
#if defined(__cplusplus) && !defined(__STRICT_ANSI__) && \
    (__has_attribute(nothrow) ||                         \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 303)
#define nothrow __attribute__((__nothrow__))
#elif defined(_MSC_VER)
#define nothrow __declspec(nothrow)
#else
#define nothrow
#endif
#endif

#ifndef nooptimize
#ifndef __STRICT_ANSI__
#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 407 || \
    __has_attribute(__optimize__)
#define nooptimize __attribute__((__optimize__(1)))
#elif defined(__llvm__) || __has_attribute(__optnone__)
#define nooptimize __attribute__((__optnone__))
#endif
#else
#define nooptimize
#endif
#endif

#ifndef optimizesize
#ifndef __STRICT_ANSI__
#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 407 || \
    __has_attribute(__optimize__)
#define optimizesize __attribute__((__optimize__("s")))
#elif defined(__llvm__) || __has_attribute(__optnone__)
#define optimizesize __attribute__((__optnone__))
#endif
#else
#define optimizesize
#endif
#endif

#ifndef optimizespeed
#if !defined(__STRICT_ANSI__) &&                           \
    ((__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 407 || \
     __has_attribute(__optimize__))
#define optimizespeed __attribute__((__optimize__(3)))
#else
#define optimizespeed
#endif
#endif

#ifndef returnstwice
#if !defined(__STRICT_ANSI__) &&           \
    (__has_attribute(__returns_twice__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 402)
#define returnstwice __attribute__((__returns_twice__))
#else
#define returnstwice
#endif
#endif

#ifndef nodebuginfo
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__nodebug__) || defined(__llvm__))
#define nodebuginfo __attribute__((__nodebug__))
#else
#define nodebuginfo
#endif
#endif

#ifndef artificial
#if !defined(__STRICT_ANSI__) &&        \
    (__has_attribute(__artificial__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 403)
#define artificial __attribute__((__artificial__))
#else
#define artificial
#endif
#endif

#ifndef microarchitecture
#if !defined(__STRICT_ANSI__) &&    \
    (__has_attribute(__target__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 404)
#define microarchitecture(march) __attribute__((__target__(march)))
#else
#define microarchitecture(march)
#endif
#endif

#ifndef targetclones
#if !defined(__STRICT_ANSI__) && \
    (__has_attribute(__target_clones__) || __GNUC__ >= 6)
#define targetclones(archs) __attribute__((__target_clones__(archs)))
#else
#define targetclones(archs)
#endif
#endif

#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 408 || \
    __has_attribute(__force_align_arg_pointer__)
#define forcealignargpointer __attribute__((__force_align_arg_pointer__))
#else
#define forcealignargpointer "need modern compiler"
#endif

#ifndef returnsnonnull
#if !defined(__STRICT_ANSI__) &&             \
    (__has_attribute(__returns_nonnull__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define returnsnonnull __attribute__((__returns_nonnull__))
#else
#define returnsnonnull
#endif
#endif

#if !defined(__STRICT_ANSI__) &&            \
    (__has_attribute(__assume_aligned__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define returnsaligned(x) __attribute__((__assume_aligned__ x))
#else
#define returnsaligned(x)
#endif

#ifndef returnspointerwithnoaliases
#if !defined(__STRICT_ANSI__) &&    \
    (__has_attribute(__malloc__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define returnspointerwithnoaliases __attribute__((__malloc__))
#elif defined(_MSC_VER)
#define returnspointerwithnoaliases __declspec(allocator)
#else
#define returnspointerwithnoaliases
#endif
#endif

#ifndef attributeallocsize
#if !defined(__STRICT_ANSI__) &&        \
    (__has_attribute(__alloc_size__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define attributeallocsize(x) __attribute__((__alloc_size__ x))
#else
#define attributeallocsize(x)
#endif
#endif

#ifndef attributeallocalign
#if !defined(__STRICT_ANSI__) &&         \
    (__has_attribute(__alloc_align__) || \
     (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409)
#define attributeallocalign(x) __attribute__((__alloc_align__ x))
#else
#define attributeallocalign(x)
#endif
#endif

#if __cplusplus + 0 >= 201103L
#define autotype(x) auto
#elif ((__has_builtin(auto_type) || defined(__llvm__) ||       \
        (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 409) && \
       !defined(__chibicc__))
#define autotype(x) __auto_type
#else
#define autotype(x) typeof(x)
#endif

#if __GNUC__ >= 7 || __has_attribute(__no_caller_saved_registers__)
#define nocallersavedregisters __attribute__((__no_caller_saved_registers__))
#else
#define nocallersavedregisters "need modern compiler"
#endif

#if (__GNUC__ + 0) * 100 + (__GNUC_MINOR__ + 0) >= 408 || \
    __has_attribute(__no_sanitize_address__)
#define noasan __attribute__((__no_sanitize_address__))
#else
#define noasan
#endif

#ifndef unreachable
#if defined(__GNUC__) && !defined(__STRICT_ANSI)
#define unreachable __builtin_unreachable()
#else
#define unreachable \
  do {              \
  } while (1)
#endif
#endif

#define donothing \
  do {            \
  } while (0)

#ifndef __STRICT_ANSI__
#define testonly    noinline _Section(".test")
#define textstartup _Section(".text.startup") noinstrument
#define textexit    _Section(".text.exit") noinstrument
#define textreal    _Section(".text.real")
#define textwindows _Section(".text.windows")
#define antiquity   _Section(".text.antiquity")
#else
#define testonly
#define textstartup
#define textexit
#define textreal
#define textwindows
#define antiquity
#endif

#ifndef compatfn
#define compatfn
#endif

#ifndef frownedupon
#define frownedupon(alternative)
#endif

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define _Vector_size(k) __attribute__((__vector_size__(k)))
#else
#define _Vector_size(k) [k]
#endif

#if defined(__STRICT_ANSI__) || \
    (!defined(__GNUC__) && !defined(__builtin_offsetof))
#define offsetof(type, member) ((unsigned long)&((type *)0)->member)
#else
#define offsetof(type, member) __builtin_offsetof(type, member)
#endif

#ifndef _Section
#if !defined(__STRICT_ANSI__) && !defined(__APPLE__)
#define _Section(s) __attribute__((__section__(s)))
#else
#define _Section(s)
#endif
#endif

#ifndef __llvm__
#define initarray _Section(".init_array,\"a\",@init_array #")
#else
#define initarray _Section(".init_array")
#endif

#ifndef __STRICT_ANSI__
#if defined(__GNUC__) || defined(__llvm__)
#pragma GCC diagnostic ignored "-Wsign-compare" /* lint needs to change  */
#pragma GCC diagnostic ignored "-Wtype-limits" /* makes macros unsafe  */
#pragma GCC diagnostic ignored "-Woverflow" /* also breaks macros  */
#pragma GCC diagnostic ignored "-Wformat" /* forces only gnu pf */
#pragma GCC diagnostic ignored "-Wunused-parameter" /* extreme prejudice */
#pragma GCC diagnostic ignored "-Wunused-function" /* contradicts dce! */
#pragma GCC diagnostic ignored "-Wunused-variable" /* belongs in tidy */
#pragma GCC diagnostic ignored "-Wformat-extra-args" /* is also broken */
#pragma GCC diagnostic ignored "-Wparentheses" /* annoying tidy */
#pragma GCC diagnostic ignored "-Wdangling-else" /* come on tidy */
#pragma GCC diagnostic ignored "-Wformat-security" /* come on tidy */
#ifndef __cplusplus
#pragma GCC diagnostic ignored "-Wimplicit-int"
#endif /* C++ */
#endif /* GCC || LLVM */
#if defined(__GNUC__) && !defined(__llvm__)
/* why we need authorization to name a variable `yn' */
#pragma GCC diagnostic ignored "-Wbuiltin-declaration-mismatch"
#pragma GCC diagnostic ignored "-Wfree-nonheap-object" /* broken #54202 */
#ifndef __cplusplus
#if __GNUC__ >= 6
#pragma GCC diagnostic ignored /* wut */ "-Wdiscarded-qualifiers"
#pragma GCC diagnostic ignored /* tidy */ "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored /* tidy */ "-Wunused-but-set-parameter"
#endif /* GCC6+ */
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wstringop-truncation"
#endif /* GCC8+ */
#if __GNUC__ + 0 >= 9
#pragma GCC diagnostic ignored /* "always true" breaks dce */ "-Waddress"
#endif /* GCC9+ */
#endif /* !C++ */
#endif /* GCC && !LLVM */
#ifdef __llvm__
#pragma clang diagnostic ignored \
    "-Wincompatible-pointer-types-discards-qualifiers"
#pragma clang diagnostic ignored "-Wbuiltin-requires-header"
#pragma clang diagnostic ignored "-Wparentheses-equality" /*-save-temps*/
#pragma clang diagnostic ignored "-Wunused-value" /*({-save-temps})*/
#pragma clang diagnostic ignored "-Wstring-plus-int" /* special ed */
#pragma clang diagnostic ignored "-Wunused-value" /* extreme prejudice */
#pragma clang diagnostic ignored "-Wbuiltin-requires-header"
#pragma clang diagnostic ignored \
    "-Wincompatible-pointer-types-discards-qualifiers"
#endif /* !GCC && LLVM */
#endif /* ANSI */

#ifndef __W__
#ifndef __STRICT_ANSI__
#if defined(__GNUC__) || defined(__llvm__)
#pragma GCC diagnostic error "-Wpointer-arith"
#pragma GCC diagnostic error "-Wnonnull"
#pragma GCC diagnostic error "-Wunused-result"
#pragma GCC diagnostic error "-Wuninitialized"
#pragma GCC diagnostic error "-Wstrict-aliasing"
#pragma GCC diagnostic error "-Wshift-negative-value"
#ifndef __cplusplus
#pragma GCC diagnostic error "-Wimplicit-function-declaration"
#if __GNUC__ >= 6
#pragma GCC diagnostic error "-Wincompatible-pointer-types"
#if __GNUC__ >= 8
#pragma GCC diagnostic error "-Wmultistatement-macros"
#pragma GCC diagnostic error "-Wpacked-not-aligned"
#pragma GCC diagnostic error "-Wcast-align=strict"
#pragma GCC diagnostic error "-Wif-not-aligned"
#endif /* GCC 8+ */
#endif /* GCC 6+ */
#endif /* __cplusplus */
#endif /* GCC || LLVM */
#if defined(__GNUC__) && !defined(__llvm__)
#pragma GCC diagnostic error "-Wwrite-strings"
#pragma GCC diagnostic error "-Wtrampolines"
#pragma GCC diagnostic error "-Wmaybe-uninitialized"
#pragma GCC diagnostic error "-Wredundant-decls"
#if __GNUC__ >= 6
#pragma GCC diagnostic error "-Wnonnull-compare"
#if !defined(MODE_DBG) && !defined(STACK_FRAME_UNLIMITED)
#pragma GCC diagnostic error "-Wframe-larger-than=4096"
#if __GNUC__ >= 9
#pragma GCC diagnostic error "-Walloca-larger-than=1024"
#pragma GCC diagnostic error "-Wvla-larger-than=1024"
#endif /* GCC 9+ */
#endif /* STACK_FRAME_UNLIMITED */
#elif __GNUC__ >= 9
#pragma GCC diagnostic error /* e.g. fabs not abs */ "-Wabsolute-value"
#endif /* GCC 6+ */
#endif /* GCC && !LLVM */
#ifdef __llvm__
#pragma clang diagnostic error "-Wassume"
#endif /* !GCC && LLVM */
#endif /* ANSI */
#endif /* -w */

#ifndef __STRICT_ANSI__
#define DebugBreak() asm("int3")
#else
#define DebugBreak() (void)0
#endif

#ifndef __STRICT_ANSI__
#define VEIL(CONSTRAINT, EXPRESSION)                             \
  ({                                                             \
    autotype(EXPRESSION) VeiledValue = (EXPRESSION);             \
    asm("" : "=" CONSTRAINT ""(VeiledValue) : "0"(VeiledValue)); \
    VeiledValue;                                                 \
  })
#else
#define VEIL(CONSTRAINT, EXPRESSION) (EXPRESSION)
#endif

#ifndef __STRICT_ANSI__
#define CONCEAL(CONSTRAINT, EXPRESSION)                                   \
  ({                                                                      \
    autotype(EXPRESSION) VeiledValue = (EXPRESSION);                      \
    asm volatile("" : "=" CONSTRAINT ""(VeiledValue) : "0"(VeiledValue)); \
    VeiledValue;                                                          \
  })
#else
#define CONCEAL(CONSTRAINT, EXPRESSION) (EXPRESSION)
#endif

#ifndef __STRICT_ANSI__
#define EXPROPRIATE(EXPRESSION)                    \
  ({                                               \
    asm volatile("" ::"g"(EXPRESSION) : "memory"); \
    0;                                             \
  })
#else
#define EXPROPRIATE(EXPRESSION) (EXPRESSION)
#endif

#if !defined(__STRICT_ANSI__) && !defined(__APPLE__)
#define YOINK(SYMBOL) \
  asm(".section .yoink\n\tnopl\t%a0\n\t.previous" : : "X"(SYMBOL))
#else
#define YOINK(SYMBOL) (void)0
#endif

#if !defined(__STRICT_ANSI__) && !defined(__APPLE__)
#define STATIC_YOINK(SYMBOLSTR) \
  asm(".section .yoink\n\tnopl\t\"" SYMBOLSTR "\"\n\t.previous")
#else
#define STATIC_YOINK(SYMBOLSTR)
#endif

#if !defined(IM_FEELING_NAUGHTY)
#define STATIC_YOINK_SOURCE(PATH) STATIC_YOINK(PATH)
#else
#define STATIC_YOINK_SOURCE(PATH)
#endif

#define MACHINE_CODE_ANALYSIS_BEGIN_
#define MACHINE_CODE_ANALYSIS_END_
#else
#define const
#define volatile
#endif
#ifdef __cplusplus


/*!BEGIN libc/integral/cxx.inc */

#define COSMOPOLITAN_CXX_START_ namespace cosmo {
#define COSMOPOLITAN_CXX_END_   }
#define COSMOPOLITAN_CXX_USING_ using namespace cosmo;
#define COSMOPOLITAN_C_START_   extern "C" {
#define COSMOPOLITAN_C_END_     }

#if !defined(__builtin_types_compatible_p) && !__has_builtin(types_compatible_p)
#if 0 /* todo jart whyyyy */


/*!BEGIN libc/integral/cxxtypescompat.inc */

#define NAME __cxx_types_compatible
#define QUALIFIED(Q1, Q2)       \
  template <class _T, class _U> \
  struct NAME<_T Q1, _U Q2> : NAME<_T, _U> {}

template <class, class>
struct NAME {
  enum { _value = 0 };
};

template <class _T>
struct NAME<_T, _T> {
  enum { _value = 1 };
};

template <class _T, size_t N>
struct NAME<_T[], _T[N]> {
  enum { _value = 1 };
};

template <class _T, size_t N>
struct NAME<_T[N], _T[]> {
  enum { _value = 1 };
};

QUALIFIED(const volatile, );
QUALIFIED(const volatile, const);
QUALIFIED(const, const volatile);
QUALIFIED(volatile, const volatile);
QUALIFIED(const volatile, volatile);
QUALIFIED(const, volatile);
QUALIFIED(volatile, const);
QUALIFIED(, const);
QUALIFIED(const, );
QUALIFIED(, volatile);
QUALIFIED(volatile, );

#undef QUALIFIED
#undef NAME
#define __builtin_types_compatible_p(A, B) \
  (__cxx_types_compatible<A, B>::_value)
#else
#define __builtin_types_compatible_p(A, B) 0
#endif
#endif

#if !defined(__builtin_choose_expr) && !__has_builtin(choose_expr)
#if 1
template <bool _P, typename _T, typename _U>
struct __cxx_choose_expr {
  __cxx_choose_expr(_T _a, _U _b) : _value(_a) {}
  const _T _value;
};
template <typename _T, typename _U>
struct __cxx_choose_expr<false, _T, _U> {
  __cxx_choose_expr(_T _a, _U _b) : _value(_b) {}
  const _U _value;
};
#define __builtin_choose_expr(X, A, B) \
  (__cxx_choose_expr<X, typeof(A), typeof(B)>(A, B)._value)
#else
#define __builtin_choose_expr(X, A, B) ((X) ? (A) : (B))
#endif
#endif
#endif
#endif


/*!BEGIN libc/assert.h */

#define COSMOPOLITAN_LIBC_ASSERT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void __assert_fail(const char *, const char *, int) hidden wontreturn relegated;

#ifdef NDEBUG
#define __ASSERT_FAIL(EXPR, FILE, LINE)
#else
#define __ASSERT_FAIL(EXPR, FILE, LINE) __assert_fail(EXPR, FILE, LINE)
#endif

#define assert(EXPR)                            \
  do {                                          \
    if (!(EXPR)) {                              \
      __ASSERT_FAIL(#EXPR, __FILE__, __LINE__); \
      unreachable;                              \
    }                                           \
  } while (0)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/complex.h */

#define COSMOPOLITAN_LIBC_COMPLEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
#if __STDC_VERSION__ + 0 >= 201112 && !defined(__STDC_NO_COMPLEX__)

#define complex   _Complex
#define imaginary _Imaginary

double cabs(complex double);
double carg(complex double);
double cimag(complex double);
double creal(complex double);

float cabsf(complex float);
float cargf(complex float);
float cimagf(complex float);
float crealf(complex float);

long double cabsl(complex long double);
long double cargl(complex long double);
long double cimagl(complex long double);
long double creall(complex long double);

complex double cacos(complex double);
complex double cacosh(complex double);
complex double casin(complex double);
complex double casinh(complex double);
complex double catan(complex double);
complex double catanh(complex double);
complex double ccos(complex double);
complex double ccosh(complex double);
complex double cexp(complex double);
complex double cexp2(complex double);
complex double clog(complex double);
complex double conj(complex double);
complex double cpow(complex double, complex double);
complex double cproj(complex double);
complex double csin(complex double);
complex double csinh(complex double);
complex double csqrt(complex double);
complex double ctan(complex double);
complex double ctanh(complex double);

complex float cacosf(complex float);
complex float cacoshf(complex float);
complex float casinf(complex float);
complex float casinhf(complex float);
complex float catanf(complex float);
complex float catanhf(complex float);
complex float ccosf(complex float);
complex float ccoshf(complex float);
complex float cexpf(complex float);
complex float cexp2f(complex float);
complex float clogf(complex float);
complex float conjf(complex float);
complex float cpowf(complex float, complex float);
complex float cprojf(complex float);
complex float csinf(complex float);
complex float csinhf(complex float);
complex float csqrtf(complex float);
complex float ctanf(complex float);
complex float ctanhf(complex float);

complex long double cprojl(complex long double);
complex long double csinhl(complex long double);
complex long double csinl(complex long double);
complex long double csqrtl(complex long double);
complex long double ctanhl(complex long double);
complex long double ctanl(complex long double);
complex long double cacoshl(complex long double);
complex long double cacosl(complex long double);
complex long double casinhl(complex long double);
complex long double casinl(complex long double);
complex long double catanhl(complex long double);
complex long double catanl(complex long double);
complex long double ccoshl(complex long double);
complex long double ccosl(complex long double);
complex long double cexpl(complex long double);
complex long double cexp2l(complex long double);
complex long double clogl(complex long double);
complex long double conjl(complex long double);
complex long double cpowl(complex long double, complex long double);

#endif /* C11 */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dce.h */

#define COSMOPOLITAN_LIBC_DCE_H_


/*!BEGIN libc/nexgen32e/kcpuids.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_KCPUIDS_H_

#define KCPUIDS_0H        0
#define KCPUIDS_1H        1
#define KCPUIDS_2H        2
#define KCPUIDS_7H        3
#define KCPUIDS_80000001H 4
#define KCPUIDS_80000007H 5
#define KCPUIDS_16H       6
#define KCPUIDS_LEN       7
#define KCPUIDS_6H        -1 /* TBD: Thermal and Power Management */
#define KCPUIDS_DH        -1 /* TBD: Extended state features */
#define KCPUIDS_80000008H -1 /* TBD: AMD Miscellaneous */
#define KCPUIDS_8000000AH -1 /* TBD: AMD SVM */

#define KCPUIDS_EAX 0
#define KCPUIDS_EBX 1
#define KCPUIDS_ECX 2
#define KCPUIDS_EDX 3

#define KCPUIDS(LEAF, REG) _KCPUIDS(LEAF, REG)
#ifdef __ASSEMBLER__
#define _KCPUIDS(LEAF, REG) KCPUIDS_##LEAF * 16 + KCPUIDS_##REG * 4
#else
#define _KCPUIDS(LEAF, REG) kCpuids[KCPUIDS_##LEAF][KCPUIDS_##REG]
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const unsigned kCpuids[KCPUIDS_LEN][4];

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
/*─────────────────────────────────────────────────────────────────────────────╗
│ cosmopolitan § autotune » dead code elimination                              │
╚─────────────────────────────────────────────────────────────────────────────*/

#ifndef SUPPORT_VECTOR
/**
 * Supported Platforms Tuning Knob (Runtime & Compile-Time)
 * Tuning this bitmask will remove platform polyfills at compile-time.
 */
#define SUPPORT_VECTOR 255
#endif

#define LINUX   1
#define METAL   2
#define WINDOWS 4
#define XNU     8
#define OPENBSD 16
#define FREEBSD 32
#define NETBSD  64

#ifdef NDEBUG
#define NoDebug() 1
#else
#define NoDebug() 0
#endif

#ifdef MODE_DBG
#define IsModeDbg() 1
#else
#define IsModeDbg() 0
#endif

#ifdef __MFENTRY__
#define HaveFentry() 1
#else
#define HaveFentry() 0
#endif

#ifdef TRUSTWORTHY
#define IsTrustworthy() 1
#else
#define IsTrustworthy() 0
#endif

#ifdef SECURITY_BLANKETS
#define UseSecurityBlankets() 1
#else
#define UseSecurityBlankets() 0
#endif

#ifdef TINY
#define IsTiny() 1
#else
#define IsTiny() 0
#endif

#ifdef __OPTIMIZE__
#define IsOptimized() 1
#else
#define IsOptimized() 0
#endif

#if defined(__PIE__) || defined(__PIC__)
#define IsPositionIndependent() 1
#else
#define IsPositionIndependent() 0
#endif

#define SupportsLinux()   ((SUPPORT_VECTOR & LINUX) == LINUX)
#define SupportsMetal()   ((SUPPORT_VECTOR & METAL) == METAL)
#define SupportsWindows() ((SUPPORT_VECTOR & WINDOWS) == WINDOWS)
#define SupportsXnu()     ((SUPPORT_VECTOR & XNU) == XNU)
#define SupportsFreebsd() ((SUPPORT_VECTOR & FREEBSD) == FREEBSD)
#define SupportsOpenbsd() ((SUPPORT_VECTOR & OPENBSD) == OPENBSD)
#define SupportsNetbsd()  ((SUPPORT_VECTOR & NETBSD) == NETBSD)
#define SupportsBsd()     (!!(SUPPORT_VECTOR & (XNU | FREEBSD | OPENBSD | NETBSD)))
#define SupportsSystemv() \
  (!!(SUPPORT_VECTOR & (LINUX | XNU | OPENBSD | FREEBSD | NETBSD)))

#ifndef __ASSEMBLER__
#define IsLinux()   (SupportsLinux() && (__hostos & LINUX))
#define IsMetal()   (SupportsMetal() && (__hostos & METAL))
#define IsWindows() (SupportsWindows() && (__hostos & WINDOWS))
#define IsXnu()     (SupportsXnu() && (__hostos & XNU))
#define IsFreebsd() (SupportsFreebsd() && (__hostos & FREEBSD))
#define IsOpenbsd() (SupportsOpenbsd() && (__hostos & OPENBSD))
#define IsNetbsd()  (SupportsNetbsd() && (__hostos & NETBSD))
#define IsBsd()     (IsXnu() || IsFreebsd() || IsOpenbsd() || IsNetbsd())
#else
/* clang-format off */
#define IsLinux() $LINUX,__hostos(%rip)
#define IsMetal() $METAL,__hostos(%rip)
#define IsWindows() $WINDOWS,__hostos(%rip)
#define IsBsd() $XNU|FREEBSD|OPENBSD|NETBSD,__hostos(%rip)
#define IsXnu() $XNU,__hostos(%rip)
#define IsFreebsd() $FREEBSD,__hostos(%rip)
#define IsOpenbsd() $OPENBSD,__hostos(%rip)
#define IsNetbsd() $NETBSD,__hostos(%rip)
/* clang-format on */
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int __hostos;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/errno.h */

#define COSMOPOLITAN_LIBC_ERRNO_H_

/**
 * @fileoverview System error codes.
 * @see libc/sysv/consts.sh for numbers
 */

#define EPERM           EPERM            /* operation not permitted */
#define ENOENT          ENOENT           /* no such file or directory */
#define ESRCH           ESRCH            /* no such process */
#define EINTR           EINTR            /* interrupted system call */
#define EIO             EIO              /* input/output error */
#define ENXIO           ENXIO            /* no such device or address */
#define E2BIG           E2BIG            /* argument list too long */
#define ENOEXEC         ENOEXEC          /* exec format error */
#define EBADF           EBADF            /* bad file descriptor */
#define ECHILD          ECHILD           /* no child processes */
#define EAGAIN          EAGAIN           /* resource temporarily unavailable */
#define ENOMEM          ENOMEM           /* not enough space */
#define EACCES          EACCES           /* permission denied */
#define EFAULT          EFAULT           /* bad address */
#define ENOTBLK         ENOTBLK          /* block device required */
#define EBUSY           EBUSY            /* device or resource busy */
#define EEXIST          EEXIST           /* file exists */
#define EXDEV           EXDEV            /* improper link */
#define ENODEV          ENODEV           /* no such device */
#define ENOTDIR         ENOTDIR          /* not a directory */
#define EISDIR          EISDIR           /* is a directory */
#define EINVAL          EINVAL           /* invalid argument */
#define ENFILE          ENFILE           /* too many open files in system */
#define EMFILE          EMFILE           /* too many open files */
#define ENOTTY          ENOTTY           /* inappropriate I/O control op */
#define ETXTBSY         ETXTBSY          /* text file busy */
#define EFBIG           EFBIG            /* file too large */
#define ENOSPC          ENOSPC           /* no space left on device */
#define ESPIPE          ESPIPE           /* invalid seek */
#define EROFS           EROFS            /* read-only filesystem */
#define EMLINK          EMLINK           /* too many links */
#define EPIPE           EPIPE            /* broken pipe */
#define EDOM            EDOM             /* argument out of function domain */
#define ERANGE          ERANGE           /* result too large */
#define EDEADLK         EDEADLK          /* resource deadlock avoided */
#define ENAMETOOLONG    ENAMETOOLONG     /* filename too long */
#define ENOLCK          ENOLCK           /* no locks available */
#define ENOSYS          ENOSYS           /* system call not implemented */
#define ENOTEMPTY       ENOTEMPTY        /* directory not empty */
#define ELOOP           ELOOP            /* too many levels of symbolic links */
#define ENOMSG          ENOMSG           /* no message of the desired type */
#define EIDRM           EIDRM            /* identifier removed */
#define ECHRNG          ECHRNG           /* channel number out of range */
#define EL2NSYNC        EL2NSYNC         /* level 2 not synchronized */
#define EL3HLT          EL3HLT           /* level 3 halted */
#define EL3RST          EL3RST           /* level 3 halted */
#define ELNRNG          ELNRNG           /* link number out of range */
#define EUNATCH         EUNATCH          /* protocol driver not attached */
#define ENOCSI          ENOCSI           /* no csi structure available */
#define EL2HLT          EL2HLT           /* level 2 halted */
#define EBADE           EBADE            /* invalid exchange */
#define EBADR           EBADR            /* invalid request descriptor */
#define EXFULL          EXFULL           /* exchange full */
#define ENOANO          ENOANO           /* no anode */
#define EBADRQC         EBADRQC          /* invalid request code */
#define EBADSLT         EBADSLT          /* invalid slot */
#define ENOSTR          ENOSTR           /* no string */
#define ENODATA         ENODATA          /* no data */
#define ETIME           ETIME            /* timer expired */
#define ENOSR           ENOSR            /* out of streams resources */
#define ENONET          ENONET           /* no network */
#define ENOPKG          ENOPKG           /* package not installed */
#define EREMOTE         EREMOTE          /* object is remote */
#define ENOLINK         ENOLINK          /* link severed */
#define EADV            EADV             /* todo */
#define ESRMNT          ESRMNT           /* todo */
#define ECOMM           ECOMM            /* communication error on send */
#define EPROTO          EPROTO           /* protocol error */
#define EMULTIHOP       EMULTIHOP        /* multihop attempted */
#define EDOTDOT         EDOTDOT          /* todo */
#define EBADMSG         EBADMSG          /* bad message */
#define EOVERFLOW       EOVERFLOW        /* value too large for type */
#define ENOTUNIQ        ENOTUNIQ         /* name not unique on network */
#define EBADFD          EBADFD           /* fd in bad *state* (cf. EBADF) */
#define EREMCHG         EREMCHG          /* remote address changed */
#define ELIBACC         ELIBACC          /* cannot access dso */
#define ELIBBAD         ELIBBAD          /* corrupted shared library */
#define ELIBSCN         ELIBSCN          /* a.out section corrupted */
#define ELIBMAX         ELIBMAX          /* too many shared libraries */
#define ELIBEXEC        ELIBEXEC         /* cannot exec a dso directly */
#define EILSEQ          EILSEQ           /* invalid wide character */
#define ERESTART        ERESTART         /* please restart syscall */
#define ESTRPIPE        ESTRPIPE         /* streams pipe error */
#define EUSERS          EUSERS           /* too many users */
#define ENOTSOCK        ENOTSOCK         /* not a socket */
#define EDESTADDRREQ    EDESTADDRREQ     /* dest address needed */
#define EMSGSIZE        EMSGSIZE         /* message too long */
#define EPROTOTYPE      EPROTOTYPE       /* protocol wrong for socket */
#define ENOPROTOOPT     ENOPROTOOPT      /* protocol not available */
#define EPROTONOSUPPORT EPROTONOSUPPORT  /* protocol not supported */
#define ESOCKTNOSUPPORT ESOCKTNOSUPPORT  /* socket type not supported */
#define EOPNOTSUPP      EOPNOTSUPP       /* operation not supported on socket */
#define EPFNOSUPPORT    EPFNOSUPPORT     /* protocol family not supported */
#define EAFNOSUPPORT    EAFNOSUPPORT     /* address family not supported */
#define EADDRINUSE      EADDRINUSE       /* address already in use */
#define EADDRNOTAVAIL   EADDRNOTAVAIL    /* address not available */
#define ENETDOWN        ENETDOWN         /* network is down */
#define ENETUNREACH     ENETUNREACH      /* network unreachable */
#define ENETRESET       ENETRESET        /* connection aborted by network */
#define ECONNABORTED    ECONNABORTED     /* connection aborted */
#define ECONNRESET      ECONNRESET       /* connection reset */
#define ENOBUFS         ENOBUFS          /* no buffer space available */
#define EISCONN         EISCONN          /* socket is connected */
#define ENOTCONN        ENOTCONN         /* the socket is not connected */
#define ESHUTDOWN       ESHUTDOWN        /* no send after endpoint shutdown */
#define ETOOMANYREFS    ETOOMANYREFS     /* too many refs */
#define ETIMEDOUT       ETIMEDOUT        /* connection timed out */
#define ECONNREFUSED    ECONNREFUSED     /* connection refused */
#define EHOSTDOWN       EHOSTDOWN        /* host is down */
#define EHOSTUNREACH    EHOSTUNREACH     /* host is unreachable */
#define EALREADY        EALREADY         /* connection already in progress */
#define EINPROGRESS     EINPROGRESS      /* operation in progress */
#define ESTALE          ESTALE           /* stale file handle */
#define EUCLEAN         EUCLEAN          /* structure needs cleaning */
#define ENOTNAM         ENOTNAM          /* todo */
#define ENAVAIL         ENAVAIL          /* todo */
#define EISNAM          EISNAM           /* is a named type file */
#define EREMOTEIO       EREMOTEIO        /* remote i/o error */
#define EDQUOT          EDQUOT           /* disk quota exceeded */
#define ENOMEDIUM       ENOMEDIUM        /* no medium found */
#define EMEDIUMTYPE     EMEDIUMTYPE      /* wrong medium type */
#define ECANCELED       ECANCELED        /* operation canceled */
#define ENOKEY          ENOKEY           /* required key not available */
#define EKEYEXPIRED     EKEYEXPIRED      /* key has expired */
#define EKEYREVOKED     EKEYREVOKED      /* key has been revoked */
#define EKEYREJECTED    EKEYREJECTED     /* key was rejected by service */
#define EOWNERDEAD      EOWNERDEAD       /* owner died */
#define ENOTRECOVERABLE ENOTRECOVERABLE  /* state not recoverable */
#define ERFKILL         ERFKILL          /* can't op b/c RF-kill */
#define EHWPOISON       EHWPOISON        /* mempage has h/w error */
#define EWOULDBLOCK     EAGAIN           /* poll fd and try again */
#define ENOTSUP         ENOTSUP

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern errno_t errno;

hidden extern const long EPERM;
hidden extern const long ENOENT;
hidden extern const long ESRCH;
hidden extern const long EINTR;
hidden extern const long EIO;
hidden extern const long ENXIO;
hidden extern const long E2BIG;
hidden extern const long ENOEXEC;
hidden extern const long EBADF;
hidden extern const long ECHILD;
hidden extern const long EAGAIN;
hidden extern const long ENOMEM;
hidden extern const long EACCES;
hidden extern const long EFAULT;
hidden extern const long ENOTBLK;
hidden extern const long EBUSY;
hidden extern const long EEXIST;
hidden extern const long EXDEV;
hidden extern const long ENODEV;
hidden extern const long ENOTDIR;
hidden extern const long EISDIR;
hidden extern const long EINVAL;
hidden extern const long ENFILE;
hidden extern const long EMFILE;
hidden extern const long ENOTTY;
hidden extern const long ETXTBSY;
hidden extern const long EFBIG;
hidden extern const long ENOSPC;
hidden extern const long ESPIPE;
hidden extern const long EROFS;
hidden extern const long EMLINK;
hidden extern const long EPIPE;
hidden extern const long EDOM;
hidden extern const long ERANGE;
hidden extern const long EDEADLK;
hidden extern const long ENAMETOOLONG;
hidden extern const long ENOLCK;
hidden extern const long ENOSYS;
hidden extern const long ENOTEMPTY;
hidden extern const long ELOOP;
hidden extern const long ENOMSG;
hidden extern const long EIDRM;
hidden extern const long ECHRNG;
hidden extern const long EL2NSYNC;
hidden extern const long EL3HLT;
hidden extern const long EL3RST;
hidden extern const long ELNRNG;
hidden extern const long EUNATCH;
hidden extern const long ENOCSI;
hidden extern const long EL2HLT;
hidden extern const long EBADE;
hidden extern const long EBADR;
hidden extern const long EXFULL;
hidden extern const long ENOANO;
hidden extern const long EBADRQC;
hidden extern const long EBADSLT;
hidden extern const long ENOSTR;
hidden extern const long ENODATA;
hidden extern const long ETIME;
hidden extern const long ENOSR;
hidden extern const long ENONET;
hidden extern const long ENOPKG;
hidden extern const long EREMOTE;
hidden extern const long ENOLINK;
hidden extern const long EADV;
hidden extern const long ESRMNT;
hidden extern const long ECOMM;
hidden extern const long EPROTO;
hidden extern const long EMULTIHOP;
hidden extern const long EDOTDOT;
hidden extern const long EBADMSG;
hidden extern const long EOVERFLOW;
hidden extern const long ENOTUNIQ;
hidden extern const long EBADFD;
hidden extern const long EREMCHG;
hidden extern const long ELIBACC;
hidden extern const long ELIBBAD;
hidden extern const long ELIBSCN;
hidden extern const long ELIBMAX;
hidden extern const long ELIBEXEC;
hidden extern const long EILSEQ;
hidden extern const long ERESTART;
hidden extern const long ESTRPIPE;
hidden extern const long EUSERS;
hidden extern const long ENOTSOCK;
hidden extern const long EDESTADDRREQ;
hidden extern const long EMSGSIZE;
hidden extern const long EPROTOTYPE;
hidden extern const long ENOPROTOOPT;
hidden extern const long EPROTONOSUPPORT;
hidden extern const long ESOCKTNOSUPPORT;
hidden extern const long EOPNOTSUPP;
hidden extern const long EPFNOSUPPORT;
hidden extern const long EAFNOSUPPORT;
hidden extern const long EADDRINUSE;
hidden extern const long EADDRNOTAVAIL;
hidden extern const long ENETDOWN;
hidden extern const long ENETUNREACH;
hidden extern const long ENETRESET;
hidden extern const long ECONNABORTED;
hidden extern const long ECONNRESET;
hidden extern const long ENOBUFS;
hidden extern const long EISCONN;
hidden extern const long ENOTCONN;
hidden extern const long ESHUTDOWN;
hidden extern const long ETOOMANYREFS;
hidden extern const long ETIMEDOUT;
hidden extern const long ECONNREFUSED;
hidden extern const long EHOSTDOWN;
hidden extern const long EHOSTUNREACH;
hidden extern const long EALREADY;
hidden extern const long EINPROGRESS;
hidden extern const long ESTALE;
hidden extern const long EUCLEAN;
hidden extern const long ENOTNAM;
hidden extern const long ENAVAIL;
hidden extern const long EISNAM;
hidden extern const long EREMOTEIO;
hidden extern const long EDQUOT;
hidden extern const long ENOMEDIUM;
hidden extern const long EMEDIUMTYPE;
hidden extern const long ECANCELED;
hidden extern const long ENOKEY;
hidden extern const long EKEYEXPIRED;
hidden extern const long EKEYREVOKED;
hidden extern const long EKEYREJECTED;
hidden extern const long EOWNERDEAD;
hidden extern const long ENOTRECOVERABLE;
hidden extern const long ERFKILL;
hidden extern const long EHWPOISON;
hidden extern const long ENOTSUP;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/inttypes.h */

#define COSMOPOLITAN_LIBC_INTTYPES_H_

typedef __INT_LEAST8_TYPE__ int_least8_t;
typedef __UINT_LEAST8_TYPE__ uint_least8_t;
typedef __INT_LEAST16_TYPE__ int_least16_t;
typedef __UINT_LEAST16_TYPE__ uint_least16_t;
typedef __INT_LEAST32_TYPE__ int_least32_t;
typedef __UINT_LEAST32_TYPE__ uint_least32_t;
typedef __INT_LEAST64_TYPE__ int_least64_t;
typedef __UINT_LEAST64_TYPE__ uint_least64_t;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define __PRI8 "hh"

#if __SIZEOF_INT__ == 2
#define __PRI16 ""
#elif __SIZEOF_SHORT__ == 2
#define __PRI16 "h"
#elif __SIZEOF_LONG__ == 2
#define __PRI16 "l"
#endif

#if __SIZEOF_INT__ == 4
#define __PRI32 ""
#elif __SIZEOF_LONG__ == 4
#define __PRI32 "l"
#elif __SIZEOF_LONG_LONG__ == 4
#define __PRI32 "ll"
#endif

#if __SIZEOF_INT__ == 8
#define __PRI64 ""
#elif __SIZEOF_LONG__ == 8
#define __PRI64 "l"
#elif __SIZEOF_LONG_LONG__ == 8
#define __PRI64 "ll"
#endif

#if __SIZEOF_INT__ == 16
#define __PRI128 ""
#elif __SIZEOF_LONG__ == 16
#define __PRI128 "l"
#elif __SIZEOF_LONG_LONG__ == 16
#define __PRI128 "ll"
#elif __SIZEOF_INTMAX__ == 16
#define __PRI128 "j"
#endif

#if __SIZEOF_POINTER__ == __SIZEOF_INT__
#define __PRIPTR ""
#elif __SIZEOF_POINTER__ == __SIZEOF_LONG__
#define __PRIPTR "l"
#elif __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__
#define __PRIPTR "ll"
#endif

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » decimal                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRId8   __PRI8 "d"
#define PRId16  __PRI16 "d"
#define PRId32  __PRI32 "d"
#define PRId64  __PRI64 "d"
#define PRId128 __PRI128 "d"

#define PRIdLEAST8   __PRI8 "d"
#define PRIdLEAST16  __PRI16 "d"
#define PRIdLEAST32  __PRI32 "d"
#define PRIdLEAST64  __PRI64 "d"
#define PRIdLEAST128 __PRI128 "d"

#define PRIdFAST8   __PRI8 "d"
#define PRIdFAST16  __PRI16 "d"
#define PRIdFAST32  __PRI32 "d"
#define PRIdFAST64  __PRI64 "d"
#define PRIdFAST128 __PRI128 "d"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » unsigned decimal        ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIu8   __PRI8 "u"
#define PRIu16  __PRI16 "u"
#define PRIu32  __PRI32 "u"
#define PRIu64  __PRI64 "u"
#define PRIu128 __PRI128 "u"

#define PRIuLEAST8   __PRI8 "u"
#define PRIuLEAST16  __PRI16 "u"
#define PRIuLEAST32  __PRI32 "u"
#define PRIuLEAST64  __PRI64 "u"
#define PRIuLEAST128 __PRI128 "u"

#define PRIuFAST8   __PRI8 "u"
#define PRIuFAST16  __PRI16 "u"
#define PRIuFAST32  __PRI32 "u"
#define PRIuFAST64  __PRI64 "u"
#define PRIuFAST128 __PRI128 "u"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » wut                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIi8   __PRI8 "i"
#define PRIi16  __PRI16 "i"
#define PRIi32  __PRI32 "i"
#define PRIi64  __PRI64 "i"
#define PRIi128 __PRI128 "i"

#define PRIiLEAST8   __PRI8 "i"
#define PRIiLEAST16  __PRI16 "i"
#define PRIiLEAST32  __PRI32 "i"
#define PRIiLEAST64  __PRI64 "i"
#define PRIiLEAST128 __PRI128 "i"

#define PRIiFAST8   __PRI8 "i"
#define PRIiFAST16  __PRI16 "i"
#define PRIiFAST32  __PRI32 "i"
#define PRIiFAST64  __PRI64 "i"
#define PRIiFAST128 __PRI128 "i"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » octal                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIo8   __PRI8 "o"
#define PRIo16  __PRI16 "o"
#define PRIo32  __PRI32 "o"
#define PRIo64  __PRI64 "o"
#define PRIo128 __PRI128 "o"

#define PRIoLEAST8   __PRI8 "o"
#define PRIoLEAST16  __PRI16 "o"
#define PRIoLEAST32  __PRI32 "o"
#define PRIoLEAST64  __PRI64 "o"
#define PRIoLEAST128 __PRI128 "o"

#define PRIoFAST8   __PRI8 "o"
#define PRIoFAST16  __PRI16 "o"
#define PRIoFAST32  __PRI32 "o"
#define PRIoFAST64  __PRI64 "o"
#define PRIoFAST128 __PRI128 "o"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » hexadecimal             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIx8   __PRI8 "x"
#define PRIx16  __PRI16 "x"
#define PRIx32  __PRI32 "x"
#define PRIx64  __PRI64 "x"
#define PRIx128 __PRI128 "x"

#define PRIxLEAST8   __PRI8 "x"
#define PRIxLEAST16  __PRI16 "x"
#define PRIxLEAST32  __PRI32 "x"
#define PRIxLEAST64  __PRI64 "x"
#define PRIxLEAST128 __PRI128 "x"

#define PRIxFAST8   __PRI8 "x"
#define PRIxFAST16  __PRI16 "x"
#define PRIxFAST32  __PRI32 "x"
#define PRIxFAST64  __PRI64 "x"
#define PRIxFAST128 __PRI128 "x"

#define PRIX8   __PRI8 "X"
#define PRIX16  __PRI16 "X"
#define PRIX32  __PRI32 "X"
#define PRIX64  __PRI64 "X"
#define PRIX128 __PRI128 "X"

#define PRIXLEAST8   __PRI8 "X"
#define PRIXLEAST16  __PRI16 "X"
#define PRIXLEAST32  __PRI32 "X"
#define PRIXLEAST64  __PRI64 "X"
#define PRIXLEAST128 __PRI128 "X"

#define PRIXFAST8   __PRI8 "X"
#define PRIXFAST16  __PRI16 "X"
#define PRIXFAST32  __PRI32 "X"
#define PRIXFAST64  __PRI64 "X"
#define PRIXFAST128 __PRI128 "X"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » binary                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIb8   __PRI8 "b"
#define PRIb16  __PRI16 "b"
#define PRIb32  __PRI32 "b"
#define PRIb64  __PRI64 "b"
#define PRIb128 __PRI128 "b"

#define PRIbLEAST8   __PRI8 "b"
#define PRIbLEAST16  __PRI16 "b"
#define PRIbLEAST32  __PRI32 "b"
#define PRIbLEAST64  __PRI64 "b"
#define PRIbLEAST128 __PRI128 "b"

#define PRIbFAST8   __PRI8 "b"
#define PRIbFAST16  __PRI16 "b"
#define PRIbFAST32  __PRI32 "b"
#define PRIbFAST64  __PRI64 "b"
#define PRIbFAST128 __PRI128 "b"

#define PRIB8   __PRI8 "B"
#define PRIB16  __PRI16 "B"
#define PRIB32  __PRI32 "B"
#define PRIB64  __PRI64 "B"
#define PRIB128 __PRI128 "B"

#define PRIBLEAST8   __PRI8 "B"
#define PRIBLEAST16  __PRI16 "B"
#define PRIBLEAST32  __PRI32 "B"
#define PRIBLEAST64  __PRI64 "B"
#define PRIBLEAST128 __PRI128 "B"

#define PRIBFAST8   __PRI8 "B"
#define PRIBFAST16  __PRI16 "B"
#define PRIBFAST32  __PRI32 "B"
#define PRIBFAST64  __PRI64 "B"
#define PRIBFAST128 __PRI128 "B"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » printf » miscellaneous           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define PRIdMAX "jd"
#define PRIiMAX "ji"
#define PRIoMAX "jo"
#define PRIuMAX "ju"
#define PRIxMAX "jx"
#define PRIXMAX "jX"

#define PRIdPTR __PRIPTR "d"
#define PRIiPTR __PRIPTR "i"
#define PRIoPTR __PRIPTR "o"
#define PRIuPTR __PRIPTR "u"
#define PRIxPTR __PRIPTR "x"
#define PRIXPTR __PRIPTR "X"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » decimal                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNd8   __PRI8 "d"
#define SCNd16  __PRI16 "d"
#define SCNd32  __PRI32 "d"
#define SCNd64  __PRI64 "d"
#define SCNd128 __PRI128 "d"

#define SCNdLEAST8   __PRI8 "d"
#define SCNdLEAST16  __PRI16 "d"
#define SCNdLEAST32  __PRI32 "d"
#define SCNdLEAST64  __PRI64 "d"
#define SCNdLEAST128 __PRI128 "d"

#define SCNdFAST8   __PRI8 "d"
#define SCNdFAST16  __PRI16 "d"
#define SCNdFAST32  __PRI32 "d"
#define SCNdFAST64  __PRI64 "d"
#define SCNdFAST128 __PRI128 "d"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » flexidecimal             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNi8   __PRI8 "i"
#define SCNi16  __PRI16 "i"
#define SCNi32  __PRI32 "i"
#define SCNi64  __PRI64 "i"
#define SCNi128 __PRI128 "i"

#define SCNiLEAST8   __PRI8 "i"
#define SCNiLEAST16  __PRI16 "i"
#define SCNiLEAST32  __PRI32 "i"
#define SCNiLEAST64  __PRI64 "i"
#define SCNiLEAST128 __PRI128 "i"

#define SCNiFAST8   __PRI8 "i"
#define SCNiFAST16  __PRI16 "i"
#define SCNiFAST32  __PRI32 "i"
#define SCNiFAST64  __PRI64 "i"
#define SCNiFAST128 __PRI128 "i"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » unsigned decimal         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNu8   __PRI8 "u"
#define SCNu16  __PRI16 "u"
#define SCNu32  __PRI32 "u"
#define SCNu64  __PRI64 "u"
#define SCNu128 __PRI128 "u"

#define SCNuLEAST8   __PRI8 "u"
#define SCNuLEAST16  __PRI16 "u"
#define SCNuLEAST32  __PRI32 "u"
#define SCNuLEAST64  __PRI64 "u"
#define SCNuLEAST128 __PRI128 "u"

#define SCNuFAST8   __PRI8 "u"
#define SCNuFAST16  __PRI16 "u"
#define SCNuFAST32  __PRI32 "u"
#define SCNuFAST64  __PRI64 "u"
#define SCNuFAST128 __PRI128 "u"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » octal                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNo8   __PRI8 "o"
#define SCNo16  __PRI16 "o"
#define SCNo32  __PRI32 "o"
#define SCNo64  __PRI64 "o"
#define SCNo128 __PRI128 "o"

#define SCNoLEAST8   __PRI8 "o"
#define SCNoLEAST16  __PRI16 "o"
#define SCNoLEAST32  __PRI32 "o"
#define SCNoLEAST64  __PRI64 "o"
#define SCNoLEAST128 __PRI128 "o"

#define SCNoFAST8   __PRI8 "o"
#define SCNoFAST16  __PRI16 "o"
#define SCNoFAST32  __PRI32 "o"
#define SCNoFAST64  __PRI64 "o"
#define SCNoFAST128 __PRI128 "o"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » hexadecimal              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNx8   __PRI8 "x"
#define SCNx16  __PRI16 "x"
#define SCNx32  __PRI32 "x"
#define SCNx64  __PRI64 "x"
#define SCNx128 __PRI128 "x"

#define SCNxLEAST8   __PRI8 "x"
#define SCNxLEAST16  __PRI16 "x"
#define SCNxLEAST32  __PRI32 "x"
#define SCNxLEAST64  __PRI64 "x"
#define SCNxLEAST128 __PRI128 "x"

#define SCNxFAST8   __PRI8 "x"
#define SCNxFAST16  __PRI16 "x"
#define SCNxFAST32  __PRI32 "x"
#define SCNxFAST64  __PRI64 "x"
#define SCNxFAST128 __PRI128 "x"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » binary                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNb8   __PRI8 "b"
#define SCNb16  __PRI16 "b"
#define SCNb32  __PRI32 "b"
#define SCNb64  __PRI64 "b"
#define SCNb128 __PRI128 "b"

#define SCNbLEAST8   __PRI8 "b"
#define SCNbLEAST16  __PRI16 "b"
#define SCNbLEAST32  __PRI32 "b"
#define SCNbLEAST64  __PRI64 "b"
#define SCNbLEAST128 __PRI128 "b"

#define SCNbFAST8   __PRI8 "b"
#define SCNbFAST16  __PRI16 "b"
#define SCNbFAST32  __PRI32 "b"
#define SCNbFAST64  __PRI64 "b"
#define SCNbFAST128 __PRI128 "b"

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dismal format notation » scanf » miscellaneous            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define SCNdMAX "jd"
#define SCNiMAX "ji"
#define SCNoMAX "jo"
#define SCNuMAX "ju"
#define SCNxMAX "jx"

#define SCNdPTR __PRIPTR "d"
#define SCNiPTR __PRIPTR "i"
#define SCNoPTR __PRIPTR "o"
#define SCNuPTR __PRIPTR "u"
#define SCNxPTR __PRIPTR "x"



/*!BEGIN libc/limits.h */

#define COSMOPOLITAN_LIBC_LIMITS_H_

#define __MAX2MIN(I) (-I - 1)

#define SIZEOF_SHORT       __SIZEOF_SHORT__
#define SIZEOF_INT         __SIZEOF_INT__
#define SIZEOF_LONG        __SIZEOF_LONG__
#define SIZEOF_LONG_LONG   __SIZEOF_LONG_LONG__
#define SIZEOF_POINTER     __SIZEOF_POINTER__
#define SIZEOF_PTRDIFF_T   __SIZEOF_PTRDIFF_T__
#define SIZEOF_SIZE_T      __SIZEOF_SIZE_T__
#define SIZEOF_WCHAR_T     __SIZEOF_WCHAR_T__
#define SIZEOF_WINT_T      __SIZEOF_WINT_T__
#define SIZEOF_FLOAT       __SIZEOF_FLOAT__
#define SIZEOF_FLOAT128    __SIZEOF_FLOAT128__
#define SIZEOF_DOUBLE      __SIZEOF_DOUBLE__
#define SIZEOF_FLOAT80     __SIZEOF_FLOAT80__
#define SIZEOF_LONG_DOUBLE __SIZEOF_LONG_DOUBLE__
#define SIZEOF_INTMAX      __SIZEOF_INTMAX__

#define SCHAR_MAX     __SCHAR_MAX__
#define SHRT_MAX      __SHRT_MAX__
#define INT_MAX       __INT_MAX__
#define LONG_MAX      __LONG_MAX__
#define LLONG_MAX     LONG_LONG_MAX
#define LONG_LONG_MAX __LONG_LONG_MAX__
#define SIZE_MAX      __SIZE_MAX__
#define INT8_MAX      __INT8_MAX__
#define INT16_MAX     __INT16_MAX__
#define INT32_MAX     __INT32_MAX__
#define INT64_MAX     __INT64_MAX__
#define WINT_MAX      __WCHAR_MAX__
#define WCHAR_MAX     __WCHAR_MAX__
#define INTPTR_MAX    __INTPTR_MAX__
#define PTRDIFF_MAX   __PTRDIFF_MAX__

#define SCHAR_MIN     __MAX2MIN(SCHAR_MAX)
#define SHRT_MIN      __MAX2MIN(SHRT_MAX)
#define INT_MIN       __MAX2MIN(INT_MAX)
#define LONG_MIN      __MAX2MIN(LONG_MAX)
#define LLONG_MIN     __MAX2MIN(LLONG_MAX)
#define LONG_LONG_MIN __MAX2MIN(LONG_LONG_MAX)
#define SIZE_MIN      __MAX2MIN(SIZE_MAX)
#define INT8_MIN      __MAX2MIN(INT8_MAX)
#define INT16_MIN     __MAX2MIN(INT16_MAX)
#define INT32_MIN     __MAX2MIN(INT32_MAX)
#define INT64_MIN     __MAX2MIN(INT64_MAX)
#define INTMAX_MIN    __MAX2MIN(INTMAX_MAX)
#define INTPTR_MIN    __MAX2MIN(INTPTR_MAX)
#define WINT_MIN      __MAX2MIN(WINT_MAX)
#define WCHAR_MIN     __MAX2MIN(WCHAR_MAX)
#define PTRDIFF_MIN   __MAX2MIN(PTRDIFF_MAX)

#define USHRT_MAX      (SHRT_MAX << 1 | 1)
#define UINT_MAX       (~0U)
#define ULONG_MAX      (~0LU)
#define ULLONG_MAX     (~0LLU)
#define ULONG_LONG_MAX (~0LLU)

#define UINTPTR_MAX __UINTPTR_MAX__
#define UINT8_MAX   __UINT8_MAX__
#define UINT16_MAX  __UINT16_MAX__
#define UINT32_MAX  __UINT32_MAX__
#define UINT64_MAX  __UINT64_MAX__

#define USHRT_MIN      ((unsigned short)0)
#define UINT_MIN       ((unsigned)0)
#define ULONG_MIN      ((unsigned long)0)
#define ULLONG_MIN     ((unsigned long long)0)
#define ULONG_LONG_MIN ((unsigned long long)0)
#define UINT8_MIN      ((uint8_t)0)
#define UINT16_MIN     ((uint16_t)0)
#define UINT32_MIN     ((uint32_t)0)
#define UINT64_MIN     ((uint64_t)0)
#define UINTMAX_MIN    ((uintmax_t)0)
#define UINTPTR_MIN    ((uintptr_t)0)

#define MB_CUR_MAX 6
#define MB_LEN_MAX 6

#if !(__ASSEMBLER__ + __LINKER__ + 0)

#if __GNUC__ * 100 + __GNUC_MINOR__ >= 406 || defined(__llvm__)
#define INTMAX_MAX \
  (((intmax_t)0x7fffffffffffffff) << 64 | (intmax_t)0xffffffffffffffff)
#define UINTMAX_MAX \
  (((uintmax_t)0xffffffffffffffff) << 64 | (uintmax_t)0xffffffffffffffff)
#define INT128_MIN  INTMAX_MIN
#define INT128_MAX  INTMAX_MAX
#define UINT128_MIN ((uintmax_t)0)
#define UINT128_MAX UINTMAX_MAX
#else
#define INTMAX_MAX  __INT64_MAX__
#define UINTMAX_MAX __UINT64_MAX__
#endif /* GCC 4.6+ */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/literal.h */

#define COSMOPOLITAN_LIBC_LITERAL_H_

#ifdef __INT8_C
#define INT8_C(c)   __INT8_C(c)
#define UINT8_C(c)  __UINT8_C(c)
#define INT16_C(c)  __INT16_C(c)
#define UINT16_C(c) __UINT16_C(c)
#define INT32_C(c)  __INT32_C(c)
#define UINT32_C(c) __UINT32_C(c)
#define INT64_C(c)  __INT64_C(c)
#define UINT64_C(c) __UINT64_C(c)
#else
#define INT8_C(c)   c
#define UINT8_C(c)  c
#define INT16_C(c)  c
#define UINT16_C(c) c
#define INT32_C(c)  c
#define UINT32_C(c) c##U
#define INT64_C(c)  c##L
#define UINT64_C(c) c##UL
#endif

#if __SIZEOF_INTMAX__ == 16
#define INT128_C(c)  ((intmax_t)(c))
#define UINT128_C(c) ((uintmax_t)(c))
#elif __SIZEOF_INTMAX__ == 8
#define INT128_C(c)  __INT64_C(c)
#define UINT128_C(c) __UINT64_C(c)
#endif



/*!BEGIN libc/mach.h */

#define COSMOPOLITAN_LIBC_MACH_H_
/*                                            ▄▄███▄
                                          ▄▄████████▄
                                       ▄█████████████▄
                                   ▄▄███▓▓▓▓▓▓▓▓▓▓▓███▄
                               ▄▄█████▓▓▓█████████▓▓▓██▄
                           ▄▄████████▓▓▓███████▓▓▓▓▓████▄
                        ▄█████░░░████▓▓█████▓▓▓▓█████████▄
                    ▄▄█████████░░░███▓▓█▓▓▓▓▒███████▓▓▒███▄
                 ▄██████████████░░░██▓▓▓▓███████████▓▓█████▄
               ██████████████████░░░██▓▓▓█████████▓▓▓███████▄
                ███░░░░░░█████████▓░░███▓▓▓▓▓▓▓▓▓▓▓█████▒▒▒██▄
               █░███░░░██░░░░░░░░░██░░██████████████▒▒▒▒██████▄
              ███████░░░█████████░░░░░░█████████▒▒▒▒▒██████████▄
              █████ ██░░░███████████████████▒▒▒▒▒██░▒▒██████████▄
              ██████ ██░░░██████████████░███▒████████▒▒██████████▄
             ████████ ███░░█████████████░░████████████▒▒███████████
             █████████ ███░░███████████░░██████████████▒▒███████████
            ▄██████████ ██████████████ ░░███████████████▒▒███████████
            ████████████ ███░░░░░█████░░█████████████████▒▒██████  █
            █████████████ ██████░░░░░░░▒█████████████████████  ████▀
             █████████████ ██████████░░░░░░░░░███████████  ████████
              █████████████ ████████░░███████░░░██████ ▓██████████
               █████████████ ██████░░░████████████  █████████████
╔────────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § xnu's not unix » carnegie mellon mach microkernel         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define XNU_SYSCALL_MASK_MACH     0x1000000
#define XNU_SYSCALL_MASK_UNIX     0x2000000
#define XNU_SYSCALL_MASK_MACH_IPC 0x5000000

#define kXnuCommonPage   0x00007fffffe00000
#define kXnuNtTscBase    0x050 /* uint64_t */
#define kXnuNtScale      0x058 /* uint32_t */
#define kXnuNtShift      0x05c /* uint32_t */
#define kXnuNtNsBase     0x060 /* uint64_t */
#define kXnuNtGeneration 0x068 /* uint32_t */

bool swtch(void);
bool swtch_pri(int pri);



/*!BEGIN libc/macros.h */

#define COSMOPOLITAN_LIBC_MACROS_H_
#if 0
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § macros                                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#endif

/**
 * @fileoverview Common C preprocessor, assembler, and linker macros.
 */

#define TRUE  1
#define FALSE 0

#define alignas(x) _Alignas(x)

#define ROUNDUP(X, K)       (((X) + (K)-1) & -(K))
#define ROUNDDOWN(X, K)     ((X) & -(K))
#define ABS(X)              ((X) >= 0 ? (X) : -(X))
#define MIN(X, Y)           ((Y) > (X) ? (X) : (Y))
#define MAX(X, Y)           ((Y) < (X) ? (X) : (Y))
#define PASTE(A, B)         __PASTE(A, B)
#define STRINGIFY(A)        __STRINGIFY(A)
#define EQUIVALENT(X, Y)    (__builtin_constant_p((X) == (Y)) && ((X) == (Y)))
#define TYPE_BIT(type)      (sizeof(type) * CHAR_BIT)
#define TYPE_SIGNED(type)   (((type)-1) < 0)
#define TYPE_INTEGRAL(type) (((type)0.5) != 0.5)
#define INT_STRLEN_MAXIMUM(type) \
  ((TYPE_BIT(type) - TYPE_SIGNED(type)) * 302 / 1000 + 1 + TYPE_SIGNED(type))

#define ARRAYLEN(A) \
  ((sizeof(A) / sizeof(*(A))) / ((unsigned)!(sizeof(A) % sizeof(*(A)))))

#define __STRINGIFY(A) #A
#define __PASTE(A, B)  A##B
#ifdef __ASSEMBLER__
#endif /* __ASSEMBLER__ */


/*!BEGIN libc/math.h */

#define COSMOPOLITAN_LIBC_MATH_H_
/*─────────────────────────────────────────────────────────────────────────────╗
│ cosmopolitan § mathematics                                                   │
╚─────────────────────────────────────────────────────────────────────────────*/

#define M_E        2.7182818284590452354 /* 𝑒 */
#define M_LOG2_10  0xd.49a784bcd1b8afep-2 /* log₂10 ≈ 3.3219280948873623478 */
#define M_LOG10_2  0x9.a209a84fbcff799p-5 /* log₁₀2 ≈ 0.301029995663981195 */
#define M_LOG2E    0xb.8aa3b295c17f0bcp-3 /* log₂𝑒 ≈ 1.4426950408889634074 */
#define M_LOG10E   0.43429448190325182765  /* log₁₀𝑒 */
#define M_LN2      0xb.17217f7d1cf79acp-4  /* logₑ2 ≈ */
#define M_LN10     2.30258509299404568402  /* logₑ10 */
#define M_TAU      0x1.921fb54442d1846ap+2 /* τ = 2π */
#define M_PI       0x1.921fb54442d1846ap+1 /* π ≈ 3.14159265358979323846 */
#define M_PI_2     1.57079632679489661923  /* π/2 */
#define M_PI_4     0.78539816339744830962  /* π/4 */
#define M_1_PI     0.31830988618379067154  /* 1/π */
#define M_2_PI     0.63661977236758134308  /* 2/π */
#define M_2_SQRTPI 1.12837916709551257390  /* 2/sqrtπ */
#define M_SQRT2    1.41421356237309504880  /* sqrt2 */
#define M_SQRT1_2  0.70710678118654752440  /* 1/sqrt2 */

#define DBL_DECIMAL_DIG  __DBL_DECIMAL_DIG__
#define DBL_DIG          __DBL_DIG__
#define DBL_EPSILON      __DBL_EPSILON__
#define DBL_MANT_DIG     __DBL_MANT_DIG__
#define DBL_MANT_DIG     __DBL_MANT_DIG__
#define DBL_MAX          __DBL_MAX__
#define DBL_MAX_10_EXP   __DBL_MAX_10_EXP__
#define DBL_MAX_EXP      __DBL_MAX_EXP__
#define DBL_MIN          __DBL_MIN__ /* 2.23e–308 ↔ 1.79e308 */
#define DBL_MIN_10_EXP   __DBL_MIN_10_EXP__
#define DBL_MIN_EXP      __DBL_MIN_EXP__
#define DECIMAL_DIG      __LDBL_DECIMAL_DIG__
#define FLT_DECIMAL_DIG  __FLT_DECIMAL_DIG__
#define FLT_RADIX        __FLT_RADIX__
#define FLT_DIG          __FLT_DIG__
#define FLT_EPSILON      __FLT_EPSILON__
#define FLT_MANT_DIG     __FLT_MANT_DIG__
#define FLT_MANT_DIG     __FLT_MANT_DIG__
#define FLT_MAX          __FLT_MAX__
#define FLT_MAX_10_EXP   __FLT_MAX_10_EXP__
#define FLT_MAX_EXP      __FLT_MAX_EXP__
#define FLT_MIN          __FLT_MIN__ /* 1.18e–38 ↔ 3.40e38 */
#define FLT_MIN_10_EXP   __FLT_MIN_10_EXP__
#define FLT_MIN_EXP      __FLT_MIN_EXP__
#define HLF_MAX          6.50e4f
#define HLF_MIN          3.10e-5f
#define LDBL_DECIMAL_DIG __LDBL_DECIMAL_DIG__
#define LDBL_DIG         __LDBL_DIG__
#define LDBL_EPSILON     __LDBL_EPSILON__
#define LDBL_MANT_DIG    __LDBL_MANT_DIG__
#define LDBL_MANT_DIG    __LDBL_MANT_DIG__
#define LDBL_MAX         __LDBL_MAX__
#define LDBL_MAX_10_EXP  __LDBL_MAX_10_EXP__
#define LDBL_MAX_EXP     __LDBL_MAX_EXP__
#define LDBL_MIN         __LDBL_MIN__ /* 3.37e–4932 ↔ 1.18e4932 */
#define LDBL_MIN_10_EXP  __LDBL_MIN_10_EXP__
#define LDBL_MIN_EXP     __LDBL_MIN_EXP__

#define FP_NAN       0
#define FP_INFINITE  1
#define FP_ZERO      2
#define FP_SUBNORMAL 3
#define FP_NORMAL    4

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define NAN      __builtin_nanf("")
#define INFINITY __builtin_inff()
#define HUGE_VAL __builtin_inff()

#if __FLT_EVAL_METHOD__ + 0 == 2
typedef long double float_t;
typedef long double double_t;
#else
typedef float float_t;
typedef double double_t;
#endif

#define isinf(x)             __builtin_isinf(x)
#define isnan(x)             __builtin_isnan(x)
#define isfinite(x)          __builtin_isfinite(x)
#define isnormal(x)          __builtin_isnormal(x)
#define signbit(x)           __builtin_signbit(x)
#define isgreater(x, y)      __builtin_isgreater(x, y)
#define isgreaterequal(x, y) __builtin_isgreaterequal(x, y)
#define isless(x, y)         __builtin_isless(x, y)
#define islessequal(x, y)    __builtin_islessequal(x, y)
#define islessgreater(x, y)  __builtin_islessgreater(x, y)
#define isunordered(x, y)    __builtin_isunordered(x, y)

#define fpclassify(x) \
  __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, x)

double acos(double);
double acosh(double);
double asin(double);
double asinh(double);
double atan(double);
double atan2(double, double);
double atanh(double);
double cbrt(double);
double ceil(double);
double copysign(double, double);
double cos(double);
double cosh(double);
double drem(double, double);
double erf(double);
double erfc(double);
double exp(double);
double exp10(double);
double exp2(double);
double expm1(double);
double fabs(double);
double fdim(double, double);
double floor(double);
double fma(double, double, double);
double fmax(double, double);
double fmin(double, double);
double fmod(double, double);
double hypot(double, double);
double ldexp(double, int);
double log(double);
double log10(double);
double log1p(double);
double log2(double);
double logb(double);
double nearbyint(double);
double nextafter(double, double);
double nexttoward(double, long double);
double pow(double, double);
double pow10(double);
double powi(double, int);
double remainder(double, double);
double rint(double);
double round(double);
double scalb(double, double);
double scalbln(double, long int);
double scalbn(double, int);
double significand(double);
double sin(double);
double sinh(double);
double sqrt(double);
double tan(double);
double tanh(double);
double trunc(double);

float acosf(float);
float acoshf(float);
float asinf(float);
float asinhf(float);
float atan2f(float, float);
float atanf(float);
float atanhf(float);
float cbrtf(float);
float ceilf(float);
float copysignf(float, float);
float cosf(float);
float coshf(float);
float dremf(float, float);
float erfcf(float);
float erff(float);
float exp10f(float);
float exp2f(float);
float expf(float);
float expm1f(float);
float fabsf(float);
float fdimf(float, float);
float floorf(float);
float fmaf(float, float, float);
float fmaxf(float, float);
float fminf(float, float);
float fmodf(float, float);
float hypotf(float, float);
float ldexpf(float, int);
float log10f(float);
float log1pf(float);
float log2f(float);
float logbf(float);
float logf(float);
float nearbyintf(float);
float nextafterf(float, float);
float nexttowardf(float, long double);
float pow10f(float);
float powf(float, float);
float powif(float, int);
float remainderf(float, float);
float rintf(float);
float roundf(float);
float scalbf(float, float);
float scalblnf(float, long int);
float scalbnf(float, int);
float significandf(float);
float sinf(float);
float sinhf(float);
float sqrtf(float);
float tanf(float);
float tanhf(float);
float truncf(float);

long double acoshl(long double);
long double acosl(long double);
long double asinhl(long double);
long double asinl(long double);
long double atan2l(long double, long double);
long double atanhl(long double);
long double atanl(long double);
long double cbrtl(long double);
long double ceill(long double);
long double copysignl(long double, long double);
long double coshl(long double);
long double cosl(long double);
long double dreml(long double, long double);
long double erfcl(long double);
long double erfl(long double);
long double exp10l(long double);
long double exp2l(long double);
long double expl(long double);
long double expm1l(long double);
long double fabsl(long double);
long double fdiml(long double, long double);
long double floorl(long double);
long double fmal(long double, long double, long double);
long double fmaxl(long double, long double);
long double fminl(long double, long double);
long double fmodl(long double, long double);
long double hypotl(long double, long double);
long double ldexpl(long double, int);
long double log10l(long double);
long double log1pl(long double);
long double log2l(long double);
long double logbl(long double);
long double logl(long double);
long double nearbyintl(long double);
long double nextafterl(long double, long double);
long double nexttowardl(long double, long double);
long double pow10l(long double);
long double powil(long double, int);
long double powl(long double, long double);
long double remainderl(long double, long double);
long double rintl(long double);
long double roundl(long double);
long double scalbl(long double, long double);
long double scalblnl(long double, long int);
long double scalbnl(long double, int);
long double significandl(long double);
long double sinhl(long double);
long double sinl(long double);
long double sqrtl(long double);
long double tanhl(long double);
long double tanl(long double);
long double truncl(long double);

long lrint(double);
long lrintf(float);
long lrintl(long double);
long lround(double);
long lroundf(float);
long lroundl(long double);

int ilogbf(float);
int ilogb(double);
int ilogbl(long double);

long long llrint(double);
long long llrintf(float);
long long llrintl(long double);
long long llround(double);
long long llroundf(float);
long long llroundl(long double);

double frexp(double, int *);
double modf(double, double *);
double remquo(double, double, int *);
float frexpf(float, int *);
float modff(float, float *);
float remquof(float, float, int *);
long double frexpl(long double, int *);
long double modfl(long double, long double *);
long double remquol(long double, long double, int *);
void sincos(double, double *, double *);
void sincosf(float, float *, float *);
void sincosl(long double, long double *, long double *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/paths.h */

#define COSMOPOLITAN_LIBC_PATHS_H_

#define _PATH_DEFPATH "/usr/local/bin:/bin:/usr/bin"
#define _PATH_STDPATH "/bin:/usr/bin:/sbin:/usr/sbin"

#define _PATH_BSHELL "/bin/sh"
#define _PATH_CONSOLE "/dev/console"
#define _PATH_DEVNULL "/dev/null"
#define _PATH_KLOG "/proc/kmsg"
#define _PATH_LASTLOG "/var/log/lastlog"
#define _PATH_MAILDIR "/var/mail"
#define _PATH_MAN "/usr/share/man"
#define _PATH_MNTTAB "/etc/fstab"
#define _PATH_MOUNTED "/etc/mtab"
#define _PATH_NOLOGIN "/etc/nologin"
#define _PATH_SENDMAIL "/usr/sbin/sendmail"
#define _PATH_SHADOW "/etc/shadow"
#define _PATH_SHELLS "/etc/shells"
#define _PATH_TTY "/dev/tty"
#define _PATH_UTMP "/dev/null/utmp"
#define _PATH_VI "/usr/bin/vi"
#define _PATH_WTMP "/dev/null/wtmp"

#define _PATH_DEV "/dev/"
#define _PATH_TMP "/tmp/"
#define _PATH_VARDB "/var/lib/misc/"
#define _PATH_VARRUN "/var/run/"
#define _PATH_VARTMP "/var/tmp/"



/*!BEGIN libc/zip.h */

#define COSMOPOLITAN_LIBC_ZIP_H_


/*!BEGIN libc/bits/bits.h */

#define COSMOPOLITAN_LIBC_BITS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define CheckUnsigned(x) ((x) / !((typeof(x))(-1) < 0))

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § bits                                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

extern const uint8_t kReverseBits[256];

uint32_t gray(uint32_t) pureconst;
uint32_t ungray(uint32_t) pureconst;
uint8_t bitreverse8(uint8_t) libcesque pureconst;
uint16_t bitreverse16(uint16_t) libcesque pureconst;
uint32_t bitreverse32(uint32_t) libcesque pureconst;
uint64_t bitreverse64(uint64_t) libcesque pureconst;
unsigned long roundup2pow(unsigned long) libcesque pureconst;
unsigned long roundup2log(unsigned long) libcesque pureconst;
unsigned long rounddown2pow(unsigned long) libcesque pureconst;
unsigned long hamming(unsigned long, unsigned long) pureconst;
intptr_t lockxchg(void *, void *, size_t);
bool cmpxchg(void *, intptr_t, intptr_t, size_t);
bool lockcmpxchg(void *, intptr_t, intptr_t, size_t);
intptr_t atomic_load(void *, size_t);
intptr_t atomic_store(void *, intptr_t, size_t);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § bits » no assembly required                               ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define bitreverse8(X) (kReverseBits[(uint8_t)(X)])
#define bitreverse16(X)                          \
  ((uint16_t)kReverseBits[(uint8_t)(X)] << 010 | \
   kReverseBits[((uint16_t)(X) >> 010) & 0xff])

#define READ16LE(S)                             \
  ((uint16_t)((unsigned char *)(S))[1] << 010 | \
   (uint16_t)((unsigned char *)(S))[0] << 000)
#define READ32LE(S)                             \
  ((uint32_t)((unsigned char *)(S))[3] << 030 | \
   (uint32_t)((unsigned char *)(S))[2] << 020 | \
   (uint32_t)((unsigned char *)(S))[1] << 010 | \
   (uint32_t)((unsigned char *)(S))[0] << 000)
#define READ64LE(S)                             \
  ((uint64_t)((unsigned char *)(S))[7] << 070 | \
   (uint64_t)((unsigned char *)(S))[6] << 060 | \
   (uint64_t)((unsigned char *)(S))[5] << 050 | \
   (uint64_t)((unsigned char *)(S))[4] << 040 | \
   (uint64_t)((unsigned char *)(S))[3] << 030 | \
   (uint64_t)((unsigned char *)(S))[2] << 020 | \
   (uint64_t)((unsigned char *)(S))[1] << 010 | \
   (uint64_t)((unsigned char *)(S))[0] << 000)

#define READ16BE(S)                             \
  ((uint16_t)((unsigned char *)(S))[0] << 010 | \
   (uint16_t)((unsigned char *)(S))[1] << 000)
#define READ32BE(S)                             \
  ((uint32_t)((unsigned char *)(S))[0] << 030 | \
   (uint32_t)((unsigned char *)(S))[1] << 020 | \
   (uint32_t)((unsigned char *)(S))[2] << 010 | \
   (uint32_t)((unsigned char *)(S))[3] << 000)
#define READ64BE(S)                             \
  ((uint64_t)((unsigned char *)(S))[0] << 070 | \
   (uint64_t)((unsigned char *)(S))[1] << 060 | \
   (uint64_t)((unsigned char *)(S))[2] << 050 | \
   (uint64_t)((unsigned char *)(S))[3] << 040 | \
   (uint64_t)((unsigned char *)(S))[4] << 030 | \
   (uint64_t)((unsigned char *)(S))[5] << 020 | \
   (uint64_t)((unsigned char *)(S))[6] << 010 | \
   (uint64_t)((unsigned char *)(S))[7] << 000)

#define WRITE16LE(P, V)             \
  do {                              \
    uint8_t *Ple = (uint8_t *)(P);  \
    uint16_t Vle = (V);             \
    Ple[0] = (uint8_t)(Vle >> 000); \
    Ple[1] = (uint8_t)(Vle >> 010); \
  } while (0)
#define WRITE32LE(P, V)             \
  do {                              \
    uint8_t *Ple = (uint8_t *)(P);  \
    uint32_t Vle = (V);             \
    Ple[0] = (uint8_t)(Vle >> 000); \
    Ple[1] = (uint8_t)(Vle >> 010); \
    Ple[2] = (uint8_t)(Vle >> 020); \
    Ple[3] = (uint8_t)(Vle >> 030); \
  } while (0)
#define WRITE64LE(P, V)             \
  do {                              \
    uint8_t *Ple = (uint8_t *)(P);  \
    uint64_t Vle = (V);             \
    Ple[0] = (uint8_t)(Vle >> 000); \
    Ple[1] = (uint8_t)(Vle >> 010); \
    Ple[2] = (uint8_t)(Vle >> 020); \
    Ple[3] = (uint8_t)(Vle >> 030); \
    Ple[4] = (uint8_t)(Vle >> 040); \
    Ple[5] = (uint8_t)(Vle >> 050); \
    Ple[6] = (uint8_t)(Vle >> 060); \
    Ple[7] = (uint8_t)(Vle >> 070); \
  } while (0)

#define WRITE16BE(P, V)             \
  do {                              \
    uint8_t *Ple = (uint8_t *)(P);  \
    uint16_t Vle = (V);             \
    Ple[1] = (uint8_t)(Vle >> 000); \
    Ple[0] = (uint8_t)(Vle >> 010); \
  } while (0)
#define WRITE32BE(P, V)             \
  do {                              \
    uint8_t *Ple = (uint8_t *)(P);  \
    uint32_t Vle = (V);             \
    Ple[3] = (uint8_t)(Vle >> 000); \
    Ple[2] = (uint8_t)(Vle >> 010); \
    Ple[1] = (uint8_t)(Vle >> 020); \
    Ple[0] = (uint8_t)(Vle >> 030); \
  } while (0)
#define WRITE64BE(P, V)             \
  do {                              \
    uint8_t *Ple = (uint8_t *)(P);  \
    uint64_t Vle = (V);             \
    Ple[7] = (uint8_t)(Vle >> 000); \
    Ple[6] = (uint8_t)(Vle >> 010); \
    Ple[5] = (uint8_t)(Vle >> 020); \
    Ple[4] = (uint8_t)(Vle >> 030); \
    Ple[3] = (uint8_t)(Vle >> 040); \
    Ple[2] = (uint8_t)(Vle >> 050); \
    Ple[1] = (uint8_t)(Vle >> 060); \
    Ple[0] = (uint8_t)(Vle >> 070); \
  } while (0)

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § bits » some assembly required                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

/*
 * Constraints for virtual machine flags.
 * @note we beseech clang devs for flag constraints
 */
#ifdef __GCC_ASM_FLAG_OUTPUTS__ /* GCC6+ CLANG10+ */
#define CFLAG_CONSTRAINT  "=@ccc"
#define CFLAG_ASM(OP)     OP
#define ZFLAG_CONSTRAINT  "=@ccz"
#define ZFLAG_ASM(OP)     OP
#define OFLAG_CONSTRAINT  "=@cco"
#define OFLAG_ASM(OP)     OP
#define SFLAG_CONSTRAINT  "=@ccs"
#define SFLAG_ASM(SP)     SP
#define ABOVE_CONSTRAINT  "=@cca" /* i.e. !ZF && !CF */
#define ABOVEFLAG_ASM(OP) OP
#else
#define CFLAG_CONSTRAINT  "=q"
#define CFLAG_ASM(OP)     OP "\n\tsetc\t%b0"
#define ZFLAG_CONSTRAINT  "=q"
#define ZFLAG_ASM(OP)     OP "\n\tsetz\t%b0"
#define OFLAG_CONSTRAINT  "=q"
#define OFLAG_ASM(OP)     OP "\n\tseto\t%b0"
#define SFLAG_CONSTRAINT  "=q"
#define SFLAG_ASM(SP)     OP "\n\tsets\t%b0"
#define ABOVE_CONSTRAINT  "=@cca"
#define ABOVEFLAG_ASM(OP) OP "\n\tseta\t%b0"
#endif

/**
 * Reads scalar from memory w/ one operation.
 *
 * @param MEM is alignas(𝑘) uint𝑘_t[hasatleast 1] where 𝑘 ∈ {8,16,32,64}
 * @return *(MEM)
 * @note defeats compiler load tearing optimizations
 * @note alignas(𝑘) is implied if compiler knows type
 * @note alignas(𝑘) only avoids multi-core / cross-page edge cases
 * @see Intel's Six-Thousand Page Manual V.3A §8.2.3.1
 * @see atomic_store()
 */
#define atomic_load(MEM)                       \
  ({                                           \
    autotype(MEM) Mem = (MEM);                 \
    typeof(*Mem) Reg;                          \
    asm("mov\t%1,%0" : "=r"(Reg) : "m"(*Mem)); \
    Reg;                                       \
  })

/**
 * Saves scalar to memory w/ one operation.
 *
 * This is guaranteed to happen in either one or zero operations,
 * depending on whether or not it's possible for *(MEM) to be read
 * afterwards. This macro only forbids compiler from using >1 ops.
 *
 * @param MEM is alignas(𝑘) uint𝑘_t[hasatleast 1] where 𝑘 ∈ {8,16,32,64}
 * @param VAL is uint𝑘_t w/ better encoding for immediates (constexpr)
 * @return VAL
 * @note alignas(𝑘) on nexgen32e only needed for end of page gotcha
 * @note alignas(𝑘) is implied if compiler knows type
 * @note needed to defeat store tearing optimizations
 * @see Intel Six-Thousand Page Manual Manual V.3A §8.2.3.1
 * @see atomic_load()
 */
#define atomic_store(MEM, VAL)                    \
  ({                                              \
    autotype(VAL) Val = (VAL);                    \
    typeof(&Val) Mem = (MEM);                     \
    asm("mov%z1\t%1,%0" : "=m"(*Mem) : "r"(Val)); \
    Val;                                          \
  })

#define bts(MEM, BIT)     __BitOp("bts", BIT, MEM) /** bit test and set */
#define btr(MEM, BIT)     __BitOp("btr", BIT, MEM) /** bit test and reset */
#define btc(MEM, BIT)     __BitOp("btc", BIT, MEM) /** bit test and complement */
#define lockbts(MEM, BIT) __BitOp("lock bts", BIT, MEM)
#define lockbtr(MEM, BIT) __BitOp("lock btr", BIT, MEM)
#define lockbtc(MEM, BIT) __BitOp("lock btc", BIT, MEM)

#define lockinc(MEM) __ArithmeticOp1("lock inc", MEM)
#define lockdec(MEM) __ArithmeticOp1("lock dec", MEM)
#define locknot(MEM) __ArithmeticOp1("lock not", MEM)
#define lockneg(MEM) __ArithmeticOp1("lock neg", MEM)

#define lockaddeq(MEM, VAL) __ArithmeticOp2("lock add", VAL, MEM)
#define locksubeq(MEM, VAL) __ArithmeticOp2("lock sub", VAL, MEM)
#define lockxoreq(MEM, VAL) __ArithmeticOp2("lock xor", VAL, MEM)
#define lockandeq(MEM, VAL) __ArithmeticOp2("lock and", VAL, MEM)
#define lockoreq(MEM, VAL)  __ArithmeticOp2("lock or", VAL, MEM)

/**
 * Exchanges *MEMORY into *LOCALVAR w/ one operation.
 *
 * @param MEMORY is uint𝑘_t[hasatleast 1] where 𝑘 ∈ {8,16,32,64}
 * @param LOCALVAR is uint𝑘_t[hasatleast 1]
 * @return LOCALVAR[0]
 * @see xchg()
 */
#define lockxchg(MEMORY, LOCALVAR)                            \
  ({                                                          \
    asm("xchg\t%0,%1" : "+%m"(*(MEMORY)), "+r"(*(LOCALVAR))); \
    *(LOCALVAR);                                              \
  })

/**
 * Compares and exchanges.
 *
 * @param IFTHING is uint𝑘_t[hasatleast 1] where 𝑘 ∈ {8,16,32,64}
 * @return true if value was exchanged, otherwise false
 * @see lockcmpxchg()
 */
#define cmpxchg(IFTHING, ISEQUALTOME, REPLACEITWITHME)                        \
  ({                                                                          \
    bool DidIt;                                                               \
    autotype(IFTHING) IfThing = (IFTHING);                                    \
    typeof(*IfThing) IsEqualToMe = (ISEQUALTOME);                             \
    typeof(*IfThing) ReplaceItWithMe = (REPLACEITWITHME);                     \
    asm volatile(ZFLAG_ASM("cmpxchg\t%3,%1")                                  \
                 : ZFLAG_CONSTRAINT(DidIt), "+m"(*IfThing), "+a"(IsEqualToMe) \
                 : "r"(ReplaceItWithMe)                                       \
                 : "cc");                                                     \
    DidIt;                                                                    \
  })

/**
 * Compares and exchanges w/ one operation.
 *
 * @param IFTHING is uint𝑘_t[hasatleast 1] where 𝑘 ∈ {8,16,32,64}
 * @return true if value was exchanged, otherwise false
 * @see lockcmpxchg()
 */
#define lockcmpxchg(IFTHING, ISEQUALTOME, REPLACEITWITHME)                    \
  ({                                                                          \
    bool DidIt;                                                               \
    autotype(IFTHING) IfThing = (IFTHING);                                    \
    typeof(*IfThing) IsEqualToMe = (ISEQUALTOME);                             \
    typeof(*IfThing) ReplaceItWithMe = (REPLACEITWITHME);                     \
    asm volatile(ZFLAG_ASM("lock cmpxchg\t%3,%1")                             \
                 : ZFLAG_CONSTRAINT(DidIt), "+m"(*IfThing), "+a"(IsEqualToMe) \
                 : "r"(ReplaceItWithMe)                                       \
                 : "cc");                                                     \
    DidIt;                                                                    \
  })

#define IsAddressCanonicalForm(P)                             \
  ({                                                          \
    intptr_t p2 = (intptr_t)(P);                              \
    (0xffff800000000000l <= p2 && p2 <= 0x00007fffffffffffl); \
  })

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § bits » implementation details                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define __ArithmeticOp1(OP, MEM)                               \
  ({                                                           \
    asm(OP "%z0\t%0" : "+m"(*(MEM)) : /* no inputs */ : "cc"); \
    MEM;                                                       \
  })

#define __ArithmeticOp2(OP, VAL, MEM)                          \
  ({                                                           \
    asm(OP "%z0\t%1,%0" : "+m,m"(*(MEM)) : "i,r"(VAL) : "cc"); \
    MEM;                                                       \
  })

#define __BitOp(OP, BIT, MEM)                                  \
  ({                                                           \
    bool OldBit;                                               \
    if (__builtin_constant_p(BIT)) {                           \
      asm(CFLAG_ASM(OP "%z1\t%2,%1")                           \
          : CFLAG_CONSTRAINT(OldBit),                          \
            "+m"((MEM)[(BIT) / (sizeof((MEM)[0]) * CHAR_BIT)]) \
          : "J"((BIT) % (sizeof((MEM)[0]) * CHAR_BIT))         \
          : "cc");                                             \
    } else if (sizeof((MEM)[0]) == 2) {                        \
      asm(CFLAG_ASM(OP "\t%w2,%1")                             \
          : CFLAG_CONSTRAINT(OldBit), "+m"((MEM)[0])           \
          : "r"(BIT)                                           \
          : "cc");                                             \
    } else if (sizeof((MEM)[0]) == 4) {                        \
      asm(CFLAG_ASM(OP "\t%k2,%1")                             \
          : CFLAG_CONSTRAINT(OldBit), "+m"((MEM)[0])           \
          : "r"(BIT)                                           \
          : "cc");                                             \
    } else if (sizeof((MEM)[0]) == 8) {                        \
      asm(CFLAG_ASM(OP "\t%q2,%1")                             \
          : CFLAG_CONSTRAINT(OldBit), "+m"((MEM)[0])           \
          : "r"(BIT)                                           \
          : "cc");                                             \
    }                                                          \
    OldBit;                                                    \
  })

#else
#define cmpxchg(MEM, CMP, VAL) \
  cmpxchg(MEM, (intptr_t)(CMP), (intptr_t)(VAL), sizeof(*(MEM)))
#define lockcmpxchg(MEM, CMP, VAL) \
  lockcmpxchg(MEM, (intptr_t)(CMP), (intptr_t)(VAL), sizeof(*(MEM)))
#define lockxchg(MEM, VAR) \
  lockxchg(MEM, VAR, sizeof(*(MEM)) / (sizeof(*(MEM)) == sizeof(*(VAR))))
#define atomic_store(MEM, VAL) \
  atomic_store(MEM, VAL, sizeof(*(MEM)) / (sizeof(*(MEM)) == sizeof(*(VAL))))
#define atomic_load(MEM) atomic_load(MEM, sizeof(*(MEM)))
#endif /* __GNUC__ && !__STRICT_ANSI__ */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/str.h */

#define COSMOPOLITAN_LIBC_STR_STR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § characters » asa x3.4-1967                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  fourth age telecommunications */

extern const uint8_t gperf_downcase[256];
extern const uint8_t kToLower[256];
extern const uint16_t kToLower16[256];
extern const uint8_t kBase36[256];
extern const char16_t kCp437[256];

int isascii(int);
int isspace(int);
int isalpha(int);
int isdigit(int);
int isalnum(int);
int isxdigit(int);
int isprint(int);
int islower(int);
int isupper(int);
int isblank(int);
int iscntrl(int);
int isgraph(int);
int tolower(int);
int ispunct(int);
int toupper(int);
int hextoint(int);
int cescapec(int);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § characters » thompson-pike encoding                       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  fifth age telecommunications

      0123456789abcdef
    ┌0─ ☺☻♥♦♣♠•◘○◙♂♀♪♫☼┬───Control
    └1─►◄↕‼¶§▬↨↑↓→←∟↔▲▼┘
    ┌2─ !"#$%&'()*+,-./┐
    │3 0123456789:;<=>?│
    │4 @ABCDEFGHIJKLMNO├───ASA x3.4-1967
    │5 PQRSTUVWXYZ[\]^_│
    │6 `abcdefghijklmno│
    └7─pqrstuvwxyz{|}~⌂┘
    ┌8─ÇüéâäàåçêëèïîìÄÅ┐
    │9 ÉæÆôöòûùÿÖÜ¢£¥€ƒ├───Thompson-Pike Continuation
    │a á¡óúñÑªº¿⌐¬½¼¡«»│    (not really characters)
    └b─░▒▓│┤╡╢╖╕╣║╗╝╜╛┐┘
    ┌c─└┴┬├─┼╞╟╚╔╩╦╠═╬╧┬───1 Continuation will follow
    └d─╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀┘
    ─e─αßΓπΣσμτΦΘΩδ∞φε∩────2 Continuations will follow
     f─≡±≥≤⌠⌡÷≈°∙·√ⁿ²■λ
       │      ││  │││└┤
       │      ││  │└┤ └───5 Continuations follow (and is negative)
       │      │└─┬┘ └─────5 Continuations follow (note: -1=λ┐┐┐┐┐)
       └───┬──┘  └────────4 Continuations follow
           └──────────────3 Continuations follow */

#define INVALID_CODEPOINT 0xfffd

int iswalnum(wint_t);
int iswalpha(wint_t);
int iswblank(wint_t);
int iswcntrl(wint_t);
int iswdigit(wint_t);
int iswgraph(wint_t);
int iswlower(wint_t);
int iswspace(wint_t);
int iswupper(wint_t);
int iswxdigit(wint_t);
int iswpunct(wint_t);
int iswprint(wint_t);
wint_t towlower(wint_t);
wint_t towupper(wint_t);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § strings                                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void *memset(void *, int, size_t) memcpyesque;
void *memcpy(void *restrict, const void *restrict, size_t) memcpyesque;
void *mempcpy(void *restrict, const void *restrict, size_t) memcpyesque;
void *memccpy(void *restrict, const void *restrict, int, size_t) memcpyesque;
void *memmove(void *, const void *, size_t) memcpyesque;
void *memeqmask(void *, const void *, const void *, size_t) memcpyesque;

size_t strlen(const char *) strlenesque;
size_t strnlen(const char *, size_t) strlenesque;
size_t strnlen_s(const char *, size_t);
char *strchr(const char *, int) strlenesque;
char *index(const char *, int) strlenesque;
void *memchr(const void *, int, size_t) strlenesque;
char *strchrnul(const char *, int) strlenesque returnsnonnull;
void *rawmemchr(const void *, int) strlenesque returnsnonnull;
void bzero(void *, size_t) paramsnonnull() libcesque;
void explicit_bzero(void *, size_t) paramsnonnull() libcesque;
size_t strlen16(const char16_t *) strlenesque;
size_t strnlen16(const char16_t *, size_t) strlenesque;
size_t strnlen16_s(const char16_t *, size_t);
char16_t *strchr16(const char16_t *, int) strlenesque;
void *memchr16(const void *, int, size_t) strlenesque;
char16_t *strchrnul16(const char16_t *, int) strlenesque returnsnonnull;
void *rawmemchr16(const void *, int) strlenesque returnsnonnull;
size_t wcslen(const wchar_t *) strlenesque;
size_t wcsnlen(const wchar_t *, size_t) strlenesque;
size_t wcsnlen_s(const wchar_t *, size_t);
wchar_t *wcschr(const wchar_t *, wchar_t) strlenesque;
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t) strlenesque;
wchar_t *wcschrnul(const wchar_t *, wchar_t) strlenesque returnsnonnull;
char *strstr(const char *, const char *) strlenesque;
char16_t *strstr16(const char16_t *, const char16_t *) strlenesque;
wchar_t *wcsstr(const wchar_t *, const wchar_t *) strlenesque;
void *rawwmemchr(const void *, wchar_t) strlenesque returnsnonnull;
int memcmp(const void *, const void *, size_t) strlenesque;
int strcmp(const char *, const char *) strlenesque;
int strncmp(const char *, const char *, size_t) strlenesque;
int strcmp16(const char16_t *, const char16_t *) strlenesque;
int strncmp16(const char16_t *, const char16_t *, size_t) strlenesque;
int wcscmp(const wchar_t *, const wchar_t *) strlenesque;
int wcsncmp(const wchar_t *, const wchar_t *, size_t) strlenesque;
int wmemcmp(const wchar_t *, const wchar_t *, size_t) strlenesque;
int strcasecmp(const char *, const char *) strlenesque;
int strcasecmp16(const char16_t *, const char16_t *) strlenesque;
int wcscasecmp(const wchar_t *, const wchar_t *) strlenesque;
int strncasecmp(const char *, const char *, size_t) strlenesque;
int strncasecmp16(const char16_t *, const char16_t *, size_t) strlenesque;
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t) strlenesque;
char *strrchr(const char *, int) strlenesque;
void *memrchr(const void *, int, size_t) strlenesque;
char16_t *strrchr16(const char16_t *, int) strlenesque;
void *memrchr16(const void *, int, size_t) strlenesque;
wchar_t *wcsrchr(const wchar_t *, int) strlenesque;
void *wmemrchr(const void *, wchar_t, size_t) strlenesque;
char *strpbrk(const char *, const char *) strlenesque;
char16_t *strpbrk16(const char16_t *, const char16_t *) strlenesque;
wchar_t *wcspbrk(const wchar_t *, const wchar_t *) strlenesque;
size_t strspn(const char *, const char *) strlenesque;
size_t strspn16(const char16_t *, const char16_t *) strlenesque;
size_t wcsspn(const wchar_t *, const wchar_t *) strlenesque;
size_t strcspn(const char *, const char *) strlenesque;
size_t strcspn16(const char16_t *, const char16_t *) strlenesque;
size_t wcscspn(const wchar_t *, const wchar_t *) strlenesque;
void *memfrob(void *, size_t) memcpyesque;
int strcoll(const char *, const char *) strlenesque;
char *strsep(char **, const char *) paramsnonnull();
int strcmpzbw(const uint16_t *, const char *) strlenesque;
int strcasecmpzbw(const uint16_t *, const char *) strlenesque;
char *stpcpy(char *, const char *) memcpyesque;
char *stpncpy(char *, const char *, size_t) memcpyesque;
char *strcat(char *, const char *) memcpyesque;
char16_t *strcat16(char16_t *, const char16_t *) memcpyesque;
wchar_t *wcscat(wchar_t *, const wchar_t *) memcpyesque;
size_t strlcpy(char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
char *strcpy(char *, const char *) memcpyesque;
char16_t *strcpy16(char16_t *, const char16_t *) memcpyesque;
wchar_t *wcscpy(wchar_t *, const wchar_t *) memcpyesque;
char *strncat(char *, const char *, size_t) memcpyesque;
char *strncpy(char *, const char *, size_t) memcpyesque;
char *strtok(char *, const char *) paramsnonnull((2)) libcesque;
char *strtok_r(char *, const char *, char **) paramsnonnull((2, 3));
uint16_t *strcpyzbw(uint16_t *, const char *) memcpyesque;
char *wstrtrunc(uint16_t *) memcpyesque;
char *wstrntrunc(uint16_t *, size_t) memcpyesque;
bool startswith(const char *, const char *) strlenesque;
bool startswith16(const char16_t *, const char16_t *) strlenesque;
bool wcsstartswith(const wchar_t *, const wchar_t *) strlenesque;
bool endswith(const char *, const char *) strlenesque;
bool endswith16(const char16_t *, const char16_t *) strlenesque;
bool wcsendswith(const wchar_t *, const wchar_t *) strlenesque;
const char *IndexDoubleNulString(const char *, unsigned) strlenesque;
int strverscmp(const char *, const char *);
wchar_t *wmemset(wchar_t *, wchar_t, size_t) memcpyesque;
char16_t *memset16(char16_t *, char16_t, size_t) memcpyesque;
compatfn wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t) memcpyesque;
compatfn wchar_t *wmempcpy(wchar_t *, const wchar_t *, size_t) memcpyesque;
compatfn wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t) memcpyesque;
int timingsafe_memcmp(const void *, const void *, size_t);
void *memmem(const void *, size_t, const void *, size_t)
    paramsnonnull() nothrow nocallback nosideeffect;
char *strerror(int) returnsnonnull nothrow nocallback;

char *tinystrstr(const char *, const char *) strlenesque;
char16_t *tinystrstr16(const char16_t *, const char16_t *) strlenesque;
void *tinymemmem(const void *, size_t, const void *, size_t) strlenesque;
void *tinymemccpy(void *, const void *, int, size_t) memcpyesque;

char *strntolower(char *, size_t);
char *strtolower(char *) paramsnonnull();
char *strntoupper(char *, size_t);
char *strtoupper(char *) paramsnonnull();
char *chomp(char *);
char16_t *chomp16(char16_t *);
wchar_t *wchomp(wchar_t *);

bool escapedos(char16_t *, unsigned, const char16_t *, unsigned);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § strings » multibyte                                       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef unsigned mbstate_t;

axdx_t tprecode8to16(char16_t *, size_t, const char *);
axdx_t tprecode16to8(char *, size_t, const char16_t *);
int strcmp8to16(const char *, const char16_t *) strlenesque;
int strncmp8to16(const char *, const char16_t *, size_t) strlenesque;
int strcasecmp8to16(const char *, const char16_t *) strlenesque;
int strncasecmp8to16(const char *, const char16_t *, size_t) strlenesque;
int strcmp16to8(const char16_t *, const char *) strlenesque;
int strncmp16to8(const char16_t *, const char *, size_t) strlenesque;
int strcasecmp16to8(const char16_t *, const char *) strlenesque;
int strncasecmp16to8(const char16_t *, const char *, size_t) strlenesque;
wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
int mbtowc(wchar_t *, const char *, size_t);
size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
size_t mbstowcs(wchar_t *, const char *, size_t);
int wctomb(char *, wchar_t);
int wctob(wint_t);

size_t strclen(const char *) nosideeffect;
size_t strnclen(const char *, size_t) nosideeffect;
size_t strclen16(const char16_t *) nosideeffect;
size_t strnclen16(const char16_t *, size_t) nosideeffect;

typedef unsigned wctype_t;
wctype_t wctype(const char *) strlenesque;
int iswctype(wint_t, wctype_t) pureconst;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § strings » system                                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

char *strsignal(int) returnsnonnull libcesque;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § strings » optimizations                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define __memcpy_isgoodsize(SIZE)                                    \
  (__builtin_constant_p(SIZE) && ((SIZE) <= __BIGGEST_ALIGNMENT__ && \
                                  __builtin_popcountl((unsigned)(SIZE)) == 1))

#define __memset_isgoodsize(SIZE)                   \
  (__builtin_constant_p(SIZE) &&                    \
   (((SIZE) <= __BIGGEST_ALIGNMENT__ &&             \
     __builtin_popcountl((unsigned)(SIZE)) == 1) || \
    ((SIZE) % __BIGGEST_ALIGNMENT__ == 0 &&         \
     (SIZE) / __BIGGEST_ALIGNMENT__ <= 3)))

#define memcpy(DEST, SRC, SIZE)                                  \
  (__memcpy_isgoodsize(SIZE) ? __builtin_memcpy(DEST, SRC, SIZE) \
                             : __memcpy("MemCpy", DEST, SRC, SIZE))

#define memset(DEST, BYTE, SIZE)                                  \
  (__memset_isgoodsize(SIZE) ? __builtin_memset(DEST, BYTE, SIZE) \
                             : __memset(DEST, BYTE, SIZE))

#if defined(__STDC_HOSTED__) && defined(__SSE2__)

#define strlen(STR)                                       \
  (__builtin_constant_p(STR) ? __builtin_strlen(STR) : ({ \
    size_t LeN;                                           \
    const char *StR = (STR);                              \
    asm("call\tstrlen"                                    \
        : "=a"(LeN)                                       \
        : "D"(StR), "m"(*(char(*)[0x7fffffff])StR)        \
        : "rcx", "rdx", "xmm3", "xmm4", "cc");            \
    LeN;                                                  \
  }))

#define memmove(DEST, SRC, SIZE) __memcpy("MemMove", (DEST), (SRC), (SIZE))

#define mempcpy(DEST, SRC, SIZE)                          \
  ({                                                      \
    size_t SIze = (SIZE);                                 \
    (void *)((char *)memcpy((DEST), (SRC), SIze) + SIze); \
  })

#define __memcpy(FN, DEST, SRC, SIZE)                                      \
  ({                                                                       \
    void *DeSt = (DEST);                                                   \
    const void *SrC = (SRC);                                               \
    size_t SiZe = (SIZE);                                                  \
    asm("call\t" FN                                                        \
        : "=m"(*(char(*)[SiZe])(DeSt))                                     \
        : "D"(DeSt), "S"(SrC), "d"(SiZe), "m"(*(const char(*)[SiZe])(SrC)) \
        : "xmm3", "xmm4", "rcx", "cc");                                    \
    DeSt;                                                                  \
  })

#define __memset(DEST, BYTE, SIZE)        \
  ({                                      \
    void *DeSt = (DEST);                  \
    size_t SiZe = (SIZE);                 \
    asm("call\tMemSet"                    \
        : "=m"(*(char(*)[SiZe])(DeSt))    \
        : "D"(DeSt), "S"(BYTE), "d"(SiZe) \
        : "xmm3", "xmm4", "rcx", "cc");   \
    DeSt;                                 \
  })

#define explicit_bzero(STR, BYTES)                                          \
  do {                                                                      \
    void *Str;                                                              \
    size_t Bytes;                                                           \
    asm volatile("call\texplicit_bzero"                                     \
                 : "=D"(Str), "=S"(Bytes)                                   \
                 : "0"(STR), "1"(BYTES)                                     \
                 : "rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "memory", \
                   "cc", "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5");   \
  } while (0)

#else /* hosted+sse2 */

#define mempcpy(DEST, SRC, SIZE)                                           \
  ({                                                                       \
    void *Rdi, *Dest = (DEST);                                             \
    const void *Rsi, *Src = (SRC);                                         \
    size_t SiZe = (SIZE);                                                  \
    size_t Rcx;                                                            \
    asm("rep movsb"                                                        \
        : "=D"(Rdi), "=S"(Rsi), "=c"(Rcx), "=m"(*(char(*)[SiZe])(Dest))    \
        : "0"(Dest), "1"(Src), "2"(SiZe), "m"(*(const char(*)[SiZe])(Src)) \
        : "cc");                                                           \
    Rdi;                                                                   \
  })

#define __memcpy(FN, DEST, SRC, SIZE)                                      \
  ({                                                                       \
    void *Rdi, *Dest = (DEST);                                             \
    const void *Rsi, *Src = (SRC);                                         \
    size_t SiZe = (SIZE);                                                  \
    size_t Rcx;                                                            \
    asm("rep movsb"                                                        \
        : "=D"(Rdi), "=S"(Rsi), "=c"(Rcx), "=m"(*(char(*)[SiZe])(Dest))    \
        : "0"(Dest), "1"(Src), "2"(SiZe), "m"(*(const char(*)[SiZe])(Src)) \
        : "cc");                                                           \
    Dest;                                                                  \
  })

#define __memset(DEST, BYTE, SIZE)                           \
  ({                                                         \
    void *Rdi, *Dest = (DEST);                               \
    size_t SiZe = (SIZE);                                    \
    size_t Rcx;                                              \
    asm("rep stosb"                                          \
        : "=D"(Rdi), "=c"(Rcx), "=m"(*(char(*)[SiZe])(Dest)) \
        : "0"(Dest), "1"(SiZe), "a"(BYTE)                    \
        : "cc");                                             \
    Dest;                                                    \
  })

#endif /* hosted/sse2/unbloat */
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § strings » address sanitizer                               ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
void *memset_pure(void *, int, size_t) memcpyesque;
void *memmove_pure(void *, const void *, size_t) memcpyesque;
size_t strlen_pure(const char *) strlenesque;
size_t strcspn_pure(const char *, const char *) strlenesque;
#if defined(__FSANITIZE_ADDRESS__)

#define strcspn(STR, REJECT) strcspn_pure(STR, REJECT)

#undef strlen
#define strlen(STR) \
  (__builtin_constant_p(STR) ? __builtin_strlen(STR) : strlen_pure(STR))

#undef memset
#define memset(DST, CHAR, SIZE)                                  \
  (__memcpy_isgoodsize(SIZE) ? __builtin_memset(DST, CHAR, SIZE) \
                             : memset_pure(DST, CHAR, SIZE))

#undef memmove
#define memmove(DST, SRC, SIZE)                                  \
  (__memcpy_isgoodsize(SIZE) ? __builtin_memmove(DST, SRC, SIZE) \
                             : memmove_pure(DST, SRC, SIZE))

#undef memcpy
#define memcpy(DST, SRC, SIZE)                                  \
  (__memcpy_isgoodsize(SIZE) ? __builtin_memcpy(DST, SRC, SIZE) \
                             : memmove_pure(DST, SRC, SIZE))

#undef mempcpy
#define mempcpy(DST, SRC, SIZE)                                       \
  (__memcpy_isgoodsize(SIZE) ? __builtin_mempcpy(DST, SRC, SIZE) : ({ \
    void *DsT = (DST);                                                \
    size_t SiZe = (SIZE);                                             \
    memmove_pure(DsT, SRC, SiZe);                                     \
    (void *)((char *)DsT + SiZe);                                     \
  }))

#endif /* __FSANITIZE_ADDRESS__ */
#endif /* __GNUC__ && !__STRICT_ANSI__ */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

/**
 * @fileoverview PKZIP Data Structures.
 */

#define kZipAlign 2

#define kZipCosmopolitanVersion 1

#define kZipOsDos         0
#define kZipOsAmiga       1
#define kZipOsOpenvms     2
#define kZipOsUnix        3
#define kZipOsVmcms       4
#define kZipOsAtarist     5
#define kZipOsOs2hpfs     6
#define kZipOsMacintosh   7
#define kZipOsZsystem     8
#define kZipOsCpm         9
#define kZipOsWindowsntfs 10
#define kZipOsMvsos390zos 11
#define kZipOsVse         12
#define kZipOsAcornrisc   13
#define kZipOsVfat        14
#define kZipOsAltmvs      15
#define kZipOsBeos        16
#define kZipOsTandem      17
#define kZipOsOs400       18
#define kZipOsOsxdarwin   19

#define kZipEra1989 10 /* PKZIP 1.0 */
#define kZipEra1993 20 /* PKZIP 2.0: deflate/subdir/etc. support */
#define kZipEra2001 45 /* PKZIP 4.5: kZipExtraZip64 support */

#define kZipIattrBinary 0
#define kZipIattrAscii  1

#define kZipCompressionNone    0
#define kZipCompressionDeflate 8

#define kZipCdirHdrMagic   0x06054b50 /* PK♣♠ "PK\5\6" */
#define kZipCdirHdrMinSize 22
#define kZipCdirAlign      64 /* our choice; actually 2 */
#define kZipCdirHdrLinkableSize \
  ROUNDUP(kZipCfileHdrMinSize + PATH_MAX, kZipCdirAlign)

#define kZipCfileHdrMagic                 0x02014b50 /* PK☺☻ "PK\1\2" */
#define kZipCfileHdrMinSize               46
#define kZipCfileOffsetGeneralflag        8
#define kZipCfileOffsetCompressionmethod  10
#define kZipCfileOffsetLastmodifiedtime   12
#define kZipCfileOffsetLastmodifieddate   14
#define kZipCfileOffsetCrc32              16
#define kZipCfileOffsetCompressedsize     20
#define kZipCfileOffsetUncompressedsize   24
#define kZipCfileOffsetExternalattributes 38
#define kZipCfileOffsetOffset             42

#define kZipLfileHdrMagic                0x04034b50 /* PK♥♦ "PK\3\4" */
#define kZipLfileHdrMinSize              30
#define kZipLfileOffsetGeneralflag       6
#define kZipLfileOffsetCompressionmethod 8
#define kZipLfileOffsetLastmodifiedtime  10
#define kZipLfileOffsetLastmodifieddate  12
#define kZipLfileOffsetCrc32             14
#define kZipLfileOffsetCompressedsize    18

#define kZipGflagUtf8 0x800

#define kZipExtraHdrSize           4
#define kZipExtraZip64             0x0001
#define kZipExtraNtfs              0x000a
#define kZipExtraExtendedTimestamp 0x5455

#define kZipCfileMagic "PK\001\002"

#if !(__ASSEMBLER__ + __LINKER__ + 0)

/* end of central directory record */
#define ZIP_CDIR_MAGIC(P)         READ32LE(P)
#define ZIP_CDIR_DISK(P)          READ16LE((P) + 4)
#define ZIP_CDIR_STARTINGDISK(P)  READ16LE((P) + 6)
#define ZIP_CDIR_RECORDSONDISK(P) READ16LE((P) + 8)
#define ZIP_CDIR_RECORDS(P)       READ16LE((P) + 10)
#define ZIP_CDIR_SIZE(P)          READ32LE((P) + 12)
#define ZIP_CDIR_OFFSET(P)        READ32LE((P) + 16)
#define ZIP_CDIR_COMMENTSIZE(P)   READ16LE((P) + 20)
#define ZIP_CDIR_COMMENT(P)       (&(P)[22])
#define ZIP_CDIR_HDRSIZE(P)       (ZIP_CDIR_COMMENTSIZE(P) + kZipCdirHdrMinSize)

/* central directory file header */
#define ZIP_CFILE_MAGIC(P)          READ32LE(P)
#define ZIP_CFILE_VERSIONMADE(P)    ((P)[4])
#define ZIP_CFILE_FILEATTRCOMPAT(P) ((P)[5])
#define ZIP_CFILE_VERSIONNEED(P)    ((P)[6])
#define ZIP_CFILE_OSNEED(P)         ((P)[7])
#define ZIP_CFILE_GENERALFLAG(P)    READ16LE((P) + kZipCfileOffsetGeneralflag)
#define ZIP_CFILE_COMPRESSIONMETHOD(P) \
  READ16LE((P) + kZipCfileOffsetCompressionmethod)
#define ZIP_CFILE_LASTMODIFIEDTIME(P) \
  READ16LE((P) + kZipCfileOffsetLastmodifiedtime) /* @see DOS_TIME() */
#define ZIP_CFILE_LASTMODIFIEDDATE(P) \
  READ16LE((P) + kZipCfileOffsetLastmodifieddate) /* @see DOS_DATE() */
#define ZIP_CFILE_CRC32(P)          READ32LE((P) + kZipCfileOffsetCrc32)
#define ZIP_CFILE_COMPRESSEDSIZE(P) READ32LE(P + kZipCfileOffsetCompressedsize)
#define ZIP_CFILE_UNCOMPRESSEDSIZE(P) \
  READ32LE((P) + kZipCfileOffsetUncompressedsize)
#define ZIP_CFILE_NAMESIZE(P)           READ16LE((P) + 28)
#define ZIP_CFILE_EXTRASIZE(P)          READ16LE((P) + 30)
#define ZIP_CFILE_COMMENTSIZE(P)        READ16LE((P) + 32)
#define ZIP_CFILE_DISK(P)               READ16LE((P) + 34)
#define ZIP_CFILE_INTERNALATTRIBUTES(P) READ16LE((P) + 36)
#define ZIP_CFILE_EXTERNALATTRIBUTES(P) \
  READ32LE((P) + kZipCfileOffsetExternalattributes)
#define ZIP_CFILE_OFFSET(P) READ32LE((P) + kZipCfileOffsetOffset)
#define ZIP_CFILE_NAME(P)   ((const char *)(&(P)[46])) /* not nul-terminated */
#define ZIP_CFILE_EXTRA(P)  (&(P)[46 + ZIP_CFILE_NAMESIZE(P)])
#define ZIP_CFILE_COMMENT(P) \
  (&(P)[46 + ZIP_CFILE_NAMESIZE(P) + ZIP_CFILE_EXTRASIZE(P)])
#define ZIP_CFILE_HDRSIZE(P)                                                   \
  (ZIP_CFILE_NAMESIZE(P) + ZIP_CFILE_EXTRASIZE(P) + ZIP_CFILE_COMMENTSIZE(P) + \
   kZipCfileHdrMinSize)

/* local file header */
#define ZIP_LFILE_MAGIC(P)       READ32LE(P)
#define ZIP_LFILE_VERSIONNEED(P) ((P)[4])
#define ZIP_LFILE_OSNEED(P)      ((P)[5])
#define ZIP_LFILE_GENERALFLAG(P) READ16LE((P) + kZipLfileOffsetGeneralflag)
#define ZIP_LFILE_COMPRESSIONMETHOD(P) \
  READ16LE((P) + kZipLfileOffsetCompressionmethod)
#define ZIP_LFILE_LASTMODIFIEDTIME(P) \
  READ16LE((P) + kZipLfileOffsetLastmodifiedtime) /* @see DOS_TIME() */
#define ZIP_LFILE_LASTMODIFIEDDATE(P) \
  READ16LE((P) + kZipLfileOffsetLastmodifieddate) /* @see DOS_DATE() */
#define ZIP_LFILE_CRC32(P) READ32LE((P) + kZipLfileOffsetCrc32)
#define ZIP_LFILE_COMPRESSEDSIZE(P) \
  READ32LE((P) + kZipLfileOffsetCompressedsize)
#define ZIP_LFILE_UNCOMPRESSEDSIZE(P) READ32LE((P) + 22)
#define ZIP_LFILE_NAMESIZE(P)         READ16LE((P) + 26)
#define ZIP_LFILE_EXTRASIZE(P)        READ16LE((P) + 28)
#define ZIP_LFILE_NAME(P)             ((const char *)(&(P)[30]))
#define ZIP_LFILE_EXTRA(P)            (&(P)[30 + ZIP_LFILE_NAMESIZE(P)])
#define ZIP_LFILE_HDRSIZE(P) \
  (ZIP_LFILE_NAMESIZE(P) + ZIP_LFILE_EXTRASIZE(P) + kZipLfileHdrMinSize)
#define ZIP_LFILE_CONTENT(P) ((P) + ZIP_LFILE_HDRSIZE(P))
#define ZIP_LFILE_SIZE(P)    (ZIP_LFILE_HDRSIZE(P) + ZIP_LFILE_COMPRESSEDSIZE(P))

#define ZIP_EXTRA_HEADERID(P)    READ16LE(P)
#define ZIP_EXTRA_CONTENTSIZE(P) READ16LE((P) + 2)
#define ZIP_EXTRA_CONTENT(P)     (&(P)[4])
#define ZIP_EXTRA_SIZE(P)        (ZIP_EXTRA_CONTENTSIZE(P) + kZipExtraHdrSize)

uint8_t *zipfindcentraldir(const uint8_t *, size_t);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/alg/alg.h */

#define COSMOPOLITAN_LIBC_ALG_ALG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § algorithms                                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void *bsearch(const void *, const void *, size_t, size_t,
              int cmp(const void *, const void *))
    paramsnonnull() nothrow nosideeffect;
void *bsearch_r(const void *, const void *, size_t, size_t,
                int cmp(const void *, const void *, void *), void *)
    paramsnonnull((1, 2, 5)) nothrow nosideeffect;
void djbsort(int32_t *, size_t);
void qsort(void *, size_t, size_t, int (*)(const void *, const void *))
    paramsnonnull();
void qsort_r(void *, size_t, size_t,
             int cmp(const void *, const void *, void *), void *arg)
    paramsnonnull((1, 4));
int tarjan(int, const int (*)[2], int, int[], int[], int *)
    paramsnonnull((2, 4)) nocallback nothrow;

#define __algalloc returnspointerwithnoaliases nothrow nocallback nodiscard

char *replacestr(const char *, const char *, const char *)
    paramsnonnull() __algalloc;
char16_t *replacestr16(const char16_t *, const char16_t *, const char16_t *)
    paramsnonnull() __algalloc;
wchar_t *replacewcs(const wchar_t *, const wchar_t *, const wchar_t *)
    paramsnonnull() __algalloc;

char *concatstr(const char *, ...) nullterminated() paramsnonnull() __algalloc;
char16_t *concatstr16(const char16_t *, ...) nullterminated()
    paramsnonnull() __algalloc;
wchar_t *concatwcs(const wchar_t *, ...) nullterminated()
    paramsnonnull() __algalloc;

int cmpsb(const void *, const void *);
int cmpub(const void *, const void *);
int cmpsw(const void *, const void *);
int cmpuw(const void *, const void *);
int cmpsl(const void *, const void *);
int cmpul(const void *, const void *);
int cmpsq(const void *, const void *);
int cmpuq(const void *, const void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/alg/critbit0.h */

#define COSMOPOLITAN_LIBC_ALG_CRITBIT0_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § data structures » critical bit tree (for c strings)       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

struct critbit0 {
  void *root;
  size_t count;
};

bool critbit0_contains(struct critbit0 *, const char *) nothrow nosideeffect
    paramsnonnull();
bool critbit0_insert(struct critbit0 *, const char *) paramsnonnull();
bool critbit0_delete(struct critbit0 *, const char *) nothrow paramsnonnull();
void critbit0_clear(struct critbit0 *) nothrow paramsnonnull();
char *critbit0_get(struct critbit0 *, const char *);
intptr_t critbit0_allprefixed(struct critbit0 *, const char *,
                              intptr_t (*)(const char *, void *), void *)
    paramsnonnull((1, 2, 3)) nothrow;
bool critbit0_emplace(struct critbit0 *, char *, size_t) paramsnonnull();

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/alg/reverse.h */

#define COSMOPOLITAN_LIBC_ALG_REVERSE_H_


/*!BEGIN libc/bits/xchg.h */

#define COSMOPOLITAN_LIBC_BITS_XCHG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Exchanges *MEMORY into *LOCALVAR.
 *
 * @return *MEMORY
 * @see lockcmpxchg()
 * todo(jart): what's the point of this?
 */
#define xchg(MEMORY, LOCALVAR)              \
  ({                                        \
    autotype(MEMORY) Memory = (MEMORY);     \
    typeof(Memory) LocalVar = (LOCALVAR);   \
    typeof(*Memory) Temp;                   \
    memcpy(&Temp, Memory, sizeof(Temp));    \
    memcpy(Memory, LocalVar, sizeof(Temp)); \
    memcpy(LocalVar, &Temp, sizeof(Temp));  \
    Temp;                                   \
  })

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Reverses array.
 *
 * @param ARRAY is a typed array or a pointer to one
 * @param COUNT is the number of items
 * @return pointer to start of array
 * @see ARRAYLEN()
 */
#ifndef reverse
#define reverse(ARRAY, COUNT)              \
  ({                                       \
    autotype(&(ARRAY)[0]) Array = (ARRAY); \
    size_t Count = (COUNT);                \
    if (Count) {                           \
      size_t Start = 0;                    \
      size_t End = Count - 1;              \
      while (Start < End) {                \
        xchg(&Array[Start], &Array[End]);  \
        ++Start;                           \
        --End;                             \
      }                                    \
    }                                      \
    Array;                                 \
  })
#endif /* reverse */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/alg/shuffle.h */

#define COSMOPOLITAN_LIBC_RAND_SHUFFLE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Fisher-Yates shuffle.
 *
 * @param R is a function like rand() → ≥0
 * @param A is a typed array
 * @param n is the number of items in A
 * @see ARRAYLEN()
 */
#ifndef shuffle
#define shuffle(R, A, n)                      \
  do {                                        \
    autotype(A) Array = (A);                  \
    for (size_t i = (n)-1; i >= 1; --i) {     \
      xchg(&Array[i], &Array[R() % (i + 1)]); \
    }                                         \
  } while (0)
#endif /* shuffle */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/atomic.h */

#define COSMOPOLITAN_LIBC_BITS_ATOMIC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview C11 version of The Cosmopolitan Atomics Library.
 *
 *   - Forty-two different ways to say MOV.
 *   - Fourteen different ways to say XCHG.
 *   - Twenty different ways to say LOCK CMPXCHG.
 *
 * Living proof high-level languages can be lower-level than assembly.
 */

#define memory_order         int
#define memory_order_relaxed 0
#define memory_order_consume 1
#define memory_order_acquire 2
#define memory_order_release 3
#define memory_order_acq_rel 4
#define memory_order_seq_cst 5

#define atomic_flag            struct AtomicFlag
#define atomic_flag_clear(PTR) atomic_store((PTR)->__cacheline, 0)
#define atomic_flag_test_and_set(PTR)        \
  ({                                         \
    uint32_t ax = 0;                         \
    lockcmpxchg((PTR)->__cacheline, &ax, 1); \
  })
#define atomic_init(PTR, VAL)                         atomic_store(PTR, VAL)
#define atomic_exchange(PTR, VAL)                     lockxchg(PTR, &(VAL))
#define atomic_compare_exchange_strong(X, Y, Z)       lockcmpxchg(X, Y, Z)
#define atomic_compare_exchange_weak(X, Y, Z)         lockcmpxchg(X, Y, Z)
#define atomic_load_explicit(PTR, ORDER)              atomic_load(PTR)
#define atomic_store_explicit(PTR, VAL, ORDER)        atomic_store(PTR, VAL)
#define atomic_flag_clear_explicit(PTR, ORDER)        atomic_store(PTR, 0)
#define atomic_exchange_explicit(PTR, VAL, ORDER)     lockxchg(PTR, &(VAL))
#define atomic_flag_test_and_set_explicit(PTR, ORDER) lockcmpxchg(PTR, 0, 1)
#define atomic_compare_exchange_strong_explicit(X, Y, Z, S, F) \
  lockcmpxchg(X, Y, Z)
#define atomic_compare_exchange_weak_explicit(X, Y, Z, S, F) \
  lockcmpxchg(X, Y, Z)

struct AtomicFlag {
  uint32_t __cacheline[16]; /* Intel V.O §9.4.6 */
} forcealign(64);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/bswap.h */

#define COSMOPOLITAN_LIBC_BITS_BSWAP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint16_t bswap_16(uint16_t) pureconst;
uint32_t bswap_32(uint32_t) pureconst;
uint32_t bswap_64(uint32_t) pureconst;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define bswap_16(x) __builtin_bswap16(x)
#define bswap_32(x) __builtin_bswap32(x)
#define bswap_64(x) __builtin_bswap64(x)
#endif /* defined(__GNUC__) && !defined(__STRICT_ANSI__) */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/ezlea.h */

#define COSMOPOLITAN_LIBC_BITS_EZLEA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#if __pic__ + __pie__ + __code_model_medium__ + __code_model_large__ + 0 > 1
#define ezlea(symbol) "lea\t" symbol "(%%rip),%"
#else
#define ezlea(symbol) "mov\t$" symbol ",%k"
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/hilbert.h */

#define COSMOPOLITAN_LIBC_BITS_HILBERT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

long hilbert(long, long, long) pureconst;
axdx_t unhilbert(long, long) pureconst;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/likely.h */

#define COSMOPOLITAN_LIBC_BITS_LIKELY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define LIKELY(expr)   __builtin_expect(!!(expr), 1)
#define UNLIKELY(expr) __builtin_expect(!!(expr), 0)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/morton.h */

#define COSMOPOLITAN_LIBC_BITS_MORTON_H_


/*!BEGIN libc/intrin/pdep.h */

#define COSMOPOLITAN_LIBC_INTRIN_PDEP_H_


/*!BEGIN libc/nexgen32e/x86feature.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_X86FEATURE_H_


/*!BEGIN libc/nexgen32e/x86compiler.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_X86COMPILER_H_

/**
 * @fileoverview x86 cpu feature compile-time requirement detection.
 * @see -march=native, -mavx2, etc.
 */

#ifdef __AES__
#define _X86_CC_AES 1
#else
#define _X86_CC_AES 0
#endif

#ifdef __AVX__
#define _X86_CC_AVX 1
#else
#define _X86_CC_AVX 0
#endif

#ifdef __AVX2__
#define _X86_CC_AVX2 1
#else
#define _X86_CC_AVX2 0
#endif

#ifdef __ABM__
#define _X86_CC_ABM 1
#else
#define _X86_CC_ABM 0
#endif

#ifdef __BMI__
#define _X86_CC_BMI 1
#else
#define _X86_CC_BMI 0
#endif

#ifdef __BMI2__
#define _X86_CC_BMI2 1
#else
#define _X86_CC_BMI2 0
#endif

#ifdef __FMA__
#define _X86_CC_FMA 1
#else
#define _X86_CC_FMA 0
#endif

#ifdef __ADX__
#define _X86_CC_ADX 1
#else
#define _X86_CC_ADX 0
#endif

#ifdef __PCLMUL__
#define _X86_CC_PCLMUL 1
#else
#define _X86_CC_PCLMUL 0
#endif

#ifdef __POPCNT__
#define _X86_CC_POPCNT 1
#else
#define _X86_CC_POPCNT 0
#endif

#ifdef __RDRND__
#define _X86_CC_RDRND 1
#else
#define _X86_CC_RDRND 0
#endif

#ifdef __RDSEED__
#define _X86_CC_RDSEED 1
#else
#define _X86_CC_RDSEED 0
#endif

#ifdef __SHA__
#define _X86_CC_SHA 1
#else
#define _X86_CC_SHA 0
#endif

#ifdef __SSSE3__
#define _X86_CC_SSSE3 1
#else
#define _X86_CC_SSSE3 0
#endif

#ifdef __SSE__
#define _X86_CC_SSE 1
#else
#define _X86_CC_SSE 0
#endif

#ifdef __SSE2__
#define _X86_CC_SSE2 1
#else
#define _X86_CC_SSE2 0
#endif

#ifdef __SSE3__
#define _X86_CC_SSE3 1
#else
#define _X86_CC_SSE3 0
#endif

#ifdef __SSE4_1__
#define _X86_CC_SSE4_1 1
#else
#define _X86_CC_SSE4_1 0
#endif

#ifdef __SSE4_2__
#define _X86_CC_SSE4_2 1
#else
#define _X86_CC_SSE4_2 0
#endif

#ifdef __XSAVE__
#define _X86_CC_XSAVE 1
#else
#define _X86_CC_XSAVE 0
#endif

#ifdef __CLFLUSHOPT__
#define _X86_CC_CLFLUSHOPT 1
#else
#define _X86_CC_CLFLUSHOPT 0
#endif

#ifdef __RDPID__
#define _X86_CC_RDPID 1
#else
#define _X86_CC_RDPID 0
#endif


/**
 * @fileoverview x86 cpu feature detection.
 */

#define X86_HAVE(FEATURE) _X86_HAVE(X86_##FEATURE)

/* clang-format off */
/*      --- FEATURE              LEAF       REG BIT  COMPILE-TIME-DEFINE  HOOK */
#define X86_ACC                  1H,        EDX, 29, 0,                   _
#define X86_ACPI                 1H,        EDX, 22, 0,                   _
#define X86_ADX                  7H,        EBX, 19, _X86_CC_ADX,         _     /* broadwell c. 2014 */
#define X86_AES                  1H,        ECX, 25, _X86_CC_AES,         _     /* westmere c. 2010 */
#define X86_APIC                 1H,        EDX,  9, 0,                   _
#define X86_ARCH_CAPABILITIES    7H,        EDX, 29, 0,                   _
#define X86_AVX                  1H,        ECX, 28, _X86_CC_AVX,         _     /* sandybridge c. 2012 */
#define X86_AVX2                 7H,        EBX,  5, _X86_CC_AVX2,        _     /* haswell c. 2013 */
#define X86_AVX512BW             7H,        EBX, 30, 0,                   _
#define X86_AVX512CD             7H,        EBX, 28, 0,                   _
#define X86_AVX512DQ             7H,        EBX, 17, 0,                   _
#define X86_AVX512ER             7H,        EBX, 27, 0,                   _
#define X86_AVX512F              7H,        EBX, 16, 0,                   _
#define X86_AVX512IFMA           7H,        EBX, 21, 0,                   _
#define X86_AVX512PF             7H,        EBX, 26, 0,                   _
#define X86_AVX512VBMI           7H,        ECX,  1, 0,                   _
#define X86_AVX512VL             7H,        EBX, 31, 0,                   _
#define X86_AVX512_4FMAPS        7H,        EDX,  3, 0,                   _
#define X86_AVX512_4VNNIW        7H,        EDX,  2, 0,                   _
#define X86_AVX512_BF16          7H,        EAX,  5, 0,                   _
#define X86_AVX512_BITALG        7H,        ECX, 12, 0,                   _
#define X86_AVX512_VBMI2         7H,        ECX,  6, 0,                   _
#define X86_AVX512_VNNI          7H,        ECX, 11, 0,                   _
#define X86_AVX512_VP2INTERSECT  7H,        EDX,  8, 0,                   _
#define X86_AVX512_VPOPCNTDQ     7H,        ECX, 14, 0,                   _
#define X86_BMI                  7H,        EBX,  3, _X86_CC_BMI,         _     /* haswell c. 2013 */
#define X86_BMI2                 7H,        EBX,  8, _X86_CC_BMI2,        _     /* haswell c. 2013 */
#define X86_CID                  1H,        ECX, 10, 0,                   _
#define X86_CLDEMOTE             7H,        ECX, 25, 0,                   _
#define X86_CLFLUSH              1H,        EDX, 19, _X86_CC_SSE2,        _
#define X86_CLFLUSHOPT           7H,        EBX, 23, _X86_CC_CLFLUSHOPT,  _     /* skylake/zen  */
#define X86_CLWB                 7H,        EBX, 24, 0,                   _     /* skylake/zen2 */
#define X86_CMOV                 1H,        EDX, 15, 0,                   _
#define X86_CQM                  7H,        EBX, 12, 0,                   _
#define X86_CX16                 1H,        ECX, 13, 0,                   _
#define X86_CX8                  1H,        EDX,  8, 0,                   _
#define X86_DCA                  1H,        ECX, 18, 0,                   _
#define X86_DE                   1H,        EDX,  2, 0,                   _
#define X86_DS                   1H,        EDX, 21, 0,                   _
#define X86_DSCPL                1H,        ECX,  4, 0,                   _
#define X86_DTES64               1H,        ECX,  2, 0,                   _
#define X86_ERMS                 7H,        EBX,  9, 0,                   _     /* broaadwell c. 2014 */
#define X86_EST                  1H,        ECX,  7, 0,                   _
#define X86_F16C                 1H,        ECX, 29, 0,                   _
#define X86_FDP_EXCPTN_ONLY      7H,        EBX,  6, 0,                   _
#define X86_FLUSH_L1D            7H,        EDX, 28, 0,                   _
#define X86_FMA                  1H,        ECX, 12, _X86_CC_FMA,         _     /* haswell c. 2013 */
#define X86_FPU                  1H,        EDX,  0, 0,                   _
#define X86_FSGSBASE             7H,        EBX,  0, 0,                   _
#define X86_FXSR                 1H,        EDX, 24, 0,                   _
#define X86_GBPAGES              80000001H, EDX, 26, 0,                   _
#define X86_GFNI                 7H,        ECX,  8, 0,                   _
#define X86_HLE                  7H,        EBX,  4, 0,                   _
#define X86_HT                   1H,        EDX, 28, 0,                   _
#define X86_HYPERVISOR           1H,        ECX, 31, 0,                   _
#define X86_IA64                 1H,        EDX, 30, 0,                   _
#define X86_INTEL_PT             7H,        EBX, 25, 0,                   _
#define X86_INTEL_STIBP          7H,        EDX, 27, 0,                   _
#define X86_INVPCID              1H,        EBX, 10, 0,                   _
#define X86_INVTSC               80000007H, EDX,  8, _X86_CC_POPCNT,      _     /* i.e. not a K8 */
#define X86_LA57                 7H,        ECX, 16, 0,                   _
#define X86_LAHF_LM              80000001H, ECX,  0, 0,                   _
#define X86_LM                   80000001H, EDX, 29, 0,                   _
#define X86_MCA                  1H,        EDX, 14, 0,                   _
#define X86_MCE                  1H,        EDX,  7, 0,                   _
#define X86_MD_CLEAR             7H,        EDX, 10, 0,                   _
#define X86_MMX                  1H,        EDX, 23, 0,                   _
#define X86_MOVBE                1H,        ECX, 22, 0,                   _
#define X86_MOVDIR64B            7H,        ECX, 28, 0,                   _
#define X86_MOVDIRI              7H,        ECX, 27, 0,                   _
#define X86_MP                   80000001H, EDX, 19, 0,                   _
#define X86_MPX                  7H,        EBX, 14, 0,                   _
#define X86_MSR                  1H,        EDX,  5, 0,                   _
#define X86_MTRR                 1H,        EDX, 12, 0,                   _
#define X86_MWAIT                1H,        ECX,  3, 0,                   _
#define X86_NX                   80000001H, EDX, 20, 0,                   _
#define X86_OSPKE                7H,        ECX,  4, 0,                   _
#define X86_OSXSAVE              1H,        ECX, 27, 0,                   _
#define X86_PAE                  1H,        EDX,  6, 0,                   _
#define X86_PAT                  1H,        EDX, 16, 0,                   _
#define X86_PBE                  1H,        EDX, 31, 0,                   _
#define X86_PCID                 1H,        ECX, 17, 0,                   _
#define X86_PCLMUL               1H,        ECX,  1, _X86_CC_PCLMUL,      _     /* westmere c. 2010 */
#define X86_PCONFIG              7H,        EDX, 18, 0,                   _
#define X86_PDCM                 1H,        ECX, 15, 0,                   _
#define X86_PGE                  1H,        EDX, 13, 0,                   _
#define X86_PKU                  7H,        ECX,  3, 0,                   _
#define X86_PN                   1H,        EDX, 18, 0,                   _
#define X86_POPCNT               1H,        ECX, 23, _X86_CC_POPCNT,      _     /* nehalem c. 2008 */
#define X86_PSE                  1H,        EDX,  3, 0,                   _
#define X86_PSE36                1H,        EDX, 17, 0,                   _
#define X86_RDPID                7H,        ECX, 22, _X86_CC_RDPID,       _     /* cannonlake c. 2018 */
#define X86_RDRND                1H,        ECX, 30, _X86_CC_RDRND,       _     /* ivybridge c. 2012 */
#define X86_RDSEED               7H,        EBX, 18, _X86_CC_RDSEED,      _     /* broadwell c. 2014 */
#define X86_RDTSCP               80000001H, EDX, 27, 0,                   _
#define X86_RDT_A                7H,        EBX, 15, 0,                   _
#define X86_RTM                  7H,        EBX, 11, 0,                   _
#define X86_SDBG                 1H,        ECX, 11, 0,                   _
#define X86_SELFSNOOP            1H,        EDX, 27, 0,                   _
#define X86_SEP                  1H,        EDX, 11, 0,                   _
#define X86_SHA                  7H,        EBX, 29, _X86_CC_SHA,         _     /* goldmont (2016) */
#define X86_SMAP                 7H,        EBX, 20, 0,                   _
#define X86_SMEP                 7H,        EBX,  7, 0,                   _
#define X86_SMX                  1H,        ECX,  6, 0,                   _
#define X86_SPEC_CTRL            7H,        EDX, 26, 0,                   _
#define X86_SPEC_CTRL_SSBD       7H,        EDX, 31, 0,                   _
#define X86_SSE                  1H,        EDX, 25, _X86_CC_SSE,         _     /* pentium c. 1999 */
#define X86_SSE2                 1H,        EDX, 26, _X86_CC_SSE2,        _     /* pentium c. 2001 */
#define X86_SSE3                 1H,        ECX,  0, _X86_CC_SSE3,        _     /* k8 c. 2005 */
#define X86_SSE4_1               1H,        ECX, 19, _X86_CC_SSE4_1,      _     /* core c. 2006 */
#define X86_SSE4_2               1H,        ECX, 20, _X86_CC_SSE4_2,      _     /* nehalem c. 2008 */
#define X86_SSSE3                1H,        ECX,  9, _X86_CC_SSSE3,       _     /* westmere c. 2010 */
#define X86_SYSCALL              80000001H, EDX, 11, 0,                   _
#define X86_TM2                  1H,        ECX,  8, 0,                   _
#define X86_TME                  7H,        ECX, 13, 0,                   _
#define X86_TSC                  1H,        EDX,  4, 0,                   _
#define X86_TSC_ADJUST           7H,        EBX,  1, 0,                   _
#define X86_TSC_DEADLINE_TIMER   1H,        ECX, 24, 0,                   _
#define X86_TSX_FORCE_ABORT      7H,        EDX, 13, 0,                   _
#define X86_UMIP                 7H,        ECX,  2, 0,                   _
#define X86_VAES                 7H,        ECX,  9, 0,                   _
#define X86_VME                  1H,        EDX,  1, 0,                   _
#define X86_VMX                  1H,        ECX,  5, 0,                   _
#define X86_VPCLMULQDQ           7H,        ECX, 10, 0,                   _
#define X86_WAITPKG              7H,        ECX,  5, 0,                   _
#define X86_X2APIC               1H,        ECX, 21, 0,                   _
#define X86_XSAVE                1H,        ECX, 26, _X86_CC_XSAVE,       _     /* sandybridge c. 2012 */
#define X86_XTPR                 1H,        ECX, 14, 0,                   _
#define X86_ZERO_FCS_FDS         7H,        EBX, 13, 0,                   _
/* clang-format on */

/* AMD specific features */
#define X86_ABM            80000001H, ECX, 5, _X86_CC_ABM, _
#define X86_3DNOW          80000001H, EDX, 31, 0, _
#define X86_3DNOWEXT       80000001H, EDX, 30, 0, _
#define X86_3DNOWPREFETCH  80000001H, ECX, 8, 0, _
#define X86_BPEXT          80000001H, ECX, 26, 0, _
#define X86_CMP_LEGACY     80000001H, ECX, 1, 0, _
#define X86_CR8_LEGACY     80000001H, ECX, 4, 0, _
#define X86_EXTAPIC        80000001H, ECX, 3, 0, _
#define X86_FMA4           80000001H, ECX, 16, 0, _
#define X86_FXSR_OPT       80000001H, EDX, 25, 0, _
#define X86_IBS            80000001H, ECX, 10, 0, _
#define X86_LWP            80000001H, ECX, 15, 0, _
#define X86_MISALIGNSSE    80000001H, ECX, 7, 0, _
#define X86_MMXEXT         80000001H, EDX, 22, 0, _
#define X86_MWAITX         80000001H, ECX, 29, 0, _
#define X86_NODEID_MSR     80000001H, ECX, 19, 0, _
#define X86_OSVW           80000001H, ECX, 9, 0, _
#define X86_OVERFLOW_RECOV 80000007H, EBX, 0, 0, _
#define X86_PERFCTR_CORE   80000001H, ECX, 23, 0, _
#define X86_PERFCTR_LLC    80000001H, ECX, 28, 0, _
#define X86_PERFCTR_NB     80000001H, ECX, 24, 0, _
#define X86_PTSC           80000001H, ECX, 27, 0, _
#define X86_SKINIT         80000001H, ECX, 12, 0, _
#define X86_SMCA           80000007H, EBX, 3, 0, _
#define X86_SSE4A          80000001H, ECX, 6, 0, _
#define X86_SUCCOR         80000007H, EBX, 1, 0, _
#define X86_SVM            80000001H, ECX, 2, 0, _
#define X86_TBM            80000001H, ECX, 21, 0, _
#define X86_TCE            80000001H, ECX, 17, 0, _
#define X86_TOPOEXT        80000001H, ECX, 22, 0, _
#define X86_WDT            80000001H, ECX, 13, 0, _
#define X86_XOP            80000001H, ECX, 11, 0, _

/* Defined but not loaded by kCpuids.S */
#define X86_ARAT            6H, EAX, 2, 0, _
#define X86_AVIC            8000000AH, EDX, 13, 0, _
#define X86_CLZERO          80000008H, EBX, 0, 0, _
#define X86_DECODEASSISTS   8000000AH, EDX, 7, 0, _
#define X86_DTHERM          6H, EAX, 0, 0, _
#define X86_FLUSHBYASID     8000000AH, EDX, 6, 0, _
#define X86_HWP             6H, EAX, 7, 0, _
#define X86_HWP_ACT_WINDOW  6H, EAX, 9, 0, _
#define X86_HWP_EPP         6H, EAX, 10, 0, _
#define X86_HWP_NOTIFY      6H, EAX, 8, 0, _
#define X86_HWP_PKG_REQ     6H, EAX, 11, 0, _
#define X86_IBPB            80000008H, EBX, 12, 0, _
#define X86_IBRS            80000008H, EBX, 14, 0, _
#define X86_IDA             6H, EAX, 1, 0, _
#define X86_IRPERF          80000008H, EBX, 1, 0, _
#define X86_LBRV            8000000AH, EDX, 1, 0, _
#define X86_NPT             8000000AH, EDX, 0, 0, _
#define X86_NRIPS           8000000AH, EDX, 3, 0, _
#define X86_PAUSEFILTER     8000000AH, EDX, 10, 0, _
#define X86_PFTHRESHOLD     8000000AH, EDX, 12, 0, _
#define X86_PLN             6H, EAX, 4, 0, _
#define X86_PTS             6H, EAX, 6, 0, _
#define X86_SSBD            80000008H, EBX, 24, 0, _
#define X86_SSB_NO          80000008H, EBX, 26, 0, _
#define X86_STIBP           80000008H, EBX, 15, 0, _
#define X86_STIBP_ALWAYS_ON 80000008H, EBX, 17, 0, _
#define X86_SVML            8000000AH, EDX, 2, 0, _
#define X86_TSCRATEMSR      8000000AH, EDX, 4, 0, _
#define X86_VGIF            8000000AH, EDX, 16, 0, _
#define X86_VIRT_SSBD       80000008H, EBX, 25, 0, _
#define X86_VMCBCLEAN       8000000AH, EDX, 5, 0, _
#define X86_V_VMSAVE_VMLOAD 8000000AH, EDX, 15, 0, _
#define X86_WBNOINVD        80000008H, EBX, 9, 0, _
#define X86_XGETBV1         DH, EAX, 2, 0, _
#define X86_XSAVEC          DH, EAX, 1, 0, _
#define X86_XSAVEERPTR      80000008H, EBX, 2, 0, _
#define X86_XSAVEOPT        DH, EAX, 0, 0, _
#define X86_XSAVES          DH, EAX, 3, 0, _

#define X86_NEED(FEATURE) _X86_NEED(X86_##FEATURE)
#define X86_WORD(FEATURE) _X86_WORD(X86_##FEATURE)
#define X86_LEAF(FEATURE) _X86_LEAF(X86_##FEATURE)
#define X86_REG(FEATURE)  _X86_REG(X86_##FEATURE)
#define X86_BIT(FEATURE)  _X86_BIT(X86_##FEATURE)

#define _X86_HAVE(FEATURE) __X86_HAVE(FEATURE)
#define _X86_NEED(FEATURE) __X86_NEED(FEATURE)
#define _X86_WORD(FEATURE) __X86_WORD(FEATURE)
#define _X86_LEAF(FEATURE) __X86_LEAF(FEATURE)
#define _X86_REG(FEATURE)  __X86_REG(FEATURE)
#define _X86_BIT(FEATURE)  __X86_BIT(FEATURE)

#define __X86_HAVE(LEAF, REG, BIT, MANDATORY, HOOK) \
  ___X86_HAVE(LEAF, REG, BIT, MANDATORY, _X86_HOOK_##HOOK)
#define __X86_NEED(LEAF, REG, BIT, MANDATORY, HOOK) MANDATORY
#define __X86_WORD(LEAF, REG, BIT, MANDATORY, HOOK) KCPUIDS(LEAF, REG)
#define __X86_LEAF(LEAF, REG, BIT, MANDATORY, HOOK) LEAF
#define __X86_REG(LEAF, REG, BIT, MANDATORY, HOOK)  REG
#define __X86_BIT(LEAF, REG, BIT, MANDATORY, HOOK)  BIT

#ifndef __ASSEMBLER__
#define ___X86_HAVE(LEAF, REG, BIT, MANDATORY, HOOK) \
  HOOK(!!(MANDATORY || KCPUIDS(LEAF, REG) & (1u << BIT)))
#else
#define ___X86_HAVE(LEAF, REG, BIT, MANDATORY, HOOK) \
  $1 << (BIT % 8), BIT / 8 + KCPUIDS(LEAF, REG)
#endif

#define _X86_HOOK__(X) X

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint64_t pdep(uint64_t, uint64_t) pureconst;

#define PDEP(NUMBER, BITMASK)                                                \
  ({                                                                         \
    typeof(BITMASK) ShuffledBits, Number = (NUMBER);                         \
    asm("pdep\t%2,%1,%0" : "=r"(ShuffledBits) : "r"(Number), "rm"(BITMASK)); \
    ShuffledBits;                                                            \
  })

#define pdep(NUMBER, BITMASK) \
  (!X86_HAVE(BMI2) ? pdep(NUMBER, BITMASK) : PDEP(NUMBER, BITMASK))

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pext.h */

#define COSMOPOLITAN_LIBC_INTRIN_PEXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint64_t pext(uint64_t, uint64_t) pureconst;

#define PEXT(NUMBER, BITMASK)                                                \
  ({                                                                         \
    typeof(BITMASK) ShuffledBits, Number = (NUMBER);                         \
    asm("pext\t%2,%1,%0" : "=r"(ShuffledBits) : "r"(Number), "rm"(BITMASK)); \
    ShuffledBits;                                                            \
  })

#define pext(NUMBER, BITMASK) \
  (!X86_HAVE(BMI2) ? pext(NUMBER, BITMASK) : PEXT(NUMBER, BITMASK))

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

unsigned long morton(unsigned long, unsigned long) libcesque;
axdx_t unmorton(unsigned long) libcesque;

#ifndef __STRICT_ANSI__
#define morton(Y, X)                                                          \
  (X86_NEED(BMI2) ? pdep(X, 0x5555555555555555) | pdep(Y, 0xAAAAAAAAAAAAAAAA) \
                  : morton(Y, X))
#define unmorton(I)                                                         \
  (X86_NEED(BMI2)                                                           \
       ? (axdx_t){pext(I, 0xAAAAAAAAAAAAAAAA), pext(I, 0x5555555555555555)} \
       : unmorton(I))
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/popcnt.h */

#define COSMOPOLITAN_LIBC_BITS_POPCNT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

unsigned long popcnt(unsigned long) pureconst;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define popcnt(X)                                         \
  (__builtin_constant_p(X) ? __builtin_popcountll(X) : ({ \
    unsigned long Res, Pop = (X);                         \
    if (X86_HAVE(POPCNT)) {                               \
      asm("popcnt\t%1,%0" : "=r"(Res) : "r"(Pop) : "cc"); \
    } else {                                              \
      Res = (popcnt)(Pop);                                \
    }                                                     \
    Res;                                                  \
  }))
#endif /* GNUC && !ANSI */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/pushpop.h */

#define COSMOPOLITAN_LIBC_BITS_PUSHPOP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#if !defined(__GNUC__) || defined(__STRICT_ANSI__)
#define pushpop(x) (x)
#else
/**
 * PushPop
 * An elegant weapon for a more civilized age.
 */
#define pushpop(x)                                          \
  ({                                                        \
    typeof(x) Popped;                                       \
    if (__builtin_constant_p(x) &&                          \
        (TYPE_SIGNED(typeof(x)) ? (intptr_t)(x) + 128 < 256 \
                                : (intptr_t)(x) < 128)) {   \
      if (x) {                                              \
        asm("push\t%1\n\t"                                  \
            "pop\t%q0"                                      \
            : "=r"(Popped)                                  \
            : "ir"(x));                                     \
      } else {                                              \
        asm("xor\t%k0,%k0" : "=r"(Popped));                 \
      }                                                     \
    } else {                                                \
      asm("" : "=r"(Popped) : "0"(x));                      \
    }                                                       \
    Popped;                                                 \
  })
#endif

#if !defined(__GNUC__) || defined(__STRICT_ANSI__)
#define pushmov(d, x) (*(d) = (x))
#else
#define pushmov(d, x)                                       \
  ({                                                        \
    typeof(*(d)) Popped = (x);                              \
    if (__builtin_constant_p(x) &&                          \
        (TYPE_SIGNED(typeof(x)) ? (intptr_t)(x) + 128 < 256 \
                                : (intptr_t)(x) < 128)) {   \
      asm("pushq\t%1\n\t"                                   \
          "popq\t%0"                                        \
          : "=m"(*(d))                                      \
          : "ir"(Popped));                                  \
    } else {                                                \
      *(d) = Popped;                                        \
    }                                                       \
    Popped;                                                 \
  })
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/safemacros.h */

#define COSMOPOLITAN_LIBC_BITS_SAFEMACROS_H_


/*!BEGIN libc/runtime/runtime.h */

#define COSMOPOLITAN_LIBC_RUNTIME_RUNTIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § runtime                                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef long jmp_buf[8] forcealign(CACHELINE);

extern int g_argc;                                  /* CRT */
extern char **g_argv;                               /* CRT */
extern char **environ;                              /* CRT */
extern unsigned long *g_auxv;                       /* CRT */
extern char *program_invocation_name;               /* RII */
extern char *program_invocation_short_name;         /* RII */
extern uint64_t g_syscount;                         /* RII */
extern const uint64_t kStartTsc;                    /* RII */
extern const char kTmpPath[];                       /* RII */
extern const char kNtSystemDirectory[];             /* RII */
extern const char kNtWindowsDirectory[];            /* RII */
extern unsigned char _base[] forcealign(PAGESIZE);  /* αpε */
extern unsigned char _ehead[] forcealign(PAGESIZE); /* αpε */
extern unsigned char _etext[] forcealign(PAGESIZE); /* αpε */
extern unsigned char _edata[] forcealign(PAGESIZE); /* αpε */
extern unsigned char _end[] forcealign(FRAMESIZE);  /* αpε */
extern unsigned char _ereal;                        /* αpε */
extern unsigned char __privileged_start;            /* αpε */
extern unsigned char __test_start;                  /* αpε */
extern unsigned char __ro;                          /* αpε */
extern unsigned char *__relo_start[];               /* αpε */
extern unsigned char *__relo_end[];                 /* αpε */
extern uint8_t __zip_start[];                       /* αpε */
extern uint8_t __zip_end[];                         /* αpε */

long missingno();
void mcount(void);
unsigned long getauxval(unsigned long);
void *mapanon(size_t) vallocesque attributeallocsize((1));
int setjmp(jmp_buf) libcesque returnstwice paramsnonnull();
void longjmp(jmp_buf, int) libcesque wontreturn paramsnonnull();
void exit(int) wontreturn;
void _exit(int) libcesque wontreturn;
void _Exit(int) libcesque wontreturn;
void abort(void) wontreturn noinstrument;
void panic(void) wontreturn noinstrument privileged;
void triplf(void) wontreturn noinstrument privileged;
int __cxa_atexit(void *, void *, void *) libcesque;
int atfork(void *, void *) libcesque;
int atexit(void (*)(void)) libcesque;
void free_s(void *) paramsnonnull() libcesque;
int close_s(int *) paramsnonnull() libcesque;
char *getenv(const char *) paramsnonnull() nosideeffect libcesque;
int putenv(char *) paramsnonnull();
int setenv(const char *, const char *, int) paramsnonnull();
int unsetenv(const char *);
int clearenv(void);
void fpreset(void);
void savexmm(void *);
void loadxmm(void *);
void peekall(void);
int issetugid(void);
void weakfree(void *) libcesque;
bool isheap(void *);
void *mmap(void *, uint64_t, int32_t, int32_t, int32_t, int64_t);
void *mremap(void *, uint64_t, uint64_t, int32_t, void *);
int munmap(void *, uint64_t);
int mprotect(void *, uint64_t, int) privileged;
int msync(void *, size_t, int);
void __print(const void *, size_t);
void __print_string(const char *);
void *sbrk(intptr_t);
int brk(void *);
int NtGetVersion(void);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § runtime » optimizations                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define _exit(RC) _Exit(RC)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

long min(long, long);
long max(long, long);
long roundup(long, long);
long rounddown(long, long);
bool isempty(const char *);
const char *nulltoempty(const char *);
const char *emptytonull(const char *);
const char *firstnonnull(const char *, const char *);
uint64_t(unsignedsubtract)(uint64_t, uint64_t) pureconst;

#if !defined(__STRICT_ANSI__) && defined(__GNUC__) && \
!defined(__VSCODE_INTELLISENSE__)

#define min(x, y)              \
  ({                           \
    autotype(x) MinX = (x);    \
    autotype(y) MinY = (y);    \
    MinX < MinY ? MinX : MinY; \
  })

#define max(x, y)              \
  ({                           \
    autotype(x) MaxX = (x);    \
    autotype(y) MaxY = (y);    \
    MaxX > MaxY ? MaxX : MaxY; \
  })

#define roundup(x, k)            \
  ({                             \
    autotype(x) RoundupX = (x);  \
    autotype(k) RoundupK = (k);  \
    ROUNDUP(RoundupX, RoundupK); \
  })

#define rounddown(x, k)                \
  ({                                   \
    autotype(x) RounddownX = (x);      \
    autotype(k) RounddownK = (k);      \
    ROUNDDOWN(RounddownX, RounddownK); \
  })

#define isempty(s)              \
  ({                            \
    autotype(s) IsEmptyS = (s); \
    !IsEmptyS || !(*IsEmptyS);  \
  })

#define nulltoempty(s)                \
  ({                                  \
    autotype(s) NullToEmptyS = (s);   \
    NullToEmptyS ? NullToEmptyS : ""; \
  })

#define firstnonnull(a, b)                         \
  ({                                               \
    autotype(a) FirstNonNullA = (a);               \
    autotype(a) FirstNonNullB = (b);               \
    if (!FirstNonNullA && !FirstNonNullB) abort(); \
    FirstNonNullA ? FirstNonNullA : FirstNonNullB; \
  })

#define emptytonull(s)                                      \
  ({                                                        \
    autotype(s) EmptyToNullS = (s);                         \
    EmptyToNullS && !(*EmptyToNullS) ? NULL : EmptyToNullS; \
  })

#define unsignedsubtract(a, b)                                 \
  ({                                                           \
    uint64_t UnsubA = (a);                                     \
    uint64_t UnsubB = (b);                                     \
    UnsubA >= UnsubB ? UnsubA - UnsubB : ~UnsubB + UnsubA + 1; \
  })

#endif /* GNU && !ANSI */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/segmentation.h */

#define COSMOPOLITAN_LIBC_BITS_SEGMENTATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

/**
 * Reads scalar from memory, offset by segment.
 *
 * @return *(MEM) relative to segment
 * @see arch_prctl()
 * @see pushpop()
 */
#define fs(MEM) __peek("fs", MEM)
#define gs(MEM) __peek("gs", MEM)

#define __peek(SEGMENT, ADDRESS)                                  \
  ({                                                              \
    typeof(*(ADDRESS)) Pk;                                        \
    asm("mov\t%%" SEGMENT ":%1,%0" : "=r"(Pk) : "m"(*(ADDRESS))); \
    Pk;                                                           \
  })

#endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/bits/weaken.h */

#define COSMOPOLITAN_LIBC_BITS_WEAKEN_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
#ifndef __STRICT_ANSI__

#define weaken(symbol) ((const typeof(&(symbol)))weakaddr(#symbol))

#define strongaddr(symbolstr)                \
  ({                                         \
    intptr_t waddr;                          \
    asm(ezlea(symbolstr) "0" : "=r"(waddr)); \
    waddr;                                   \
  })

#define weakaddr(symbolstr)                                             \
  ({                                                                    \
    intptr_t waddr;                                                     \
    asm(".weak\t" symbolstr "\n\t" ezlea(symbolstr) "0" : "=r"(waddr)); \
    waddr;                                                              \
  })

#else
#define weaken(symbol)      symbol
#define weakaddr(symbolstr) &(symbolstr)
#endif /* __STRICT_ANSI__ */
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/typedef/sigaction_f.h */

#define COSMOPOLITAN_LIBC_CALLS_TYPEDEF_SIGACTION_F_H_


/*!BEGIN libc/calls/struct/siginfo.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGINFO_H_


/*!BEGIN libc/calls/struct/sigval.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGVAL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

union sigval {
  int32_t sival_int;
  void *sival_ptr;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct siginfo {
  int32_t si_signo;
  int32_t si_errno;
  int32_t si_code;
  union {
    struct {
      union {
        struct {
          int32_t si_pid;
          uint32_t si_uid;
        };
        struct {
          int32_t si_timerid;
          int32_t si_overrun;
        };
      };
      union {
        union sigval si_value;
        struct {
          int32_t si_status;
          int64_t si_utime, si_stime;
        };
      };
    };
    struct {
      void *si_addr;
      int16_t si_addr_lsb;
      union {
        struct {
          void *si_lower;
          void *si_upper;
        };
        uint32_t si_pkey;
      };
    };
    struct {
      int64_t si_band;
      int32_t si_fd;
    };
    struct {
      void *si_call_addr;
      int32_t si_syscall;
      uint32_t si_arch;
    };
    char __ignoreme[128 - 2 * sizeof(int32_t) - sizeof(int64_t)];
  };
} forcealign(8);

typedef struct siginfo siginfo_t;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/ucontext.h */

#define COSMOPOLITAN_LIBC_CALLS_UCONTEXT_H_


/*!BEGIN libc/calls/struct/sigaltstack.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGALTSTACK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct sigaltstack {
  void *ss_sp;
  int ss_flags;
  size_t ss_size;
};

typedef struct sigaltstack stack_t;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sigset.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGSET_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct sigset {
  uint64_t __bits[2];
} sigset_t;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define REG_R8      REG_R8
#define REG_R9      REG_R9
#define REG_R10     REG_R10
#define REG_R11     REG_R11
#define REG_R12     REG_R12
#define REG_R13     REG_R13
#define REG_R14     REG_R14
#define REG_R15     REG_R15
#define REG_RDI     REG_RDI
#define REG_RSI     REG_RSI
#define REG_RBP     REG_RBP
#define REG_RBX     REG_RBX
#define REG_RDX     REG_RDX
#define REG_RAX     REG_RAX
#define REG_RCX     REG_RCX
#define REG_RSP     REG_RSP
#define REG_RIP     REG_RIP
#define REG_EFL     REG_EFL
#define REG_CSGSFS  REG_CSGSFS
#define REG_ERR     REG_ERR
#define REG_TRAPNO  REG_TRAPNO
#define REG_OLDMASK REG_OLDMASK
#define REG_CR2     REG_CR2

enum GeneralRegister {
  REG_R8,
  REG_R9,
  REG_R10,
  REG_R11,
  REG_R12,
  REG_R13,
  REG_R14,
  REG_R15,
  REG_RDI,
  REG_RSI,
  REG_RBP,
  REG_RBX,
  REG_RDX,
  REG_RAX,
  REG_RCX,
  REG_RSP,
  REG_RIP,
  REG_EFL,
  REG_CSGSFS,
  REG_ERR,
  REG_TRAPNO,
  REG_OLDMASK,
  REG_CR2
};

struct XmmRegister {
  uint64_t u64[2];
};

struct FpuStackEntry {
  uint16_t significand[4];
  uint16_t exponent;
  uint16_t padding[3];
};

struct FpuState {
  uint16_t cwd;
  uint16_t swd;
  uint16_t ftw;
  uint16_t fop;
  uint64_t rip;
  uint64_t rdp;
  uint32_t mxcsr;
  uint32_t mxcr_mask;
  struct FpuStackEntry st[8];
  struct XmmRegister xmm[16];
  uint32_t __padding[24];
};

typedef uint64_t greg_t;
typedef greg_t gregset_t[23];
typedef struct FpuState *fpregset_t;

struct MachineContext {
  union {
    struct {
      uint64_t r8;
      uint64_t r9;
      uint64_t r10;
      uint64_t r11;
      uint64_t r12;
      uint64_t r13;
      uint64_t r14;
      uint64_t r15;
      uint64_t rdi;
      uint64_t rsi;
      uint64_t rbp;
      uint64_t rbx;
      uint64_t rdx;
      uint64_t rax;
      uint64_t rcx;
      uint64_t rsp;
      uint64_t rip;
      uint64_t eflags;
      uint16_t cs;
      uint16_t gs;
      uint16_t fs;
      uint16_t __pad0;
      uint64_t err;
      uint64_t trapno;
      uint64_t oldmask;
      uint64_t cr2;
    };
    gregset_t gregs;
  };
  struct FpuState *fpregs;
  uint64_t __pad1[8];
};

typedef struct MachineContext mcontext_t;

struct ucontext {
  union {
    uint64_t uc_flags;
    struct {
      unsigned cf : 1;  /* bit  0: carry flag */
      unsigned vf : 1;  /* bit  1: V flag: was 8085 signed-number overflow */
      unsigned pf : 1;  /* bit  2: parity flag */
      unsigned rf : 1;  /* bit  3: always zero [undoc] */
      unsigned af : 1;  /* bit  4: auxiliary flag */
      unsigned kf : 1;  /* bit  5: K flag = V flag ⊕ sgn(result) [undoc] */
      unsigned zf : 1;  /* bit  6: zero flag */
      unsigned sf : 1;  /* bit  7: sign flag */
      unsigned tf : 1;  /* bit  8: trap flag */
      unsigned if_ : 1; /* bit  9: interrupt enable flag */
      unsigned df : 1;  /* bit 10: direction flag */
      unsigned of : 1;  /* bit 11: overflow flag */
      unsigned pl : 2;  /* b12-13: i/o privilege level (80286+) */
      unsigned nt : 1;  /* bit 14: nested task flag (80286+) */
      unsigned pc : 1;  /* bit 15: oldskool flag */
    };
  };
  struct ucontext *uc_link;
  stack_t uc_stack;
  mcontext_t uc_mcontext; /* use this */
  sigset_t uc_sigmask;
  struct FpuState __fpustate; /* for cosmo on non-linux */
};

typedef struct ucontext ucontext_t;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*sigaction_f)(int, struct siginfo *, struct ucontext *);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/typedef/sighandler_t.h */

#define COSMOPOLITAN_LIBC_CALLS_TYPEDEF_SIGHANDLER_T_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*sighandler_t)(int);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/dirent.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_DIRENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct dirent {      /* linux getdents64 abi */
  uint64_t d_ino;    /* inode number */
  int64_t d_off;     /* implementation-dependent location number */
  uint16_t d_reclen; /* byte length of this whole struct and string */
  uint8_t d_type;    /* DT_UNKNOWN, DT_BLK, DT_DIR, etc. */
  char d_name[256];  /* NUL-terminated basename */
};

struct dirstream;
typedef struct dirstream DIR;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/flock.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_FLOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct flock {
  short l_type;
  short l_whence;
  int64_t l_start;
  int64_t l_len;
  int l_pid;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/framebufferfixedscreeninfo.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_FRAMEBUFFERFIXEDSCREENINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct FrameBufferFixedScreenInfo {
  char id[16];
  uint64_t smem_start;
  uint32_t smem_len;
  uint32_t type;
  uint32_t type_aux;
  uint32_t visual;
  uint16_t xpanstep;
  uint16_t ypanstep;
  uint16_t ywrapstep;
  uint32_t line_length;
  uint64_t mmio_start;
  uint32_t mmio_len;
  uint32_t accel;
  uint16_t capabilities;
  uint16_t reserved[2];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/framebuffervirtualscreeninfo.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_FRAMEBUFFERVIRTUALSCREENINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct FrameBufferBitField {
  uint32_t offset;
  uint32_t length;
  uint32_t msb_right;
};

struct FrameBufferVirtualScreenInfo {
  uint32_t xres;
  uint32_t yres;
  uint32_t xres_virtual;
  uint32_t yres_virtual;
  uint32_t xoffset;
  uint32_t yoffset;
  uint32_t bits_per_pixel;
  uint32_t grayscale;
  struct FrameBufferBitField red;
  struct FrameBufferBitField green;
  struct FrameBufferBitField blue;
  struct FrameBufferBitField transp;
  uint32_t nonstd;
  uint32_t activate;
  uint32_t height;
  uint32_t width;
  uint32_t accel_flags;
  uint32_t pixclock;
  uint32_t left_margin;
  uint32_t right_margin;
  uint32_t upper_margin;
  uint32_t lower_margin;
  uint32_t hsync_len;
  uint32_t vsync_len;
  uint32_t sync;
  uint32_t vmode;
  uint32_t rotate;
  uint32_t colorspace;
  uint32_t reserved[4];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/iovec.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_IOVEC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct iovec {
  void *iov_base;
  size_t iov_len;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/itimerval.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_ITIMERVAL_H_


/*!BEGIN libc/calls/struct/timeval.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_TIMEVAL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct timeval {
  int64_t tv_sec;
  int64_t tv_usec; /* microseconds */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct itimerval {
  struct timeval it_interval; /* {0,0} means singleshot */
  struct timeval it_value;    /* {0,0} means disarm */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/rlimit.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_RLIMIT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct rlimit {
  int64_t rlim_cur;
  int64_t rlim_max;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/rusage.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_RUSAGE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct rusage {
  union {
    struct {
      struct timeval ru_utime; /* user CPU time used */
      struct timeval ru_stime; /* system CPU time used */
      int64_t ru_maxrss;       /* maximum resident set size */
      int64_t ru_ixrss;        /* integral shared memory size */
      int64_t ru_idrss;        /* integral unshared data size */
      int64_t ru_isrss;        /* integral unshared stack size */
      int64_t ru_minflt;       /* page reclaims (soft page faults) */
      int64_t ru_majflt;       /* page faults (hard page faults) */
      int64_t ru_nswap;        /* swaps */
      int64_t ru_inblock;      /* block input operations */
      int64_t ru_oublock;      /* block output operations */
      int64_t ru_msgsnd;       /* IPC messages sent */
      int64_t ru_msgrcv;       /* IPC messages received */
      int64_t ru_nsignals;     /* signals received */
      int64_t ru_nvcsw;        /* voluntary context switches */
      int64_t ru_nivcsw;       /* involuntary context switches */
    };
    uint8_t __conservatism[1024];
  };
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sched_param.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SCHED_PARAM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct sched_param {
  int32_t sched_priority;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sigaction.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGACTION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct sigaction { /* cosmo abi */
  union {
    sighandler_t sa_handler;
    sigaction_f sa_sigaction;
  };
  uint64_t sa_flags;
  void (*sa_restorer)(void);
  struct sigset sa_mask;
  int64_t __pad;
} forcealign(8);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sigaction-netbsd.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SIGACTION_NETBSD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct sigset_netbsd {
  uint32_t sig[4];
};

struct sigaction_netbsd {
  intptr_t sa_handler;
  struct sigset_netbsd sa_mask;
  uint32_t sa_flags;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/stat.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_STAT_H_


/*!BEGIN libc/calls/struct/timespec.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_TIMESPEC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct timespec {
  int64_t tv_sec;
  int64_t tv_nsec; /* nanoseconds */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct stat {               /* linux abi */
  int64_t st_dev;           /* 0: id of device with file */
  int64_t st_ino;           /* 8: inode number in disk b-tree */
  int64_t st_nlink;         /* 16: hard link count */
  int32_t st_mode;          /* 24: octal file mask thing */
  int32_t st_uid;           /* 28: user id of owner */
  int32_t st_gid;           /* group id of owning group */
  int32_t __pad;            /* ignore this */
  int64_t st_rdev;          /* id of device if a special file */
  int64_t st_size;          /* bytes in file */
  int64_t st_blksize;       /* preferred chunking for underlying filesystem */
  int64_t st_blocks;        /* number of 512-byte pages allocated to file */
  struct timespec st_atim;  /* access time (consider noatime) */
  struct timespec st_mtim;  /* modified time */
  struct timespec st_ctim;  /* complicated time */
  int64_t __future[3 + 10]; /* reserved for future use */
#define st_atime st_atim.tv_sec
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/sysinfo.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_SYSINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct sysinfo {
  int64_t uptime;     /* seconds since boot */
  uint64_t loads[3];  /* 1-5-15 min active process averages */
  uint64_t totalram;  /* system physical memory */
  uint64_t freeram;   /* amount of ram currently going to waste */
  uint64_t sharedram; /* bytes w/ pages mapped into multiple progs */
  uint64_t bufferram; /* lingering disk pages; see fadvise */
  uint64_t totalswap; /* size of emergency memory */
  uint64_t freeswap;  /* hopefully equal to totalswap */
  int16_t procs;      /* number of processes */
  int16_t __ignore;   /* padding */
  uint64_t totalhigh; /* wut */
  uint64_t freehigh;  /* wut */
  uint32_t mem_unit;  /* ram stuff above is multiples of this */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/termios.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_TERMIOS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct termios {     /* GNU/Systemd ABI */
  uint32_t c_iflag;  /* input modes */
  uint32_t c_oflag;  /* output modes */
  uint32_t c_cflag;  /* control modes */
  uint32_t c_lflag;  /* local modes */
  uint8_t c_cc[32];  /* code mappings */
  uint32_t c_ispeed; /* input speed */
  uint32_t c_ospeed; /* output speed */
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/tms.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_TMS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct tms {
  int64_t tms_utime;  /* userspace time */
  int64_t tms_stime;  /* kernelspace time */
  int64_t tms_cutime; /* children userspace time */
  int64_t tms_cstime; /* children kernelspace time */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/user_regs_struct.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_USER_REGS_STRUCT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * Linux Kernel user registers.
 *
 * @note superset of struct pt_regs
 * @see ptrace() w/ PTRACE_SYSCALL
 */
struct user_regs_struct {
  uint64_t r15;
  uint64_t r14;
  uint64_t r13;
  uint64_t r12;
  uint64_t rbp;
  uint64_t rbx;
  uint64_t r11;
  uint64_t r10;
  uint64_t r9;
  uint64_t r8;
  uint64_t rax;
  uint64_t rcx;
  uint64_t rdx;
  uint64_t rsi;
  uint64_t rdi;
  uint64_t orig_rax;
  uint64_t rip;
  uint64_t cs;
  uint64_t eflags;
  uint64_t rsp;
  uint64_t ss;
  uint64_t fs_base;
  uint64_t gs_base;
  uint64_t ds;
  uint64_t es;
  uint64_t fs;
  uint64_t gs;
};

struct useregs_struct_freebsd {
  int64_t r15;
  int64_t r14;
  int64_t r13;
  int64_t r12;
  int64_t r11;
  int64_t r10;
  int64_t r9;
  int64_t r8;
  int64_t rdi;
  int64_t rsi;
  int64_t rbp;
  int64_t rbx;
  int64_t rdx;
  int64_t rcx;
  int64_t rax;
  uint32_t trapno;
  uint16_t fs;
  uint16_t gs;
  uint32_t err;
  uint16_t es;
  uint16_t ds;
  int64_t rip;
  int64_t cs;
  int64_t rflags;
  int64_t rsp;
  int64_t ss;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/utsname.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_UTSNAME_H_

#define SYS_NMLN 321

#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct utsname {
  char sysname[SYS_NMLN];
  char nodename[SYS_NMLN];
  char release[SYS_NMLN];
  char version[SYS_NMLN];
  char machine[SYS_NMLN];
  char domainname[SYS_NMLN];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/struct/winsize.h */

#define COSMOPOLITAN_LIBC_CALLS_STRUCT_WINSIZE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct winsize {
  uint16_t ws_row;
  uint16_t ws_col;
  uint16_t ws_xpixel;
  uint16_t ws_ypixel;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/calls.h */

#define COSMOPOLITAN_LIBC_CALLS_SYSCALLS_H_


/*!BEGIN libc/fmt/pflink.h */

#define COSMOPOLITAN_LIBC_FMT_PFLINK_H_


/*!BEGIN libc/mem/mem.h */

#define COSMOPOLITAN_LIBC_MEM_MEM_H_

#define M_TRIM_THRESHOLD (-1)
#define M_GRANULARITY    (-2)
#define M_MMAP_THRESHOLD (-3)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § dynamic memory                                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void free(void *) libcesque;
void *malloc(size_t) attributeallocsize((1)) mallocesque;
void *calloc(size_t, size_t) attributeallocsize((1, 2)) mallocesque;
void *memalign(size_t, size_t) attributeallocalign((1))
    attributeallocsize((2)) mallocesque;
void *realloc(void *, size_t) reallocesque;
void *realloc_in_place(void *, size_t);
void *reallocarray(void *, size_t, size_t) nodiscard;
void *valloc(size_t) attributeallocsize((1)) vallocesque;
void *pvalloc(size_t) attributeallocsize((1)) mallocesque;
char *strdup(const char *) paramsnonnull() mallocesque;
char *strndup(const char *, size_t) paramsnonnull()
    attributeallocsize((2)) mallocesque;
int posix_memalign(void **, size_t, size_t); /* wut */
bool __grow(void *, size_t *, size_t, size_t) paramsnonnull((1, 2)) libcesque;

int malloc_trim(size_t);
size_t bulk_free(void **, size_t);
size_t malloc_usable_size(const void *);
void **independent_calloc(size_t, size_t, void **);
void **independent_comalloc(size_t, size_t *, void **);

wchar_t *wcsdup(const wchar_t *) strlenesque nodiscard;

struct mallinfo {
  size_t arena;    /* non-mmapped space allocated from system */
  size_t ordblks;  /* number of free chunks */
  size_t smblks;   /* always 0 */
  size_t hblks;    /* always 0 */
  size_t hblkhd;   /* space in mmapped regions */
  size_t usmblks;  /* maximum total allocated space */
  size_t fsmblks;  /* always 0 */
  size_t uordblks; /* total allocated space */
  size_t fordblks; /* total free space */
  size_t keepcost; /* releasable (via malloc_trim) space */
};
struct mallinfo mallinfo(void);

void malloc_stats(void);
bool32 mallopt(int, int);
size_t malloc_footprint(void);
size_t malloc_max_footprint(void);
size_t malloc_footprint_limit(void);
size_t malloc_set_footprint_limit(size_t);
void malloc_inspect_all(void (*handler)(void *, void *, size_t, void *),
                        void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/unicode/unicode.h */

#define COSMOPOLITAN_LIBC_UNICODE_UNICODE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int wcwidth(wchar_t) pureconst;
int wcswidth(const wchar_t *, size_t) strlenesque;
int wcsnwidth(const wchar_t *, size_t, size_t) strlenesque;
int strwidth(const char *, size_t) strlenesque;
int strnwidth(const char *, size_t, size_t) strlenesque;
int strwidth16(const char16_t *, size_t) strlenesque;
int strnwidth16(const char16_t *, size_t, size_t) strlenesque;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
#ifndef __STRICT_ANSI__

/**
 * @fileoverview builtin+preprocessor+linker tricks for printf/scanf.
 *
 * Your printf() function only requires that you pay for what you use.
 * These macros ensure that its code size starts at under 4kb, growing
 * to about 40kb for a fully-loaded implementation. This works best when
 * format strings are constexprs that only contain directives.
 */

#define PFLINK(FMT)                                               \
  ({                                                              \
    if (___PFLINK(FMT, strpbrk, "cmrqs")) {                       \
      if (___PFLINK(FMT, strchr, '#')) STATIC_YOINK("kCp437");    \
      if (___PFLINK(FMT, strstr, "%m")) STATIC_YOINK("strerror"); \
      if (!IsTiny() && (___PFLINK(FMT, strstr, "%*") ||           \
                        ___PFLINK(FMT, strpbrk, "0123456789"))) { \
        STATIC_YOINK("strnwidth");                                \
        STATIC_YOINK("strnwidth16");                              \
        STATIC_YOINK("wcsnwidth");                                \
      }                                                           \
    }                                                             \
    FMT;                                                          \
  })

#define SFLINK(FMT)                    \
  ({                                   \
    if (___PFLINK(FMT, strchr, 'm')) { \
      STATIC_YOINK("malloc");          \
      STATIC_YOINK("calloc");          \
      STATIC_YOINK("free");            \
      STATIC_YOINK("__grow");          \
    }                                  \
    FMT;                               \
  })

#if __GNUC__ + 0 < 4 || defined(__llvm__)
#define ___PFLINK(FMT, FN, C) 1
#else
#define ___PFLINK(FMT, FN, C) \
  !__builtin_constant_p(FMT) || ((FMT) && __builtin_##FN(FMT, C) != NULL)
#endif

#if defined(__GNUC__) && __GNUC__ < 6
/*
 * Compilers don't understand the features we've added to the format
 * string DSL, such as c string escaping, therefore we can't use it.
 * Ideally compilers should grant us more flexibility to define DSLs
 *
 * The recommended approach to turning this back on is `CFLAGS=-std=c11`
 * which puts the compiler in __STRICT_ANSI__ mode, which Cosmopolitan
 * respects by disabling all the esoteric tuning in headers like this.
 */
#pragma GCC diagnostic ignored "-Wformat-security"
#endif /* __GNUC__ + 0 < 6 */
#else
#define PFLINK(FMT) FMT
#define SFLINK(FMT) FMT
#ifdef __GNUC__
__asm__(".section .yoink\n\t"
        "nopl\tkCp437(%rip)\n\t"
        "nopl\tstrerror(%rip)\n\t"
        "nopl\tstrnwidth(%rip)\n\t"
        "nopl\tstrnwidth16(%rip)\n\t"
        "nopl\twcsnwidth(%rip)\n\t"
        "nopl\tmalloc(%rip)\n\t"
        "nopl\tcalloc(%rip)\n\t"
        "nopl\t__grow(%rip)\n\t"
        ".previous");
#else
static long __pflink(long x) {
  x |= kCp437[0];
  x |= strnwidth(0, 0, 0);
  x |= strnwidth16(0, 0, 0);
  x |= wcsnwidth(0, 0, 0);
  x |= malloc(0);
  x |= __grow(0, 0, 0, 0);
  x |= (intptr_t)strerror(0);
  x |= (intptr_t)calloc(0, 0);
  return x;
}
#endif
#endif /* __STRICT_ANSI__ */
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/s.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_S_H_


/*!BEGIN libc/runtime/symbolic.h */

#define COSMOPOLITAN_LIBC_RUNTIME_SYMBOLIC_H_

#ifdef __ASSEMBLER__
/* clang-format off */
#define SYMBOLIC(NAME) NAME(%rip)
#define LITERALLY(NAME) $NAME
/* clang-format on */
#else
#define SYMBOLIC(NAME) NAME
#define LITERALLY(NAME) NAME
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long S_IEXEC;
extern const long S_IFBLK;
extern const long S_IFCHR;
extern const long S_IFDIR;
extern const long S_IFIFO;
extern const long S_IFLNK;
extern const long S_IFMT;
extern const long S_IFREG;
extern const long S_IFSOCK;
extern const long S_IREAD;
extern const long S_IRGRP;
extern const long S_IROTH;
extern const long S_IRUSR;
extern const long S_IRWXG;
extern const long S_IRWXO;
extern const long S_IRWXU;
extern const long S_ISGID;
extern const long S_ISUID;
extern const long S_ISVTX;
extern const long S_IWGRP;
extern const long S_IWOTH;
extern const long S_IWRITE;
extern const long S_IWUSR;
extern const long S_IXGRP;
extern const long S_IXOTH;
extern const long S_IXUSR;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define S_IFREG LITERALLY(0100000)
#define S_IFBLK LITERALLY(0060000)
#define S_IFCHR LITERALLY(0020000)
#define S_IFDIR LITERALLY(0040000)
#define S_IFIFO LITERALLY(0010000)
#define S_IFMT LITERALLY(0170000)
#define S_IFLNK LITERALLY(0120000)
#define S_IFSOCK LITERALLY(0140000)
#define S_ISVTX LITERALLY(01000)
#define S_ISGID LITERALLY(02000)
#define S_ISUID LITERALLY(04000)
#define S_IEXEC LITERALLY(00100)
#define S_IWRITE LITERALLY(00200)
#define S_IREAD LITERALLY(00400)
#define S_IXUSR LITERALLY(00100)
#define S_IWUSR LITERALLY(00200)
#define S_IRUSR LITERALLY(00400)
#define S_IRWXU LITERALLY(00700)
#define S_IXGRP LITERALLY(00010)
#define S_IWGRP LITERALLY(00020)
#define S_IRGRP LITERALLY(00040)
#define S_IRWXG LITERALLY(00070)
#define S_IXOTH LITERALLY(00001)
#define S_IWOTH LITERALLY(00002)
#define S_IROTH LITERALLY(00004)
#define S_IRWXO LITERALLY(00007)



/*!BEGIN libc/sysv/consts/sig.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SIG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SIGABRT;
extern const long SIGALRM;
extern const long SIGBUS;
extern const long SIGCHLD;
extern const long SIGCONT;
extern const long SIGFPE;
extern const long SIGHUP;
extern const long SIGILL;
extern const long SIGINT;
extern const long SIGIO;
extern const long SIGIOT;
extern const long SIGKILL;
extern const long SIGPIPE;
extern const long SIGPOLL;
extern const long SIGPROF;
extern const long SIGPWR;
extern const long SIGQUIT;
extern const long SIGRTMAX;
extern const long SIGRTMIN;
extern const long SIGSEGV;
extern const long SIGSTKFLT;
extern const long SIGSTKSZ;
extern const long SIGSTOP;
extern const long SIGSYS;
extern const long SIGTERM;
extern const long SIGTRAP;
extern const long SIGTSTP;
extern const long SIGTTIN;
extern const long SIGTTOU;
extern const long SIGUNUSED;
extern const long SIGURG;
extern const long SIGUSR1;
extern const long SIGUSR2;
extern const long SIGVTALRM;
extern const long SIGWINCH;
extern const long SIGXCPU;
extern const long SIGXFSZ;

extern const long SIG_ATOMIC_MIN;
extern const long SIG_BLOCK;
extern const long SIG_SETMASK;
extern const long SIG_UNBLOCK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SIGABRT LITERALLY(6)
#define SIGALRM LITERALLY(14)
#define SIGBUS SYMBOLIC(SIGBUS)
#define SIGCHLD SYMBOLIC(SIGCHLD)
#define SIGCONT SYMBOLIC(SIGCONT)
#define SIGFPE LITERALLY(8)
#define SIGHUP LITERALLY(1)
#define SIGILL LITERALLY(4)
#define SIGINT LITERALLY(2)
#define SIGIO SYMBOLIC(SIGIO)
#define SIGIOT LITERALLY(6)
#define SIGKILL LITERALLY(9)
#define SIGPIPE LITERALLY(13)
#define SIGPOLL SYMBOLIC(SIGPOLL)
#define SIGPROF LITERALLY(27)
#define SIGPWR SYMBOLIC(SIGPWR)
#define SIGQUIT LITERALLY(3)
#define SIGRTMAX SYMBOLIC(SIGRTMAX)
#define SIGRTMIN SYMBOLIC(SIGRTMIN)
#define SIGSEGV LITERALLY(11)
#define SIGSTKFLT SYMBOLIC(SIGSTKFLT)
#define SIGSTKSZ SYMBOLIC(SIGSTKSZ)
#define SIGSTOP SYMBOLIC(SIGSTOP)
#define SIGSYS SYMBOLIC(SIGSYS)
#define SIGTERM LITERALLY(15)
#define SIGTRAP LITERALLY(5)
#define SIGTSTP SYMBOLIC(SIGTSTP)
#define SIGTTIN LITERALLY(21)
#define SIGTTOU LITERALLY(22)
#define SIGUNUSED SYMBOLIC(SIGUNUSED)
#define SIGURG SYMBOLIC(SIGURG)
#define SIGUSR1 SYMBOLIC(SIGUSR1)
#define SIGUSR2 SYMBOLIC(SIGUSR2)
#define SIGVTALRM LITERALLY(26)
#define SIGWINCH LITERALLY(28)
#define SIGXCPU LITERALLY(24)
#define SIGXFSZ LITERALLY(25)

#define SIG_ATOMIC_MIN SYMBOLIC(SIG_ATOMIC_MIN)
#define SIG_BLOCK SYMBOLIC(SIG_BLOCK)
#define SIG_SETMASK SYMBOLIC(SIG_SETMASK)
#define SIG_UNBLOCK SYMBOLIC(SIG_UNBLOCK)


#define EOF      -1  /* end of file */
#define WEOF     -1u /* end of file (multibyte) */
#define _IOFBF   0   /* fully buffered */
#define _IOLBF   1   /* line buffered */
#define _IONBF   2   /* no buffering */
#define SEEK_SET 0   /* relative to beginning */
#define SEEK_CUR 1   /* relative to current position */
#define SEEK_END 2   /* relative to end */

#define SIG_ERR ((void (*)(int))(-1))
#define SIG_DFL ((void *)0)
#define SIG_IGN ((void *)1)

#define MAP_FAILED ((void *)__SIZE_MAX__)

#define ARCH_SET_GS 0x1001
#define ARCH_SET_FS 0x1002
#define ARCH_GET_FS 0x1003
#define ARCH_GET_GS 0x1004

#define MAP_HUGE_2MB (21 << MAP_HUGE_SHIFT)
#define MAP_HUGE_1GB (30 << MAP_HUGE_SHIFT)

#define S_ISDIR(mode)  (((mode)&S_IFMT) == S_IFDIR)
#define S_ISCHR(mode)  (((mode)&S_IFMT) == S_IFCHR)
#define S_ISBLK(mode)  (((mode)&S_IFMT) == S_IFBLK)
#define S_ISREG(mode)  (((mode)&S_IFMT) == S_IFREG)
#define S_ISFIFO(mode) (((mode)&S_IFMT) == S_IFIFO)
#define S_ISLNK(mode)  (((mode)&S_IFMT) == S_IFLNK)
#define S_ISSOCK(mode) (((mode)&S_IFMT) == S_IFSOCK)

#define WCOREDUMP(s)    ((s)&0x80)
#define WEXITSTATUS(s)  (((s)&0xff00) >> 8)
#define WIFCONTINUED(s) ((s) == 0xffff)
#define WIFEXITED(s)    (!WTERMSIG(s))
#define WIFSIGNALED(s)  (((s)&0xffff) - 1u < 0xffu)
#define WIFSTOPPED(s)   ((short)((((s)&0xffff) * 0x10001) >> 8) > 0x7f00)
#define WSTOPSIG(s)     WEXITSTATUS(s)
#define WTERMSIG(s)     ((s)&0x7f)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system calls                                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef int sig_atomic_t;

extern const struct sigset kSigsetFull;
extern const struct sigset kSigsetEmpty;

DIR *fdopendir(int) nodiscard;
DIR *opendir(const char *) nodiscard;
bool fileexists(const char *);
bool isdirectory(const char *);
bool isexecutable(const char *);
bool isregularfile(const char *);
bool32 isatty(int) nosideeffect;
bool32 ischardev(int) nosideeffect;
char *commandv(const char *, char[hasatleast PATH_MAX]);
char *get_current_dir_name(void) nodiscard;
char *getcwd(char *, size_t);
char *realpath(const char *, char *);
char *replaceuser(const char *) nodiscard;
char *ttyname(int);
int access(const char *, int) nothrow;
int arch_prctl();
int chdir(const char *);
int chmod(const char *, uint32_t);
int chown(const char *, uint32_t, uint32_t);
int close(int);
int closedir(DIR *);
int creat(const char *, uint32_t) nodiscard;
int dirfd(DIR *);
int dup(int) nodiscard;
int dup2(int, int);
int dup3(int, int, int);
int execl(const char *, const char *, ...) nullterminated();
int execle(const char *, const char *, ...) nullterminated((1));
int execlp(const char *, const char *, ...) nullterminated();
int execv(const char *, char *const[]) paramsnonnull();
int execve(const char *, char *const[], char *const[]) paramsnonnull();
int execvp(const char *, char *const[]) paramsnonnull();
int execvpe(const char *, char *const[], char *const[]) paramsnonnull();
int faccessat(int, const char *, int, uint32_t);
int fadvise(int, uint64_t, uint64_t, int);
int fchmod(int, uint32_t) nothrow;
int fchmodat(int, const char *, uint32_t, uint32_t);
int fchown(int, uint32_t, uint32_t);
int fchownat(int, const char *, uint32_t, uint32_t, uint32_t);
int fcntl(int, int, ...);
int fdatasync(int);
int filecmp(const char *, const char *);
int flock(int, int);
int fork(void);
int fstat(int, struct stat *);
int fstatat(int, const char *, struct stat *, uint32_t);
int fsync(int);
int ftruncate(int, int64_t);
int getdomainname(char *, size_t);
int gethostname(char *, size_t);
int getppid(void);
int getpriority(int, unsigned);
int getrlimit(int, struct rlimit *);
int getrusage(int, struct rusage *);
int kill(int, int);
int killpg(int, int);
int link(const char *, const char *) nothrow;
int linkat(int, const char *, int, const char *, uint32_t);
int lstat(const char *, struct stat *);
int madvise(void *, uint64_t, int);
int mkdir(const char *, uint32_t);
int mkdirat(int, const char *, uint32_t);
int mkfifo(const char *, uint32_t);
int mknod(const char *, uint32_t, uint64_t);
int mknodat(int, const char *, int32_t, uint64_t);
int mlock(const void *, size_t);
int mlock2(const void *, size_t, int);
int mlockall(int);
int munlock(const void *, size_t);
int munlockall(void);
int nice(int);
int open(const char *, int, ...) nodiscard;
int openanon(char *, unsigned) nodiscard;
int openat(int, const char *, int, ...);
int pause(void);
int personality(uint64_t);
int pipe(int[hasatleast 2]);
int pipe2(int[hasatleast 2], int);
int posix_fadvise(int, uint64_t, uint64_t, int);
int posix_madvise(void *, uint64_t, int);
int raise(int);
int readlink(const char *, char *, size_t);
int remove(const char *);
int rename(const char *, const char *);
int renameat(int, const char *, int, const char *);
int renameat2(long, const char *, long, const char *, int);
int rmdir(const char *);
int sched_getaffinity(int, uint64_t, void *);
int sched_setaffinity(int, uint64_t, const void *);
int sched_yield(void);
int setegid(uint32_t);
int seteuid(uint32_t);
int setgid(uint32_t);
int setpgid(int, int);
int setpriority(int, unsigned, int);
int setregid(uint32_t, uint32_t);
int setresgid(uint32_t, uint32_t, uint32_t);
int setresuid(uint32_t, uint32_t, uint32_t);
int setreuid(uint32_t, uint32_t);
int setrlimit(int, const struct rlimit *);
int setsid(void);
int setuid(uint32_t);
int sigaction(int, const struct sigaction *, struct sigaction *);
int sigignore(int);
int sigprocmask(int, const struct sigset *, struct sigset *);
int sigsuspend(const struct sigset *);
int stat(const char *, struct stat *);
int symlink(const char *, const char *);
int symlinkat(const char *, int, const char *);
int sync_file_range(int, int64_t, int64_t, unsigned);
int sysinfo(struct sysinfo *) paramsnonnull();
int touch(const char *, uint32_t);
int truncate(const char *, uint64_t);
int ttyname_r(int, char *, size_t);
int uname(struct utsname *);
int unlink(const char *);
int unlink_s(const char **);
int unlinkat(int, const char *, int);
int vfork(void) returnstwice;
int wait(int *);
int wait3(int *, int, struct rusage *);
int wait4(int, int *, int, struct rusage *);
int waitpid(int, int *, int);
ssize_t lseek(int, int64_t, unsigned);
ssize_t pread(int, void *, size_t, int64_t);
ssize_t preadv(int, struct iovec *, int, int64_t);
ssize_t pwrite(int, const void *, size_t, int64_t);
ssize_t pwritev(int, const struct iovec *, int, int64_t);
intptr_t syscall(int, ...);
void sync(void);
long telldir(DIR *);
int getpid(void);
long times(struct tms *);
sighandler_t signal(int, sighandler_t);
size_t GetFileSize(const char *);
size_t getfiledescriptorsize(int);
ssize_t copy_file_range(int, long *, int, long *, size_t, uint32_t);
ssize_t copyfd(int, int64_t *, int, int64_t *, size_t, uint32_t);
ssize_t read(int, void *, size_t);
ssize_t readansi(int, char *, size_t);
ssize_t readlinkat(int, const char *, char *, size_t);
ssize_t splice(int, int64_t *, int, int64_t *, size_t, uint32_t);
ssize_t vmsplice(int, const struct iovec *, int64_t, uint32_t);
ssize_t write(int, const void *, size_t);
struct dirent *readdir(DIR *);
uint32_t getegid(void) nosideeffect;
uint32_t geteuid(void) nosideeffect;
uint32_t getgid(void) nosideeffect;
uint32_t getpgrp(void) nosideeffect;
uint32_t getsid(int) nosideeffect;
uint32_t gettid(void) nosideeffect;
uint32_t getuid(void) nosideeffect;
uint32_t umask(int32_t);
long ptrace(int, int, void *, void *);
int chroot(const char *);
int prctl();
int sysctl(const int *, unsigned, void *, size_t *, void *, size_t);
int fchdir(int);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system calls » formatting                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int dprintf(int, const char *, ...) printfesque(2) paramsnonnull((2));
int vdprintf(int, const char *, va_list) paramsnonnull();

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system calls » link-time optimizations                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

#define getcwd(BUF, SIZE)                                       \
  (__builtin_constant_p(BUF) && !(BUF) ? get_current_dir_name() \
                                       : getcwd(BUF, SIZE))

void _init_onntconsoleevent(void);
void _init_wincrash(void);

#ifndef __SIGACTION
#define __SIGACTION(FN, SIG, ...)          \
  ({                                       \
    if (SupportsWindows()) {               \
      if (__builtin_constant_p(SIG)) {     \
        switch (SIG) {                     \
          case SIGINT:                     \
          case SIGQUIT:                    \
          case SIGHUP:                     \
          case SIGTERM:                    \
            YOINK(_init_onntconsoleevent); \
            break;                         \
          case SIGTRAP:                    \
          case SIGILL:                     \
          case SIGSEGV:                    \
          case SIGABRT:                    \
          case SIGFPE:                     \
            YOINK(_init_wincrash);         \
            break;                         \
          default:                         \
            break;                         \
        }                                  \
      } else {                             \
        YOINK(_init_onntconsoleevent);     \
        YOINK(_init_wincrash);             \
      }                                    \
    }                                      \
    (FN)(SIG, __VA_ARGS__);                \
  })
#endif

#define dprintf(FD, FMT, ...)    (dprintf)(FD, PFLINK(FMT), ##__VA_ARGS__)
#define sigaction(SIG, ACT, OLD) __SIGACTION(sigaction, SIG, ACT, OLD)
#define signal(SIG, HAND)        __SIGACTION(signal, SIG, HAND)
#define vdprintf(FD, FMT, VA)    (vdprintf)(FD, PFLINK(FMT), VA)

#endif /* GNU && !ANSI */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/copyfile.h */

#define COSMOPOLITAN_LIBC_CALLS_COPYFILE_H_

#define COPYFILE_NOCLOBBER           1
#define COPYFILE_PRESERVE_OWNER      2
#define COPYFILE_PRESERVE_TIMESTAMPS 4

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int copyfile(const char *, const char *, int) paramsnonnull();

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/ioctl.h */

#define COSMOPOLITAN_LIBC_CALLS_IOCTL_H_


/*!BEGIN libc/sysv/consts/termios.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TERMIOS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long BRKINT;
extern const long BSDLY;
extern const long BUSY;
extern const long CANBSIZ;
extern const long CBAUD;
extern const long CBAUDEX;
extern const long CBRK;
extern const long CEOL;
extern const long CIBAUD;
extern const long CLOCAL;
extern const long CMSPAR;
extern const long CRDLY;
extern const long CS6;
extern const long CS7;
extern const long CS8;
extern const long CSIZE;
extern const long ECHO;
extern const long ECHOCTL;
extern const long ECHOE;
extern const long ECHOK;
extern const long ECHOKE;
extern const long ECHONL;
extern const long ECHOPRT;
extern const long ENDRUNDISC;
extern const long EXTPROC;
extern const long FFDLY;
extern const long FLUSHO;
extern const long H4DISC;
extern const long ICANON;
extern const long ICRNL;
extern const long IEXTEN;
extern const long IGNBRK;
extern const long IGNCR;
extern const long IGNPAR;
extern const long IMAXBEL;
extern const long INLCR;
extern const long INPCK;
extern const long ISIG;
extern const long ISTRIP;
extern const long IUCLC;
extern const long IUTF8;
extern const long IXANY;
extern const long IXOFF;
extern const long IXON;
extern const long NCCS;
extern const long NETGRAPHDISC;
extern const long NLDLY;
extern const long NMEADISC;
extern const long NOFLSH;
extern const long OCRNL;
extern const long OFDEL;
extern const long OFILL;
extern const long OLCUC;
extern const long ONLCR;
extern const long ONLRET;
extern const long ONOCR;
extern const long OPOST;
extern const long PARENB;
extern const long PARMRK;
extern const long PARODD;
extern const long PENDIN;
extern const long PPPDISC;
extern const long SLIPDISC;
extern const long STRIPDISC;
extern const long TABDLY;
extern const long TABLDISC;
extern const long TCGETS;
extern const long TCSADRAIN;
extern const long TCSAFLUSH;
extern const long TCSANOW;
extern const long TCSETS;
extern const long TCSETSF;
extern const long TCSETSW;
extern const long TIOCCBRK;
extern const long TIOCCDTR;
extern const long TIOCCHKVERAUTH;
extern const long TIOCCONS;
extern const long TIOCDRAIN;
extern const long TIOCEXT;
extern const long TIOCFLAG_CLOCAL;
extern const long TIOCFLAG_MDMBUF;
extern const long TIOCFLAG_PPS;
extern const long TIOCFLAG_SOFTCAR;
extern const long TIOCFLUSH;
extern const long TIOCGDRAINWAIT;
extern const long TIOCGETD;
extern const long TIOCGFLAGS;
extern const long TIOCGPGRP;
extern const long TIOCGPTN;
extern const long TIOCGSID;
extern const long TIOCGTSTAMP;
extern const long TIOCGWINSZ;
extern const long TIOCNOTTY;
extern const long TIOCNXCL;
extern const long TIOCOUTQ;
extern const long TIOCPTMASTER;
extern const long TIOCREMOTE;
extern const long TIOCSBRK;
extern const long TIOCSCTTY;
extern const long TIOCSDRAINWAIT;
extern const long TIOCSDTR;
extern const long TIOCSERGETLSR;
extern const long TIOCSERGETMULTI;
extern const long TIOCSERSETMULTI;
extern const long TIOCSER_TEMT;
extern const long TIOCSETD;
extern const long TIOCSETVERAUTH;
extern const long TIOCSFLAGS;
extern const long TIOCSIG;
extern const long TIOCSPGRP;
extern const long TIOCSTART;
extern const long TIOCSTAT;
extern const long TIOCSTI;
extern const long TIOCSTSTAMP;
extern const long TIOCSWINSZ;
extern const long TIOCTIMESTAMP;
extern const long TIOCUCNTL_CBRK;
extern const long TOSTOP;
extern const long TTYDISC;
extern const long VDISCARD;
extern const long VEOF;
extern const long VEOL;
extern const long VEOL2;
extern const long VERASE;
extern const long VERIFY;
extern const long VINTR;
extern const long VKILL;
extern const long VLNEXT;
extern const long VMIN;
extern const long VQUIT;
extern const long VREPRINT;
extern const long VSTART;
extern const long VSTOP;
extern const long VSUSP;
extern const long VSWTC;
extern const long VTDLY;
extern const long VTIME;
extern const long VWERASE;
extern const long XCASE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define IGNBRK  LITERALLY(0x01)
#define BRKINT  LITERALLY(0x02)
#define IGNPAR  LITERALLY(0x04)
#define PARMRK  LITERALLY(0x08)
#define INPCK   LITERALLY(0x10)
#define ISTRIP  LITERALLY(0x20)
#define INLCR   LITERALLY(0x40)
#define IGNCR   LITERALLY(0x80)
#define ICRNL   LITERALLY(0x0100)
#define IXANY   LITERALLY(0x0800)
#define IMAXBEL LITERALLY(0x2000)
#define OPOST   LITERALLY(0x01)

#define NLDLY  SYMBOLIC(NLDLY)
#define NL0    LITERALLY(0)
#define NL1    SYMBOLIC(NL1)
#define NL2    SYMBOLIC(NL2)
#define NL3    SYMBOLIC(NL3)
#define CRDLY  SYMBOLIC(CRDLY)
#define CR0    LITERALLY(0)
#define CR1    SYMBOLIC(CR1)
#define CR2    SYMBOLIC(CR2)
#define CR3    SYMBOLIC(CR3)
#define TABDLY SYMBOLIC(TABDLY)
#define TAB0   LITERALLY(0)
#define TAB1   SYMBOLIC(TAB1)
#define TAB2   SYMBOLIC(TAB2)
#define TAB3   SYMBOLIC(TAB3)
#define XTABS  SYMBOLIC(XTABS)
#define BSDLY  SYMBOLIC(BSDLY)
#define BS0    LITERALLY(0)
#define BS1    SYMBOLIC(BS1)
#define BS2    SYMBOLIC(BS2)
#define VTDLY  SYMBOLIC(VTDLY)
#define VT0    LITERALLY(0)
#define VT1    SYMBOLIC(VT1)
#define VT2    SYMBOLIC(VT2)
#define FFDLY  SYMBOLIC(FFDLY)
#define FF0    LITERALLY(0)
#define FF1    SYMBOLIC(FF1)
#define FF2    SYMBOLIC(FF2)

#define BUSY             SYMBOLIC(BUSY)
#define CANBSIZ          SYMBOLIC(CANBSIZ)
#define CBAUD            SYMBOLIC(CBAUD)
#define CBAUDEX          SYMBOLIC(CBAUDEX)
#define CBRK             SYMBOLIC(CBRK)
#define CEOL             SYMBOLIC(CEOL)
#define CIBAUD           SYMBOLIC(CIBAUD)
#define CLOCAL           SYMBOLIC(CLOCAL)
#define CMSPAR           SYMBOLIC(CMSPAR)
#define CS6              SYMBOLIC(CS6)
#define CS7              SYMBOLIC(CS7)
#define CS8              SYMBOLIC(CS8)
#define CSIZE            SYMBOLIC(CSIZE)
#define ECHO             LITERALLY(8)
#define ECHOCTL          SYMBOLIC(ECHOCTL)
#define ECHOE            SYMBOLIC(ECHOE)
#define ECHOK            SYMBOLIC(ECHOK)
#define ECHOKE           SYMBOLIC(ECHOKE)
#define ECHONL           SYMBOLIC(ECHONL)
#define ECHOPRT          SYMBOLIC(ECHOPRT)
#define ENDRUNDISC       SYMBOLIC(ENDRUNDISC)
#define EXTPROC          SYMBOLIC(EXTPROC)
#define FLUSHO           SYMBOLIC(FLUSHO)
#define H4DISC           SYMBOLIC(H4DISC)
#define ICANON           SYMBOLIC(ICANON)
#define IEXTEN           SYMBOLIC(IEXTEN)
#define ISIG             SYMBOLIC(ISIG)
#define IUCLC            SYMBOLIC(IUCLC)
#define IUTF8            SYMBOLIC(IUTF8)
#define IXOFF            SYMBOLIC(IXOFF)
#define IXON             SYMBOLIC(IXON)
#define NCCS             LITERALLY(32)
#define NETGRAPHDISC     SYMBOLIC(NETGRAPHDISC)
#define NMEADISC         SYMBOLIC(NMEADISC)
#define NOFLSH           SYMBOLIC(NOFLSH)
#define OCRNL            SYMBOLIC(OCRNL)
#define OFDEL            SYMBOLIC(OFDEL)
#define OFILL            SYMBOLIC(OFILL)
#define OLCUC            SYMBOLIC(OLCUC)
#define ONLCR            SYMBOLIC(ONLCR)
#define ONLRET           SYMBOLIC(ONLRET)
#define ONOCR            SYMBOLIC(ONOCR)
#define PARENB           SYMBOLIC(PARENB)
#define PARODD           SYMBOLIC(PARODD)
#define PENDIN           SYMBOLIC(PENDIN)
#define PPPDISC          SYMBOLIC(PPPDISC)
#define SLIPDISC         SYMBOLIC(SLIPDISC)
#define STRIPDISC        SYMBOLIC(STRIPDISC)
#define TABLDISC         SYMBOLIC(TABLDISC)
#define TCGETS           SYMBOLIC(TCGETS)
#define TCSANOW          LITERALLY(0)
#define TCSADRAIN        LITERALLY(1)
#define TCSAFLUSH        LITERALLY(2)
#define TCSETS           SYMBOLIC(TCSETS)
#define TCSETSF          SYMBOLIC(TCSETSF)
#define TCSETSW          SYMBOLIC(TCSETSW)
#define TIOCCBRK         SYMBOLIC(TIOCCBRK)
#define TIOCCDTR         SYMBOLIC(TIOCCDTR)
#define TIOCCHKVERAUTH   SYMBOLIC(TIOCCHKVERAUTH)
#define TIOCCONS         SYMBOLIC(TIOCCONS)
#define TIOCDRAIN        SYMBOLIC(TIOCDRAIN)
#define TIOCEXT          SYMBOLIC(TIOCEXT)
#define TIOCFLAG_CLOCAL  SYMBOLIC(TIOCFLAG_CLOCAL)
#define TIOCFLAG_MDMBUF  SYMBOLIC(TIOCFLAG_MDMBUF)
#define TIOCFLAG_PPS     SYMBOLIC(TIOCFLAG_PPS)
#define TIOCFLAG_SOFTCAR SYMBOLIC(TIOCFLAG_SOFTCAR)
#define TIOCFLUSH        SYMBOLIC(TIOCFLUSH)
#define TIOCGDRAINWAIT   SYMBOLIC(TIOCGDRAINWAIT)
#define TIOCGETD         SYMBOLIC(TIOCGETD)
#define TIOCGFLAGS       SYMBOLIC(TIOCGFLAGS)
#define TIOCGPGRP        SYMBOLIC(TIOCGPGRP)
#define TIOCGPTN         SYMBOLIC(TIOCGPTN)
#define TIOCGSID         SYMBOLIC(TIOCGSID)
#define TIOCGTSTAMP      SYMBOLIC(TIOCGTSTAMP)
#define TIOCGWINSZ       SYMBOLIC(TIOCGWINSZ)
#define TIOCNOTTY        SYMBOLIC(TIOCNOTTY)
#define TIOCNXCL         SYMBOLIC(TIOCNXCL)
#define TIOCOUTQ         SYMBOLIC(TIOCOUTQ)
#define TIOCPTMASTER     SYMBOLIC(TIOCPTMASTER)
#define TIOCREMOTE       SYMBOLIC(TIOCREMOTE)
#define TIOCSBRK         SYMBOLIC(TIOCSBRK)
#define TIOCSCTTY        SYMBOLIC(TIOCSCTTY)
#define TIOCSDRAINWAIT   SYMBOLIC(TIOCSDRAINWAIT)
#define TIOCSDTR         SYMBOLIC(TIOCSDTR)
#define TIOCSERGETLSR    SYMBOLIC(TIOCSERGETLSR)
#define TIOCSERGETMULTI  SYMBOLIC(TIOCSERGETMULTI)
#define TIOCSERSETMULTI  SYMBOLIC(TIOCSERSETMULTI)
#define TIOCSER_TEMT     SYMBOLIC(TIOCSER_TEMT)
#define TIOCSETD         SYMBOLIC(TIOCSETD)
#define TIOCSETVERAUTH   SYMBOLIC(TIOCSETVERAUTH)
#define TIOCSFLAGS       SYMBOLIC(TIOCSFLAGS)
#define TIOCSIG          SYMBOLIC(TIOCSIG)
#define TIOCSPGRP        SYMBOLIC(TIOCSPGRP)
#define TIOCSTART        SYMBOLIC(TIOCSTART)
#define TIOCSTAT         SYMBOLIC(TIOCSTAT)
#define TIOCSTI          SYMBOLIC(TIOCSTI)
#define TIOCSTSTAMP      SYMBOLIC(TIOCSTSTAMP)
#define TIOCSWINSZ       SYMBOLIC(TIOCSWINSZ)
#define TIOCTIMESTAMP    SYMBOLIC(TIOCTIMESTAMP)
#define TIOCUCNTL_CBRK   SYMBOLIC(TIOCUCNTL_CBRK)
#define TOSTOP           SYMBOLIC(TOSTOP)
#define TTYDISC          SYMBOLIC(TTYDISC)
#define VDISCARD         SYMBOLIC(VDISCARD)
#define VEOF             SYMBOLIC(VEOF)
#define VEOL             SYMBOLIC(VEOL)
#define VEOL2            SYMBOLIC(VEOL2)
#define VERASE           SYMBOLIC(VERASE)
#define VERIFY           SYMBOLIC(VERIFY)
#define VINTR            SYMBOLIC(VINTR)
#define VKILL            SYMBOLIC(VKILL)
#define VLNEXT           SYMBOLIC(VLNEXT)
#define VMIN             SYMBOLIC(VMIN)
#define VQUIT            SYMBOLIC(VQUIT)
#define VREPRINT         SYMBOLIC(VREPRINT)
#define VSTART           SYMBOLIC(VSTART)
#define VSTOP            SYMBOLIC(VSTOP)
#define VSUSP            SYMBOLIC(VSUSP)
#define VSWTC            SYMBOLIC(VSWTC)
#define VTIME            SYMBOLIC(VTIME)
#define VWERASE          SYMBOLIC(VWERASE)
#define XCASE            SYMBOLIC(XCASE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system calls » ioctl                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int ioctl(int, uint64_t, void *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system calls » ioctl » undiamonding (size optimization)   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

#define ioctl(FD, REQUEST, MEMORY) ioctl_dispatch(FD, REQUEST, MEMORY)

#define __IOCTL_DISPATCH(CMP, FD, REQUEST, MEMORY)                       \
  do {                                                                   \
    if (CMP(request, TIOCGWINSZ)) return ioctl_tiocgwinsz(FD, MEMORY);   \
    if (CMP(request, TIOCSWINSZ)) return ioctl_tiocswinsz(FD, MEMORY);   \
    if (CMP(request, TCGETS)) return ioctl_tcgets(FD, MEMORY);           \
    if (CMP(request, TCSETS)) return ioctl_tcsets(FD, REQUEST, MEMORY);  \
    if (CMP(request, TCSETSW)) return ioctl_tcsets(FD, REQUEST, MEMORY); \
    if (CMP(request, TCSETSF)) return ioctl_tcsets(FD, REQUEST, MEMORY); \
  } while (0)

int ioctl_tcgets(int, void *);
int ioctl_tcgets_nt(int, void *);
int ioctl_tcsets(int, uint64_t, void *);
int ioctl_tcsets_nt(int, uint64_t, void *);
int ioctl_tiocgwinsz(int, void *);
int ioctl_tiocgwinsz_nt(int, void *);
int ioctl_tiocswinsz(int, void *);
int ioctl_tiocswinsz_nt(int, void *);
int ioctl_default(int, uint64_t, void *);

forceinline int ioctl_dispatch(int fd, uint64_t request, void *memory) {
  __IOCTL_DISPATCH(EQUIVALENT, fd, request, memory);
  return ioctl_default(fd, request, memory);
}

#endif /* GNUC && !ANSI */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/ntspawn.h */

#define COSMOPOLITAN_LIBC_CALLS_NTSPAWN_H_


/*!BEGIN libc/nt/struct/processinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PROCESSINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtProcessInformation {
  int64_t hProcess;
  int64_t hThread;
  uint32_t dwProcessId;
  uint32_t dwThreadId;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/securityattributes.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SECURITYATTRIBUTES_H_


/*!BEGIN libc/nt/struct/securitydescriptor.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SECURITYDESCRIPTOR_H_


/*!BEGIN libc/nt/struct/acl.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_ACL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtAcl {
  uint8_t AclRevision;
  uint8_t Sbz1;
  uint16_t AclSize;
  uint16_t AceCount;
  uint16_t Sbz2;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSecurityDescriptor {
  uint8_t Revision;
  uint8_t Sbz1;
  uint16_t Control;
  void *Owner;
  void *Group;
  struct NtAcl *Sacl;
  struct NtAcl *Dacl;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSecurityAttributes {
  uint32_t nLength;
  struct NtSecurityDescriptor *lpSecurityDescriptor;
  bool32 bInheritHandle;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/startupinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_STARTUPINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtStartupInfo {
  uint32_t cb /* = sizeof(struct NtStartupInfo) */;
  uint16_t *lpReserved;
  char16_t *lpDesktop;
  char16_t *lpTitle; /* title of *new* console window only */
  uint32_t dwX;      /* position of window on screen */
  uint32_t dwY;
  uint32_t dwXSize;
  uint32_t dwYSize;
  uint32_t dwXCountChars; /* used to dimension the dos terminal */
  uint32_t dwYCountChars;
  uint32_t dwFillAttribute;
  uint32_t dwFlags;
  uint16_t wShowWindow;
  uint16_t cbReserved2;
  uint8_t *lpReserved2;
  union {
    struct {
      int64_t hStdInput;
      int64_t hStdOutput;
      int64_t hStdError;
    };
    int64_t stdiofds[3];
  };
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int mkntcmdline(char16_t[ARG_MAX], const char *, char *const[]) hidden;
int mkntenvblock(char16_t[ARG_MAX], char *const[], const char *) hidden;
int ntspawn(const char *, char *const[], char *const[], const char *,
            struct NtSecurityAttributes *, struct NtSecurityAttributes *,
            bool32, uint32_t, const char16_t *, const struct NtStartupInfo *,
            struct NtProcessInformation *) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/scheduler.h */

#define COSMOPOLITAN_LIBC_CALLS_SCHED_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int sched_setscheduler(int, int, const struct sched_param *);
int sched_getscheduler(int);
int sched_setparam(int, const struct sched_param *);
int sched_getparam(int, struct sched_param *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/sigbits.h */

#define COSMOPOLITAN_LIBC_CALLS_SIGBITS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int sigaddset(sigset_t *, int) paramsnonnull();
int sigdelset(sigset_t *, int) paramsnonnull();
int sigemptyset(sigset_t *) paramsnonnull();
int sigfillset(sigset_t *) paramsnonnull();
int sigismember(const sigset_t *, int) paramsnonnull() nosideeffect;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/termios.h */

#define COSMOPOLITAN_LIBC_CALLS_TERMIOS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § teletypewriter control                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int tcgetattr(int, struct termios *);
int tcsetattr(int, int, const struct termios *);
int tcsetpgrp(int, int32_t);
int32_t tcgetpgrp(int);

int openpty(int *, int *, char *, const struct termios *,
            const struct winsize *) paramsnonnull((1, 2)) nodiscard;
int forkpty(int *, char *, const struct termios *, const struct winsize *)
    paramsnonnull((1, 2)) nodiscard;
errno_t ptsname_r(int, char *, size_t);

int grantpt(int);
int unlockpt(int);
int posix_openpt(int) nodiscard;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § teletypewriter » undiamonding                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

#define tcsetattr(FD, OPT, TIO) tcsetattr_dispatch(FD, OPT, TIO)
forceinline int tcsetattr_dispatch(int fd, int opt, const struct termios *tio) {
  if (EQUIVALENT(opt, TCSANOW)) return ioctl(fd, TCSETS, (void *)tio);
  if (EQUIVALENT(opt, TCSADRAIN)) return ioctl(fd, TCSETSW, (void *)tio);
  if (EQUIVALENT(opt, TCSAFLUSH)) return ioctl(fd, TCSETSF, (void *)tio);
  return (tcsetattr)(fd, opt, tio);
}

#define tcgetattr(FD, TIO) tcgetattr_dispatch(FD, TIO)
forceinline int tcgetattr_dispatch(int fd, const struct termios *tio) {
  return ioctl(fd, TCGETS, (void *)tio);
}

#endif /* GNUC && !ANSI */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/wait4.h */

#define COSMOPOLITAN_LIBC_CALLS_WAIT4_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int sys_wait4_nt(int, int *, int, struct rusage *) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/weirdtypes.h */

#define COSMOPOLITAN_LIBC_CALLS_WEIRDTYPES_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * @fileoverview Types we'd prefer hadn't been invented.
 */

#define blkcnt_t      int64_t
#define blksize_t     int64_t /* int32_t on xnu */
#define cc_t          uint8_t
#define clock_t       int64_t /* uint64_t on xnu */
#define cpu_set_t     uint64_t
#define dev_t         uint64_t /* int32_t on xnu */
#define fsblkcnt_t    int64_t
#define fsfilcnt_t    int64_t /* uint32_t on xnu */
#define gid_t         uint32_t
#define id_t          uint32_t /* int32_t on linux/freebsd/etc. */
#define in_addr_t     uint32_t
#define in_addr_t     uint32_t
#define in_port_t     uint16_t
#define in_port_t     uint16_t
#define ino_t         uint64_t
#define key_t         int32_t
#define loff_t        int64_t
#define mode_t        uint32_t /* uint16_t on xnu */
#define nfds_t        uint64_t
#define off_t         int64_t
#define pid_t         int32_t
#define register_t    int64_t
#define sa_family_t   uint16_t /* bsd:uint8_t */
#define socklen_t     uint32_t
#define speed_t       uint32_t
#define suseconds_t   int64_t /* int32_t on xnu */
#define syscall_arg_t int64_t /* uint64_t on xnu */
#define tcflag_t      uint32_t
#define time_t        int64_t
#define timer_t       void*
#define uid_t         uint32_t

#define int_fast8_t   __INT_FAST8_TYPE__
#define uint_fast8_t  __UINT_FAST8_TYPE__
#define int_fast16_t  __INT_FAST16_TYPE__
#define uint_fast16_t __UINT_FAST16_TYPE__
#define int_fast32_t  __INT_FAST32_TYPE__
#define uint_fast32_t __UINT_FAST32_TYPE__
#define int_fast64_t  __INT_FAST64_TYPE__
#define uint_fast64_t __UINT_FAST64_TYPE__

#define atomic_bool           _Atomic(_Bool)
#define atomic_bool32         atomic_int_fast32_t
#define atomic_char           _Atomic(char)
#define atomic_schar          _Atomic(signed char)
#define atomic_uchar          _Atomic(unsigned char)
#define atomic_short          _Atomic(short)
#define atomic_ushort         _Atomic(unsigned short)
#define atomic_int            _Atomic(int)
#define atomic_uint           _Atomic(unsigned int)
#define atomic_long           _Atomic(long)
#define atomic_ulong          _Atomic(unsigned long)
#define atomic_llong          _Atomic(long long)
#define atomic_ullong         _Atomic(unsigned long long)
#define atomic_char16_t       _Atomic(char16_t)
#define atomic_char32_t       _Atomic(char32_t)
#define atomic_wchar_t        _Atomic(wchar_t)
#define atomic_int_least8_t   _Atomic(int_least8_t)
#define atomic_uint_least8_t  _Atomic(uint_least8_t)
#define atomic_int_least16_t  _Atomic(int_least16_t)
#define atomic_uint_least16_t _Atomic(uint_least16_t)
#define atomic_int_least32_t  _Atomic(int_least32_t)
#define atomic_uint_least32_t _Atomic(uint_least32_t)
#define atomic_int_least64_t  _Atomic(int_least64_t)
#define atomic_uint_least64_t _Atomic(uint_least64_t)
#define atomic_int_fast8_t    _Atomic(int_fast8_t)
#define atomic_uint_fast8_t   _Atomic(uint_fast8_t)
#define atomic_int_fast16_t   _Atomic(int_fast16_t)
#define atomic_uint_fast16_t  _Atomic(uint_fast16_t)
#define atomic_int_fast32_t   _Atomic(int_fast32_t)
#define atomic_uint_fast32_t  _Atomic(uint_fast32_t)
#define atomic_int_fast64_t   _Atomic(int_fast64_t)
#define atomic_uint_fast64_t  _Atomic(uint_fast64_t)
#define atomic_intptr_t       _Atomic(intptr_t)
#define atomic_uintptr_t      _Atomic(uintptr_t)
#define atomic_size_t         _Atomic(size_t)
#define atomic_ptrdiff_t      _Atomic(ptrdiff_t)

#ifdef __CLANG_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_BOOL_LOCK_FREE     __CLANG_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE     __CLANG_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE __CLANG_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE __CLANG_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE  __CLANG_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_SHORT_LOCK_FREE    __CLANG_ATOMIC_SHORT_LOCK_FREE
#define ATOMIC_INT_LOCK_FREE      __CLANG_ATOMIC_INT_LOCK_FREE
#define ATOMIC_LONG_LOCK_FREE     __CLANG_ATOMIC_LONG_LOCK_FREE
#define ATOMIC_LLONG_LOCK_FREE    __CLANG_ATOMIC_LLONG_LOCK_FREE
#define ATOMIC_POINTER_LOCK_FREE  __CLANG_ATOMIC_POINTER_LOCK_FREE
#else
#define ATOMIC_BOOL_LOCK_FREE     __GCC_ATOMIC_BOOL_LOCK_FREE
#define ATOMIC_CHAR_LOCK_FREE     __GCC_ATOMIC_CHAR_LOCK_FREE
#define ATOMIC_CHAR16_T_LOCK_FREE __GCC_ATOMIC_CHAR16_T_LOCK_FREE
#define ATOMIC_CHAR32_T_LOCK_FREE __GCC_ATOMIC_CHAR32_T_LOCK_FREE
#define ATOMIC_WCHAR_T_LOCK_FREE  __GCC_ATOMIC_WCHAR_T_LOCK_FREE
#define ATOMIC_SHORT_LOCK_FREE    __GCC_ATOMIC_SHORT_LOCK_FREE
#define ATOMIC_INT_LOCK_FREE      __GCC_ATOMIC_INT_LOCK_FREE
#define ATOMIC_LONG_LOCK_FREE     __GCC_ATOMIC_LONG_LOCK_FREE
#define ATOMIC_LLONG_LOCK_FREE    __GCC_ATOMIC_LLONG_LOCK_FREE
#define ATOMIC_POINTER_LOCK_FREE  __GCC_ATOMIC_POINTER_LOCK_FREE
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/calls/xattr.h */

#define COSMOPOLITAN_LIBC_CALLS_XATTR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

ssize_t flistxattr(int, char *, size_t);
ssize_t fgetxattr(int, const char *, void *, size_t);
int fsetxattr(int, const char *, const void *, size_t, int);
int fremovexattr(int, const char *);
ssize_t listxattr(const char *, char *, size_t);
ssize_t getxattr(const char *, const char *, void *, size_t);
int setxattr(const char *, const char *, const void *, size_t, int);
int removexattr(const char *, const char *);
ssize_t llistxattr(const char *, char *, size_t);
ssize_t lgetxattr(const char *, const char *, void *, size_t);
int lsetxattr(const char *, const char *, const void *, size_t, int);
int lremovexattr(const char *, const char *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/crypto/rijndael.h */

#define COSMOPOLITAN_LIBC_CRYPTO_RIJNDAEL_H_
#ifndef __STRICT_ANSI__
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § cryptography » advanced encryption standard               ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─┘
    AES-256 Latency                                  x86 2010+    SSE2
    ───────────────                                  ─────────   ──────
    rijndael(14, block, &ctx)                           23 ns    218 ns
    unrijndael(14, block, &ctx)                         23 ns    690 ns
    rijndaelinit(&ctx, 14, k1, k2)                     136 ns    135 ns
    unrijndaelinit(&ctx, 14, k1, k2)                   186 ns    639 ns

    Untrustworthy System Viability                   x86 2010+    SSE2
    ──────────────────────────────                   ─────────   ──────
    rijndael(14, block, &ctx)                             A        C
    unrijndael(14, block, &ctx)                           A        C
    rijndaelinit(&ctx, 14, k1, k2)                        B        B
    unrijndaelinit(&ctx, 14, k1, k2)                      B        C

    Comparison                                   Cosmo    Rijndael  Tiny-AES
    ──────────────────────────────              ───────   ────────  ────────
    Generalized Math                               Yes        Yes       No
    Footprint                                  1,782 b    9,258 b     903 b
    Performance (New Hardware)                   ~20 ns     ~40 ns   ~400 ns
    Performance (Old Hardware)                  ~400 ns     ~40 ns   ~400 ns */

typedef uint32_t aes_block_t _Vector_size(16) forcealign(16);

struct Rijndael {
  union {
    aes_block_t xmm;
    uint32_t u32[4];
    uint8_t u8[16];
  } rk[15];
};

void rijndaelinit(struct Rijndael *, uint32_t, aes_block_t, aes_block_t);
aes_block_t rijndael(uint32_t, aes_block_t, const struct Rijndael *);
void unrijndaelinit(struct Rijndael *, uint32_t, aes_block_t, aes_block_t);
aes_block_t unrijndael(uint32_t, aes_block_t, const struct Rijndael *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § cryptography » implementation details                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

extern const uint8_t kAesSbox[256] forcealign(64);
extern const uint8_t kAesSboxInverse[256] forcealign(64);

aes_block_t InvMixColumns(aes_block_t) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#endif /* !ANSI */


/*!BEGIN libc/dns/consts.h */

#define COSMOPOLITAN_LIBC_DNS_CONSTS_H_


/*!BEGIN libc/sock/sock.h */

#define COSMOPOLITAN_LIBC_SOCK_SOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § system api » berkeley sockets                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define INET_ADDRSTRLEN 22

#define NI_DGRAM   0x10
#define NI_MAXSERV 0x20

#define htons(u16) bswap_16(u16)
#define ntohs(u16) bswap_16(u16)
#define htonl(u32) bswap_32(u32)
#define ntohl(u32) bswap_32(u32)

struct iovec;
struct sigset;
struct timespec;
struct timeval;
struct addrinfo;

struct in_addr { /* ARPA ABI */
  /* e.g. 127|0<<8|0<<16|1<<24 or inet_pton(AF_INET, "127.0.0.1", &s_addr) */
  uint32_t s_addr;
};

struct sockaddr {     /* Linux+NT ABI */
  uint16_t sa_family; /* AF_XXX */
  char sa_data[14];
};

struct sockaddr_in {   /* Linux+NT ABI */
  uint16_t sin_family; /* AF_XXX */
  uint16_t sin_port;   /* htons(XXX) i.e. big endian */
  struct in_addr sin_addr;
  uint8_t sin_zero[8];
};

struct sockaddr_storage {
  union {
    uint16_t ss_family;
    intptr_t __ss_align;
    char __ss_storage[128];
  };
};

struct pollfd {
  int32_t fd;
  int16_t events;
  int16_t revents;
};

struct msghdr {            /* Linux+NT ABI */
  void *msg_name;          /* optional address */
  int32_t msg_namelen;     /* size of msg_name */
  struct iovec *msg_iov;   /* scatter/gather array */
  uint64_t msg_iovlen;     /* iovec count */
  void *msg_control;       /* credentials and stuff */
  uint64_t msg_controllen; /* size of msg_control */
  uint32_t msg_flags;      /* MSG_XXX */
};

const char *inet_ntop(int, const void *, char *, uint32_t);
int inet_pton(int af, const char *, void *);
int parseport(const char *);

int socket(int, int, int) nodiscard;
int accept(int, void *, uint32_t *) nodiscard;
int accept4(int, void *, uint32_t *, int) nodiscard;
int bind(int, const void *, uint32_t);
int connect(int, const void *, uint32_t);
int socketconnect(const struct addrinfo *, int);
int listen(int, int);
int shutdown(int, int);
int getsockname(int, void *, uint32_t *) paramsnonnull();
int getpeername(int, void *, uint32_t *) paramsnonnull();
ssize_t send(int, const void *, size_t, int) paramsnonnull();
ssize_t recv(int, void *, size_t, int);
ssize_t recvmsg(int, struct msghdr *, uint32_t) paramsnonnull();
ssize_t recvfrom(int, void *, size_t, uint32_t, void *, uint32_t *);
ssize_t sendmsg(int, const struct msghdr *, int) paramsnonnull();
ssize_t readv(int, const struct iovec *, int);
ssize_t writev(int, const struct iovec *, int);
ssize_t sendfile(int, int, int64_t *, size_t);
int getsockopt(int, int, int, void *, uint32_t *) paramsnonnull((5));
int setsockopt(int, int, int, const void *, uint32_t);
int socketpair(int, int, int, int64_t[2]) paramsnonnull();
int poll(struct pollfd *, uint64_t, int32_t) paramsnonnull();
int ppoll(struct pollfd *, uint64_t, const struct timespec *,
          const struct sigset *) paramsnonnull((1, 4));
ssize_t sendto(int, const void *, size_t, uint32_t, const void *, uint32_t)
    paramsnonnull((2));

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define DNS_TYPE_A 1
#define DNS_CLASS_IN 1

#define kMinSockaddr4Size \
  (offsetof(struct sockaddr_in, sin_addr) + sizeof(struct in_addr))

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/dns.h */

#define COSMOPOLITAN_LIBC_DNS_DNS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define DNS_PORT 53
#define DNS_NAME_MAX 253
#define DNS_LABEL_MAX 63

struct sockaddr;
struct sockaddr_in;
struct ResolvConf;

struct addrinfo {
  int32_t ai_flags;    /* AI_XXX */
  int32_t ai_family;   /* AF_INET */
  int32_t ai_socktype; /* SOCK_XXX */
  int32_t ai_protocol; /* IPPROTO_XXX */
  uint32_t ai_addrlen;
  union {
    struct sockaddr *ai_addr;
    struct sockaddr_in *ai_addr4;
  };
  char *ai_canonname /*[DNS_NAME_MAX + 1]*/;
  struct addrinfo *ai_next;
};

int getaddrinfo(const char *, const char *, const struct addrinfo *,
                struct addrinfo **) paramsnonnull((4));
int freeaddrinfo(struct addrinfo *);
const char *eai2str(int);
int dnsnamecmp(const char *, const char *) paramsnonnull();
int pascalifydnsname(uint8_t *, size_t, const char *) paramsnonnull();
int resolvedns(const struct ResolvConf *, int, const char *, struct sockaddr *,
               uint32_t) paramsnonnull();
struct addrinfo *newaddrinfo(uint16_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/dnsheader.h */

#define COSMOPOLITAN_LIBC_DNS_DNSHEADER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct DnsHeader {
  uint16_t id;      /* transaction id */
  uint8_t bf1;      /* bit field 1 */
  uint8_t bf2;      /* bit field 2 */
  uint16_t qdcount; /* question count */
  uint16_t ancount; /* answer count */
  uint16_t nscount; /* nameserver count */
  uint16_t arcount; /* additional record count */
};

int serializednsheader(uint8_t *, size_t, const struct DnsHeader);
int deserializednsheader(struct DnsHeader *, const uint8_t *, size_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/dnsquestion.h */

#define COSMOPOLITAN_LIBC_DNS_DNSQUESTION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct DnsQuestion {
  const char *qname;
  uint16_t qtype;
  uint16_t qclass;
};

int serializednsquestion(uint8_t *, size_t, struct DnsQuestion);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/hoststxt.h */

#define COSMOPOLITAN_LIBC_DNS_HOSTSTXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct FILE;
struct sockaddr;

struct HostsTxtEntry {
  unsigned char ip[4]; /* inet_ntop(AF_INET, he->ip, buf, size) */
  uint32_t name;       /* &ht->strings.p[he->name] */
  uint32_t canon;      /* &ht->strings.p[he->canon] */
};

struct HostsTxtEntries {
  size_t i;
  size_t n;
  struct HostsTxtEntry *p;
};

struct HostsTxtStrings {
  size_t i;
  size_t n;
  char *p;
};

struct HostsTxt {
  struct HostsTxtEntries entries;
  struct HostsTxtStrings strings;
};

const struct HostsTxt *gethoststxt(void) returnsnonnull;
void freehoststxt(struct HostsTxt **) paramsnonnull();
int parsehoststxt(struct HostsTxt *, struct FILE *) paramsnonnull();
void sorthoststxt(struct HostsTxt *) paramsnonnull();
int resolvehoststxt(const struct HostsTxt *, int, const char *,
                    struct sockaddr *, uint32_t, const char **)
    paramsnonnull((1, 3));

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/dns/resolvconf.h */

#define COSMOPOLITAN_LIBC_DNS_RESOLVCONF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct FILE;
struct sockaddr_in;

struct Nameservers {
  size_t i, n;
  struct sockaddr_in *p;
};

struct ResolvConf {
  struct Nameservers nameservers;
};

const struct ResolvConf *getresolvconf(void) returnsnonnull;
int parseresolvconf(struct ResolvConf *, struct FILE *) paramsnonnull();
void freeresolvconf(struct ResolvConf **) paramsnonnull();
int getntnameservers(struct ResolvConf *) paramsnonnull();

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/def.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_DEF_H_

/**
 * @fileoverview Executable and Linkable Format Definitions.
 */

#define EI_MAG0 0
#define EI_MAG1 1
#define EI_MAG2 2
#define EI_MAG3 3

#define ELFMAG  "\177ELF"
#define ELFMAG0 0x7f
#define ELFMAG1 'E'
#define ELFMAG2 'L'
#define ELFMAG3 'F'
#define SELFMAG 4

#define EI_CLASS     4
#define ELFCLASSNONE 0
#define ELFCLASS32   1
#define ELFCLASS64   2
#define ELFCLASSNUM  3

#define EI_DATA     5
#define ELFDATANONE 0
#define ELFDATA2LSB 1
#define ELFDATA2MSB 2
#define ELFDATANUM  3

#define EI_VERSION 6

#define EI_OSABI            7
#define ELFOSABI_NONE       0
#define ELFOSABI_SYSV       0
#define ELFOSABI_HPUX       1
#define ELFOSABI_NETBSD     2
#define ELFOSABI_LINUX      3
#define ELFOSABI_GNU        3
#define ELFOSABI_SOLARIS    6
#define ELFOSABI_AIX        7
#define ELFOSABI_IRIX       8
#define ELFOSABI_FREEBSD    9
#define ELFOSABI_TRU64      10
#define ELFOSABI_MODESTO    11
#define ELFOSABI_OPENBSD    12
#define ELFOSABI_ARM        97
#define ELFOSABI_STANDALONE 255

#define EI_ABIVERSION 8

#define EI_PAD 9

#define ET_NONE   0
#define ET_REL    1
#define ET_EXEC   2
#define ET_DYN    3
#define ET_CORE   4
#define ET_NUM    5
#define ET_LOOS   0xfe00
#define ET_HIOS   0xfeff
#define ET_LOPROC 0xff00
#define ET_HIPROC 0xffff

#define EM_NONE      0
#define EM_M32       1
#define EM_386       3
#define EM_S390      22
#define EM_ARM       40
#define EM_NEXGEN32E 62
#define EM_X86_64    EM_NEXGEN32E
#define EM_IA32E     EM_NEXGEN32E
#define EM_AMD64     EM_NEXGEN32E
#define EM_PDP11     65
#define EM_CRAYNV2   172
#define EM_L10M      180
#define EM_K10M      181
#define EM_AARCH64   183
#define EM_CUDA      190
#define EM_Z80       220
#define EM_RISCV     243
#define EM_BPF       247

#define GRP_COMDAT 0x1
#define STN_UNDEF  0

#define EV_NONE    0
#define EV_CURRENT 1
#define EV_NUM     2

#define SYMINFO_NONE          0
#define SYMINFO_CURRENT       1
#define SYMINFO_NUM           2
#define SYMINFO_BT_SELF       0xffff
#define SYMINFO_BT_PARENT     0xfffe
#define SYMINFO_BT_LOWRESERVE 0xff00
#define SYMINFO_FLG_DIRECT    0x0001
#define SYMINFO_FLG_PASSTHRU  0x0002
#define SYMINFO_FLG_COPY      0x0004
#define SYMINFO_FLG_LAZYLOAD  0x0008

#define PT_NULL         0
#define PT_LOAD         1
#define PT_DYNAMIC      2
#define PT_INTERP       3
#define PT_NOTE         4
#define PT_SHLIB        5
#define PT_PHDR         6
#define PT_TLS          7
#define PT_NUM          8
#define PT_LOOS         0x60000000
#define PT_GNU_EH_FRAME 0x6474e550
#define PT_GNU_STACK    0x6474e551
#define PT_GNU_RELRO    0x6474e552
#define PT_LOSUNW       0x6ffffffa
#define PT_SUNWBSS      0x6ffffffa
#define PT_SUNWSTACK    0x6ffffffb
#define PT_HISUNW       0x6fffffff
#define PT_HIOS         0x6fffffff
#define PT_LOPROC       0x70000000
#define PT_HIPROC       0x7fffffff

#define PN_XNUM 0xffff

#define PF_X        (1 << 0)
#define PF_W        (1 << 1)
#define PF_R        (1 << 2)
#define PF_MASKOS   0x0ff00000
#define PF_MASKPROC 0xf0000000

#define R_X86_64_NONE            0
#define R_X86_64_64              1
#define R_X86_64_PC32            2
#define R_X86_64_GOT32           3
#define R_X86_64_PLT32           4
#define R_X86_64_COPY            5
#define R_X86_64_GLOB_DAT        6
#define R_X86_64_JUMP_SLOT       7
#define R_X86_64_RELATIVE        8
#define R_X86_64_GOTPCREL        9
#define R_X86_64_32              10
#define R_X86_64_32S             11
#define R_X86_64_16              12
#define R_X86_64_PC16            13
#define R_X86_64_8               14
#define R_X86_64_PC8             15
#define R_X86_64_DTPMOD64        16
#define R_X86_64_DTPOFF64        17
#define R_X86_64_TPOFF64         18
#define R_X86_64_TLSGD           19
#define R_X86_64_TLSLD           20
#define R_X86_64_DTPOFF32        21
#define R_X86_64_GOTTPOFF        22
#define R_X86_64_TPOFF32         23
#define R_X86_64_PC64            24
#define R_X86_64_GOTOFF64        25
#define R_X86_64_GOTPC32         26
#define R_X86_64_GOT64           27
#define R_X86_64_GOTPCREL64      28
#define R_X86_64_GOTPC64         29
#define R_X86_64_GOTPLT64        30
#define R_X86_64_PLTOFF64        31
#define R_X86_64_SIZE32          32
#define R_X86_64_SIZE64          33
#define R_X86_64_GOTPC32_TLSDESC 34
#define R_X86_64_TLSDESC_CALL    35
#define R_X86_64_TLSDESC         36
#define R_X86_64_IRELATIVE       37
#define R_X86_64_RELATIVE64      38
#define R_X86_64_GOTPCRELX       41 /* 6 bytes */
#define R_X86_64_REX_GOTPCRELX   42 /* 7 bytes */
#define R_X86_64_NUM             43

#define STB_LOCAL      0
#define STB_GLOBAL     1
#define STB_WEAK       2
#define STB_NUM        3
#define STB_LOOS       10
#define STB_GNU_UNIQUE 10
#define STB_HIOS       12
#define STB_LOPROC     13
#define STB_HIPROC     15

#define STT_NOTYPE    0
#define STT_OBJECT    1
#define STT_FUNC      2
#define STT_SECTION   3
#define STT_FILE      4
#define STT_COMMON    5
#define STT_TLS       6
#define STT_NUM       7
#define STT_LOOS      10
#define STT_GNU_IFUNC 10
#define STT_HIOS      12
#define STT_LOPROC    13
#define STT_HIPROC    15

#define STV_DEFAULT   0
#define STV_INTERNAL  1
#define STV_HIDDEN    2
#define STV_PROTECTED 3

#define SHN_UNDEF     0
#define SHN_LORESERVE 0xff00
#define SHN_LOPROC    0xff00
#define SHN_BEFORE    0xff00
#define SHN_AFTER     0xff01
#define SHN_HIPROC    0xff1f
#define SHN_LOOS      0xff20
#define SHN_HIOS      0xff3f
#define SHN_ABS       0xfff1
#define SHN_COMMON    0xfff2
#define SHN_XINDEX    0xffff
#define SHN_HIRESERVE 0xffff

#define SHF_WRITE            (1 << 0)
#define SHF_ALLOC            (1 << 1)
#define SHF_EXECINSTR        (1 << 2)
#define SHF_MERGE            (1 << 4)
#define SHF_STRINGS          (1 << 5)
#define SHF_INFO_LINK        (1 << 6)
#define SHF_LINK_ORDER       (1 << 7)
#define SHF_OS_NONCONFORMING (1 << 8)
#define SHF_GROUP            (1 << 9)
#define SHF_TLS              (1 << 10)
#define SHF_COMPRESSED       (1 << 11)
#define SHF_MASKOS           0x0ff00000
#define SHF_MASKPROC         0xf0000000
#define SHF_ORDERED          (1 << 30)
#define SHF_EXCLUDE          (1U << 31)

#define ELFCOMPRESS_ZLIB   1
#define ELFCOMPRESS_LOOS   0x60000000
#define ELFCOMPRESS_HIOS   0x6fffffff
#define ELFCOMPRESS_LOPROC 0x70000000
#define ELFCOMPRESS_HIPROC 0x7fffffff

#define SHT_NULL           0
#define SHT_PROGBITS       1
#define SHT_SYMTAB         2
#define SHT_STRTAB         3
#define SHT_RELA           4
#define SHT_HASH           5
#define SHT_DYNAMIC        6
#define SHT_NOTE           7
#define SHT_NOBITS         8
#define SHT_REL            9
#define SHT_SHLIB          10
#define SHT_DYNSYM         11
#define SHT_INIT_ARRAY     14
#define SHT_FINI_ARRAY     15
#define SHT_PREINIT_ARRAY  16
#define SHT_GROUP          17
#define SHT_SYMTAB_SHNDX   18
#define SHT_NUM            19
#define SHT_LOOS           0x60000000
#define SHT_GNU_ATTRIBUTES 0x6ffffff5
#define SHT_GNU_HASH       0x6ffffff6
#define SHT_GNU_LIBLIST    0x6ffffff7
#define SHT_CHECKSUM       0x6ffffff8
#define SHT_LOSUNW         0x6ffffffa
#define SHT_SUNW_move      0x6ffffffa
#define SHT_SUNW_COMDAT    0x6ffffffb
#define SHT_SUNW_syminfo   0x6ffffffc
#define SHT_GNU_verdef     0x6ffffffd
#define SHT_GNU_verneed    0x6ffffffe
#define SHT_GNU_versym     0x6fffffff
#define SHT_HISUNW         0x6fffffff
#define SHT_HIOS           0x6fffffff
#define SHT_LOPROC         0x70000000
#define SHT_HIPROC         0x7fffffff
#define SHT_LOUSER         0x80000000
#define SHT_HIUSER         0x8fffffff

#define DT_NULL               0
#define DT_NEEDED             1
#define DT_PLTRELSZ           2
#define DT_PLTGOT             3
#define DT_HASH               4
#define DT_STRTAB             5
#define DT_SYMTAB             6
#define DT_RELA               7
#define DT_RELASZ             8
#define DT_RELAENT            9
#define DT_STRSZ              10
#define DT_SYMENT             11
#define DT_INIT               12
#define DT_FINI               13
#define DT_SONAME             14
#define DT_RPATH              15
#define DT_SYMBOLIC           16
#define DT_REL                17
#define DT_RELSZ              18
#define DT_RELENT             19
#define DT_PLTREL             20
#define DT_DEBUG              21
#define DT_TEXTREL            22
#define DT_JMPREL             23
#define DT_BIND_NOW           24
#define DT_INIT_ARRAY         25
#define DT_FINI_ARRAY         26
#define DT_INIT_ARRAYSZ       27
#define DT_FINI_ARRAYSZ       28
#define DT_RUNPATH            29
#define DT_FLAGS              30
#define DT_ENCODING           32
#define DT_PREINIT_ARRAY      32
#define DT_PREINIT_ARRAYSZ    33
#define DT_SYMTAB_SHNDX       34
#define DT_NUM                35
#define DT_LOOS               0x6000000d
#define DT_HIOS               0x6ffff000
#define DT_LOPROC             0x70000000
#define DT_HIPROC             0x7fffffff
#define DT_VALRNGLO           0x6ffffd00
#define DT_GNU_PRELINKED      0x6ffffdf5
#define DT_GNU_CONFLICTSZ     0x6ffffdf6
#define DT_GNU_LIBLISTSZ      0x6ffffdf7
#define DT_CHECKSUM           0x6ffffdf8
#define DT_PLTPADSZ           0x6ffffdf9
#define DT_MOVEENT            0x6ffffdfa
#define DT_MOVESZ             0x6ffffdfb
#define DT_FEATURE_1          0x6ffffdfc
#define DT_POSFLAG_1          0x6ffffdfd
#define DT_SYMINSZ            0x6ffffdfe
#define DT_SYMINENT           0x6ffffdff
#define DT_VALRNGHI           0x6ffffdff
#define DT_VALTAGIDX(tag)     (DT_VALRNGHI - (tag))
#define DT_VALNUM             12
#define DT_ADDRRNGLO          0x6ffffe00
#define DT_GNU_HASH           0x6ffffef5
#define DT_TLSDESC_PLT        0x6ffffef6
#define DT_TLSDESC_GOT        0x6ffffef7
#define DT_GNU_CONFLICT       0x6ffffef8
#define DT_GNU_LIBLIST        0x6ffffef9
#define DT_CONFIG             0x6ffffefa
#define DT_DEPAUDIT           0x6ffffefb
#define DT_AUDIT              0x6ffffefc
#define DT_PLTPAD             0x6ffffefd
#define DT_MOVETAB            0x6ffffefe
#define DT_SYMINFO            0x6ffffeff
#define DT_ADDRRNGHI          0x6ffffeff
#define DT_ADDRTAGIDX(tag)    (DT_ADDRRNGHI - (tag))
#define DT_ADDRNUM            11
#define DT_VERSYM             0x6ffffff0
#define DT_RELACOUNT          0x6ffffff9
#define DT_RELCOUNT           0x6ffffffa
#define DT_FLAGS_1            0x6ffffffb
#define DT_VERDEF             0x6ffffffc
#define DT_VERDEFNUM          0x6ffffffd
#define DT_VERNEED            0x6ffffffe
#define DT_VERNEEDNUM         0x6fffffff
#define DT_VERSIONTAGIDX(tag) (DT_VERNEEDNUM - (tag))
#define DT_VERSIONTAGNUM      16
#define DT_AUXILIARY          0x7ffffffd
#define DT_FILTER             0x7fffffff
#define DT_EXTRATAGIDX(tag)   ((Elf32_Word) - ((Elf32_Sword)(tag) << 1 >> 1) - 1)
#define DT_EXTRANUM           3

#define VER_NEED_NONE    0
#define VER_NEED_CURRENT 1
#define VER_NEED_NUM     2
#define VER_FLG_WEAK     0x2

#define ELF_NOTE_SOLARIS       "SUNW Solaris"
#define ELF_NOTE_GNU           "GNU"
#define ELF_NOTE_PAGESIZE_HINT 1
#define ELF_NOTE_ABI           NT_GNU_ABI_TAG
#define ELF_NOTE_OS_LINUX      0
#define ELF_NOTE_OS_GNU        1
#define ELF_NOTE_OS_SOLARIS2   2
#define ELF_NOTE_OS_FREEBSD    3

#define NT_GNU_ABI_TAG      1
#define NT_GNU_BUILD_ID     3
#define NT_GNU_GOLD_VERSION 4

#define EF_CPU32 0x00810000

#define DF_ORIGIN       0x00000001
#define DF_SYMBOLIC     0x00000002
#define DF_TEXTREL      0x00000004
#define DF_BIND_NOW     0x00000008
#define DF_STATIC_TLS   0x00000010
#define DF_1_NOW        0x00000001
#define DF_1_GLOBAL     0x00000002
#define DF_1_GROUP      0x00000004
#define DF_1_NODELETE   0x00000008
#define DF_1_LOADFLTR   0x00000010
#define DF_1_INITFIRST  0x00000020
#define DF_1_NOOPEN     0x00000040
#define DF_1_ORIGIN     0x00000080
#define DF_1_DIRECT     0x00000100
#define DF_1_TRANS      0x00000200
#define DF_1_INTERPOSE  0x00000400
#define DF_1_NODEFLIB   0x00000800
#define DF_1_NODUMP     0x00001000
#define DF_1_CONFALT    0x00002000
#define DF_1_ENDFILTEE  0x00004000
#define DF_1_DISPRELDNE 0x00008000
#define DF_1_DISPRELPND 0x00010000
#define DF_1_NODIRECT   0x00020000
#define DF_1_IGNMULDEF  0x00040000
#define DF_1_NOKSYMS    0x00080000
#define DF_1_NOHDR      0x00100000
#define DF_1_EDITED     0x00200000
#define DF_1_NORELOC    0x00400000
#define DF_1_SYMINTPOSE 0x00800000
#define DF_1_GLOBAUDIT  0x01000000
#define DF_1_SINGLETON  0x02000000
#define DF_1_STUB       0x04000000
#define DF_1_PIE        0x08000000
#define DTF_1_PARINIT   0x00000001
#define DTF_1_CONFEXP   0x00000002
#define DF_P1_LAZYLOAD  0x00000001
#define DF_P1_GROUPPERM 0x00000002

#define ELF64_ST_BIND(val)        (((unsigned char)(val)) >> 4)
#define ELF64_ST_TYPE(val)        ((val)&0xf)
#define ELF64_ST_INFO(bind, type) (((bind) << 4) + ((type)&0xf))
#define ELF64_ST_VISIBILITY(o)    ((o)&0x03)

#define ELF64_R_SYM(i)          ((i) >> 32)
#define ELF64_R_TYPE(i)         ((i)&0xffffffff)
#define ELF64_R_INFO(sym, type) ((((Elf64_Xword)(sym)) << 32) + (type))

#define ELF64_M_SYM(info)       ((info) >> 8)
#define ELF64_M_SIZE(info)      ((unsigned char)(info))
#define ELF64_M_INFO(sym, size) (((sym) << 8) + (unsigned char)(size))

#define NT_PRSTATUS         1
#define NT_PRFPREG          2
#define NT_FPREGSET         2
#define NT_PRPSINFO         3
#define NT_PRXREG           4
#define NT_TASKSTRUCT       4
#define NT_PLATFORM         5
#define NT_AUXV             6
#define NT_GWINDOWS         7
#define NT_ASRS             8
#define NT_PSTATUS          10
#define NT_PSINFO           13
#define NT_PRCRED           14
#define NT_UTSNAME          15
#define NT_LWPSTATUS        16
#define NT_LWPSINFO         17
#define NT_PRFPXREG         20
#define NT_SIGINFO          0x53494749
#define NT_FILE             0x46494c45
#define NT_PRXFPREG         0x46e62b7f
#define NT_PPC_VMX          0x100
#define NT_PPC_SPE          0x101
#define NT_PPC_VSX          0x102
#define NT_PPC_TAR          0x103
#define NT_PPC_PPR          0x104
#define NT_PPC_DSCR         0x105
#define NT_PPC_EBB          0x106
#define NT_PPC_PMU          0x107
#define NT_PPC_TM_CGPR      0x108
#define NT_PPC_TM_CFPR      0x109
#define NT_PPC_TM_CVMX      0x10a
#define NT_PPC_TM_CVSX      0x10b
#define NT_PPC_TM_SPR       0x10c
#define NT_PPC_TM_CTAR      0x10d
#define NT_PPC_TM_CPPR      0x10e
#define NT_PPC_TM_CDSCR     0x10f
#define NT_X86_XSTATE       0x202
#define NT_S390_HIGH_GPRS   0x300
#define NT_S390_TIMER       0x301
#define NT_S390_TODCMP      0x302
#define NT_S390_TODPREG     0x303
#define NT_S390_CTRS        0x304
#define NT_S390_PREFIX      0x305
#define NT_S390_LAST_BREAK  0x306
#define NT_S390_SYSTEM_CALL 0x307
#define NT_S390_TDB         0x308
#define NT_S390_VXRS_LOW    0x309
#define NT_S390_VXRS_HIGH   0x30a
#define NT_S390_GS_CB       0x30b
#define NT_S390_GS_BC       0x30c
#define NT_S390_RI_CB       0x30d
#define NT_ARM_VFP          0x400
#define NT_ARM_TLS          0x401
#define NT_ARM_HW_BREAK     0x402
#define NT_ARM_HW_WATCH     0x403
#define NT_ARM_SYSTEM_CALL  0x404
#define NT_ARM_SVE          0x405
#define NT_ARM_PAC_MASK     0x406
#define NT_METAG_CBUF       0x500
#define NT_METAG_RPIPE      0x501
#define NT_METAG_TLS        0x502
#define NT_ARC_V2           0x600
#define NT_VMCOREDD         0x700
#define NT_VERSION          1

#define VER_DEF_NONE      0
#define VER_DEF_CURRENT   1
#define VER_DEF_NUM       2
#define VER_FLG_BASE      0x1
#define VER_FLG_WEAK      0x2
#define VER_NDX_LOCAL     0
#define VER_NDX_GLOBAL    1
#define VER_NDX_LORESERVE 0xff00
#define VER_NDX_ELIMINATE 0xff01

#define LL_NONE           0
#define LL_EXACT_MATCH    (1 << 0)
#define LL_IGNORE_INT_VER (1 << 1)
#define LL_REQUIRE_MINOR  (1 << 2)
#define LL_EXPORTS        (1 << 3)
#define LL_DELAY_LOAD     (1 << 4)
#define LL_DELTA          (1 << 5)

#define R_BPF_NONE   0
#define R_BPF_MAP_FD 1



/*!BEGIN libc/elf/elf.h */

#define COSMOPOLITAN_LIBC_ELF_H_


/*!BEGIN libc/elf/struct/ehdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_EHDR_H_


/*!BEGIN libc/elf/scalar.h */

#define COSMOPOLITAN_LIBC_ELF_SCALAR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define Elf64_Half uint16_t
#define Elf64_Word uint32_t
#define Elf64_Sword int32_t
#define Elf64_Xword uint64_t
#define Elf64_Sxword int64_t
#define Elf64_Addr uint64_t
#define Elf64_Off uint64_t
#define Elf64_Section uint16_t
#define Elf64_Versym Elf64_Half

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define EI_NIDENT 16

typedef struct Elf64_Ehdr {
  unsigned char e_ident[EI_NIDENT];
  Elf64_Half e_type;
  Elf64_Half e_machine;
  Elf64_Word e_version;
  Elf64_Addr e_entry;
  Elf64_Off e_phoff;
  Elf64_Off e_shoff;
  Elf64_Word e_flags;
  Elf64_Half e_ehsize;
  Elf64_Half e_phentsize;
  Elf64_Half e_phnum;
  Elf64_Half e_shentsize;
  Elf64_Half e_shnum;
  Elf64_Half e_shstrndx;
} Elf64_Ehdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/phdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_PHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Phdr {
  Elf64_Word p_type;
  Elf64_Word p_flags;
  Elf64_Off p_offset;
  Elf64_Addr p_vaddr;
  Elf64_Addr p_paddr;
  Elf64_Xword p_filesz;
  Elf64_Xword p_memsz;
  Elf64_Xword p_align;
} Elf64_Phdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/shdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_SHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Section header.
 * @see https://docs.oracle.com/cd/E19683-01/816-1386/chapter6-94076/index.html
 */
typedef struct Elf64_Shdr {
  Elf64_Word sh_name;
  Elf64_Word sh_type;   /* SHT_{PROGBITS,NOBITS,STRTAB,SYMTAB,RELA,...} */
  Elf64_Xword sh_flags; /* SHF_{WRITE,ALLOC,EXECINSTR,MERGE,STRINGS,...} */
  Elf64_Addr sh_addr;
  Elf64_Off sh_offset;
  Elf64_Xword sh_size;
  /*
   * If SHT_RELA: Index of section of associated symbol table.
   * If SHT_SYMTAB: Index of section of associated string table.
   */
  Elf64_Word sh_link;
  /*
   * If SHT_RELA: Index of section to which relocations apply.
   * If SHT_SYMTAB: One greater than symbol table index of last local symbol.
   */
  Elf64_Word sh_info;
  Elf64_Xword sh_addralign;
  Elf64_Xword sh_entsize;
} Elf64_Shdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/sym.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_SYM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Sym {
  Elf64_Word st_name;
  /* ELF64_ST_TYPE(st_info) → STT_{NOTYPE,OBJECT,FUNC,SECTION,FILE,COMMON,...}
   * ELF64_ST_BIND(st_info) → STB_{LOCAL,GLOBAL,WEAK,...} */
  uint8_t st_info;
  /* STV_{DEFAULT,INTERNAL,HIDDEN,PROTECTED} */
  uint8_t st_other;
  /* SHN_UNDEF, <section index>, SHN_ABS, SHN_COMMON, etc. */
  Elf64_Section st_shndx;
  Elf64_Addr st_value;
  Elf64_Xword st_size;
} Elf64_Sym;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § executable & linkable format                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

char *GetElfStringTable(const Elf64_Ehdr *, size_t);
Elf64_Sym *GetElfSymbolTable(const Elf64_Ehdr *, size_t, Elf64_Xword *);
bool IsElf64Binary(const Elf64_Ehdr *, size_t);
void CheckElfAddress(const Elf64_Ehdr *, size_t, intptr_t, size_t);
bool IsElfSymbolContent(const Elf64_Sym *);
Elf64_Phdr *GetElfSegmentHeaderAddress(const Elf64_Ehdr *, size_t, unsigned);
Elf64_Shdr *GetElfSectionHeaderAddress(const Elf64_Ehdr *, size_t, Elf64_Half);
void *GetElfSectionAddress(const Elf64_Ehdr *, size_t, const Elf64_Shdr *);
char *GetElfSectionNameStringTable(const Elf64_Ehdr *, size_t);
void GetElfVirtualAddressRange(const Elf64_Ehdr *, size_t, intptr_t *,
                               intptr_t *);
char *GetElfString(const Elf64_Ehdr *, size_t, const char *, Elf64_Word);
const char *GetElfSectionName(const Elf64_Ehdr *, size_t, Elf64_Shdr *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/auxv.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_AUXV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_auxv_t {
  uint64_t a_type;
  union {
    uint64_t a_val;
  } a_un;
} Elf64_auxv_t;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/chdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_CHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Chdr {
  Elf64_Word ch_type;
  Elf64_Word ch_reserved;
  Elf64_Xword ch_size;
  Elf64_Xword ch_addralign;
} Elf64_Chdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/dyn.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_DYN_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Dyn {
  Elf64_Sxword d_tag;
  union {
    Elf64_Xword d_val;
    Elf64_Addr d_ptr;
  } d_un;
} Elf64_Dyn;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/lib.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_LIB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Lib {
  Elf64_Word l_name;
  Elf64_Word l_time_stamp;
  Elf64_Word l_checksum;
  Elf64_Word l_version;
  Elf64_Word l_flags;
} Elf64_Lib;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/move.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_MOVE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Move {
  Elf64_Xword m_value;
  Elf64_Xword m_info;
  Elf64_Xword m_poffset;
  Elf64_Half m_repeat;
  Elf64_Half m_stride;
} Elf64_Move;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/nhdr.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_NHDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Nhdr {
  Elf64_Word n_namesz;
  Elf64_Word n_descsz;
  Elf64_Word n_type;
} Elf64_Nhdr;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/rela.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_RELA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Rela {
  /*u64*/ Elf64_Addr r_offset;
  /*
   * ELF64_R_SYM(r_info) → sym
   * ELF64_R_TYPE(r_info) → R_X86_64_{64,PC32,GOTPCRELX,...}
   * ELF64_R_INFO(sym, type) → r_info
   */
  /*u64*/ Elf64_Xword r_info; /* ELF64_R_{SYM,SIZE,INFO} */
  /*i64*/ Elf64_Sxword r_addend;
} Elf64_Rela;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/rel.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_REL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Rel {
  Elf64_Addr r_offset;
  Elf64_Xword r_info; /** @see ELF64_R_{SYM,SIZE,INFO} */
} Elf64_Rel;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/syminfo.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_SYMINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Syminfo {
  Elf64_Half si_boundto;
  Elf64_Half si_flags;
} Elf64_Syminfo;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/verdaux.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_VERDAUX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Verdaux {
  Elf64_Word vda_name;
  Elf64_Word vda_next;
} Elf64_Verdaux;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/verdef.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_VERDEF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Verdef {
  Elf64_Half vd_version;
  Elf64_Half vd_flags;
  Elf64_Half vd_ndx;
  Elf64_Half vd_cnt;
  Elf64_Word vd_hash;
  Elf64_Word vd_aux;
  Elf64_Word vd_next;
} Elf64_Verdef;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/vernaux.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_VERNAUX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Vernaux {
  Elf64_Word vna_hash;
  Elf64_Half vna_flags;
  Elf64_Half vna_other;
  Elf64_Word vna_name;
  Elf64_Word vna_next;
} Elf64_Vernaux;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/elf/struct/verneed.h */

#define COSMOPOLITAN_LIBC_ELF_STRUCT_VERNEED_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef struct Elf64_Verneed {
  Elf64_Half vn_version;
  Elf64_Half vn_cnt;
  Elf64_Word vn_file;
  Elf64_Word vn_aux;
  Elf64_Word vn_next;
} Elf64_Verneed;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/conv.h */

#define COSMOPOLITAN_LIBC_FMT_CONV_H_


/*!BEGIN libc/nt/struct/filetime.h */

#define COSMOPOLITAN_LIBC_NT_FILETIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileTime {
  uint32_t dwLowDateTime;
  uint32_t dwHighDateTime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion                                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define MODERNITYSECONDS 11644473600ull
#define HECTONANOSECONDS 10000000ull

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int abs(int) libcesque pureconst;
long labs(long) libcesque pureconst;
long long llabs(long long) libcesque pureconst;
int llog10(unsigned long) libcesque pureconst;
int atoi(const char *) paramsnonnull() libcesque;
long atol(const char *) paramsnonnull() libcesque;
long long atoll(const char *) paramsnonnull() libcesque;
unsigned long strtoul(const char *, char **, int) paramsnonnull((1));
long long strtoll(const char *, char **, int) paramsnonnull((1));
unsigned long long strtoull(const char *, char **, int) paramsnonnull((1));
long long strtonum(const char *, long long, long long, const char **);
intmax_t div10(intmax_t, unsigned *) hidden;
intmax_t strtoimax(const char *, char **, int) paramsnonnull((1));
uintmax_t strtoumax(const char *, char **, int) paramsnonnull((1));
intmax_t wcstoimax(const wchar_t *, wchar_t **, int);
long wcstol(const wchar_t *, wchar_t **, int);
long strtol(const char *, char **, int) paramsnonnull((1)) libcesque;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion » time                                         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int64_t DosDateTimeToUnix(unsigned, unsigned);
struct timespec FileTimeToTimeSpec(struct NtFileTime);
struct NtFileTime TimeSpecToFileTime(struct timespec);
struct NtFileTime TimeToFileTime(int64_t) nothrow pureconst;
int64_t filetimetotime(struct NtFileTime) nothrow pureconst;
void FileTimeToTimeVal(struct timeval *, struct NtFileTime) nothrow;
struct NtFileTime TimeValToFileTime(const struct timeval *) nosideeffect;
long convertmicros(const struct timeval *, long) paramsnonnull() nosideeffect;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion » manipulation                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

char *dirname(char *);
char *basename(const char *) nosideeffect;
char *basename_n(const char *, size_t) nosideeffect;
bool isabspath(const char *) paramsnonnull() nosideeffect;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion » computation                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef struct {
  int quot;
  int rem;
} div_t;

typedef struct {
  long int quot;
  long int rem;
} ldiv_t;

typedef struct {
  long long int quot;
  long long int rem;
} lldiv_t;

typedef struct {
  intmax_t quot;
  intmax_t rem;
} imaxdiv_t;

div_t div(int, int) pureconst;
ldiv_t ldiv(long, long) pureconst;
lldiv_t lldiv(long long, long long) pureconst;
imaxdiv_t imaxdiv(intmax_t, intmax_t) pureconst;
double RoundDecimalPlaces(double, double, double (*)(double));

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § conversion » optimizations                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if __STDC_VERSION__ + 0 >= 199901L
#define div(num, den)   ((div_t){(num) / (den), (num) % (den)})
#define ldiv(num, den)  ((ldiv_t){(num) / (den), (num) % (den)})
#define lldiv(num, den) ((lldiv_t){(num) / (den), (num) % (den)})
#endif

#ifndef __STRICT_ANSI__
intmax_t __imaxabs(intmax_t) libcesque pureconst;
#define imaxabs(x) __imaxabs(x)
#endif /* !ANSI */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/fmt.h */

#define COSMOPOLITAN_LIBC_FMT_FMT_H_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § string formatting                                         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if __SIZEOF_POINTER__ == 8
#define POINTER_XDIGITS 12 /* math.log(2**48-1,16) */
#else
#define POINTER_XDIGITS 8
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int snprintf(char *, size_t, const char *, ...) printfesque(3)
    paramsnonnull((3)) nothrow nocallback;
int vsnprintf(char *, size_t, const char *, va_list)
    paramsnonnull((3)) nothrow nocallback;
int sprintf(char *, const char *, ...) printfesque(2)
    paramsnonnull((2)) nothrow nocallback frownedupon(snprintf);
int vsprintf(char *, const char *, va_list)
    paramsnonnull((2)) nothrow nocallback frownedupon(vsnprintf);
int sscanf(const char *, const char *, ...) scanfesque(2);
int vsscanf(const char *, const char *, va_list);
int vcscanf(int (*)(void *), int (*)(int, void *), void *, const char *,
            va_list);
int strerror_r(int, char *, size_t) nothrow nocallback;
int palandprintf(void *, void *, const char *, va_list) hidden;
char *itoa(int, char *, int) compatfn;
char *fcvt(double, int, int *, int *);
char *ecvt(double, int, int *, int *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § string formatting » optimizations                         ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define sprintf(BUF, FMT, ...)        (sprintf)(BUF, PFLINK(FMT), ##__VA_ARGS__)
#define vsprintf(BUF, FMT, VA)        (vsprintf)(BUF, PFLINK(FMT), VA)
#define snprintf(B, Z, F, ...)        (snprintf)(B, Z, PFLINK(F), ##__VA_ARGS__)
#define vsnprintf(BUF, SIZE, FMT, VA) (vsnprintf)(BUF, SIZE, PFLINK(FMT), VA)
#define sscanf(STR, FMT, ...)         (sscanf)(STR, SFLINK(FMT), ##__VA_ARGS__)
#define vsscanf(STR, FMT, VA)         (vsscanf)(STR, SFLINK(FMT), VA)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/itoa.h */

#define COSMOPOLITAN_LIBC_FMT_ITOA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § integer conversion                                        ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  FASTEST + TINY

  - uint64toarray_radix10(0x31337, a)         l: 68 (20ns) m: 112 (33ns)
  - int64toarray_radix10(0x31337, a)          l: 69 (20ns) m: 134 (39ns)

  FAST + AWESOME

  - snprintf(a, sizeof(a), "%d", 0x31337)     l: 199 (58ns) m: 421 (123ns)
  - uint128toarray_radix10(0x31337, a)        l: 93 (27ns) m: 141 (41ns)
  - int128toarray_radix10(0x31337, a)         l: 96 (28ns) m: 173 (51ns) */

size_t int64toarray_radix10(int64_t, char[hasatleast 21]);
size_t uint64toarray_radix10(uint64_t, char[hasatleast 21]);
size_t uint64toarray_radix16(uint64_t, char[hasatleast 17]);
size_t uint64toarray_fixed16(uint64_t, char[hasatleast 17], uint8_t);
size_t uint64toarray_radix8(uint64_t, char[hasatleast 24]);

#ifndef __STRICT_ANSI__
size_t int128toarray_radix10(int128_t, char *);
size_t uint128toarray_radix10(uint128_t, char *);
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/leb128.h */

#define COSMOPOLITAN_LIBC_FMT_LEB128_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#ifndef __STRICT_ANSI__
int sleb128(const void *, size_t, int128_t);
int unsleb128(const void *, size_t, int128_t *);
#endif /* ANSI */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/fmt/palandprintf.h */

#define COSMOPOLITAN_LIBC_FMT_PALANDPRINTF_H_

#define PRINTF_NTOA_BUFFER_SIZE 144
#define PRINTF_FTOA_BUFFER_SIZE 64

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int spacepad(int (*)(long, void *), void *, unsigned long) hidden;
int ftoa(int (*)(long, void *), void *, long double, int, unsigned long,
         unsigned long) hidden;
int stoa(int (*)(long, void *), void *, void *, unsigned long, unsigned long,
         unsigned long, unsigned char, unsigned char) hidden;
int ntoa(int (*)(long, void *), void *, va_list, unsigned char, unsigned long,
         unsigned long, unsigned long, unsigned char, const char *) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/macros.h */

#define COSMOPOLITAN_LIBC_INTRIN_MACROS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define INTRIN_COMMUTATIVE "%"
#define INTRIN_NONCOMMUTATIVE

#if defined(__x86_64__) && !defined(__STRICT_ANSI__)

typedef char __intrin_xmm_t _Vector_size(16) forcealign(16) mayalias;

#define INTRIN_SSEVEX_X_X_X_(PURE, ISA, OP, FLAGS, A, B, C)                    \
  do {                                                                         \
    if (!IsModeDbg() && X86_HAVE(ISA)) {                                       \
      __intrin_xmm_t *Xmm0 = (void *)(A);                                      \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);                \
      const __intrin_xmm_t *Xmm2 = (const __intrin_xmm_t *)(C);                \
      if (!X86_NEED(AVX)) {                                                    \
        asm(OP "\t%1,%0" : "=x"(*Xmm0) : FLAGS "x"(*Xmm2), "0"(*Xmm1));        \
      } else {                                                                 \
        asm("v" OP "\t%2,%1,%0" : "=x"(*Xmm0) : FLAGS "x"(*Xmm1), "x"(*Xmm2)); \
      }                                                                        \
    } else {                                                                   \
      PURE(A, B, C);                                                           \
    }                                                                          \
  } while (0)

#define INTRIN_SSEVEX_X_X_I_(PURE, ISA, OP, A, B, I)                 \
  do {                                                               \
    if (!IsModeDbg() && X86_HAVE(ISA)) {                             \
      __intrin_xmm_t *Xmm0 = (void *)(A);                            \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);      \
      if (!X86_NEED(AVX)) {                                          \
        asm(OP "\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I));     \
      } else {                                                       \
        asm("v" OP "\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I)); \
      }                                                              \
    } else {                                                         \
      PURE(A, B, I);                                                 \
    }                                                                \
  } while (0)

#define INTRIN_SSEVEX_X_X_(PURE, ISA, OP, A, B)                 \
  do {                                                          \
    if (!IsModeDbg() && X86_HAVE(ISA)) {                        \
      __intrin_xmm_t *Xmm0 = (void *)(A);                       \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B); \
      if (!X86_NEED(AVX)) {                                     \
        asm(OP "\t%1,%0" : "=x"(*Xmm0) : "0"(*Xmm1));           \
      } else {                                                  \
        asm("v" OP "\t%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1));       \
      }                                                         \
    } else {                                                    \
      PURE(A, B);                                               \
    }                                                           \
  } while (0)

#define INTRIN_SSEVEX_X_I_(PURE, ISA, OP, A, B, I)                   \
  do {                                                               \
    if (!IsModeDbg() && X86_HAVE(ISA)) {                             \
      __intrin_xmm_t *Xmm0 = (void *)(A);                            \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);      \
      if (!X86_NEED(AVX)) {                                          \
        asm(OP "\t%1,%0" : "=x"(*Xmm0) : "i"(I), "0"(*Xmm1));        \
      } else {                                                       \
        asm("v" OP "\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I)); \
      }                                                              \
    } else {                                                         \
      PURE(A, B, I);                                                 \
    }                                                                \
  } while (0)

#else
#define INTRIN_SSEVEX_X_X_X_(PURE, ISA, OP, FLAGS, A, B, C) PURE(A, B, C)
#define INTRIN_SSEVEX_X_X_I_(PURE, ISA, OP, A, B, I)        PURE(A, B, I)
#define INTRIN_SSEVEX_X_I_(PURE, ISA, OP, A, B, I)          PURE(A, B, I)
#endif /* X86 && !ANSI */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/mpsadbw.h */

#define COSMOPOLITAN_LIBC_INTRIN_MPSADBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void mpsadbw(uint16_t[8], const uint8_t[16], const uint8_t[16], uint8_t);

#ifndef __STRICT_ANSI__
__intrin_xmm_t __mpsadbws(__intrin_xmm_t, __intrin_xmm_t);
#define mpsadbw(C, B, A, I)                                                   \
  do {                                                                        \
    if (__builtin_expect(!IsModeDbg() && X86_NEED(SSE) && X86_HAVE(SSE4_1),   \
                         1)) {                                                \
      __intrin_xmm_t *Xmm0 = (void *)(C);                                     \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);               \
      const __intrin_xmm_t *Xmm2 = (const __intrin_xmm_t *)(A);               \
      if (__builtin_constant_p(I)) {                                          \
        if (!X86_NEED(AVX)) {                                                 \
          asm("mpsadbw\t%2,%1,%0"                                             \
              : "=x"(*Xmm0)                                                   \
              : "x"(*Xmm2), "i"(I), "0"(*Xmm1));                              \
        } else {                                                              \
          asm("vmpsadbw\t%3,%2,%1,%0"                                         \
              : "=x"(*Xmm0)                                                   \
              : "x"(*Xmm1), "x"(*Xmm2), "i"(I));                              \
        }                                                                     \
      } else {                                                                \
        unsigned long Vimm = (I);                                             \
        typeof(__mpsadbws) *Fn;                                               \
        Fn = (typeof(__mpsadbws) *)((uintptr_t)&__mpsadbws + (Vimm & 7) * 8); \
        *Xmm0 = Fn(*Xmm1, *Xmm2);                                             \
      }                                                                       \
    } else {                                                                  \
      mpsadbw(C, B, A, I);                                                    \
    }                                                                         \
  } while (0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pabsb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PABSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pabsb(uint8_t[16], const int8_t[16]);

#define pabsb(A, B) INTRIN_SSEVEX_X_X_(pabsb, SSSE3, "pabsb", A, B)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pabsd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PABSD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pabsd(uint32_t[4], const int32_t[4]);

#define pabsd(A, B) INTRIN_SSEVEX_X_X_(pabsd, SSSE3, "pabsd", A, B)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pabsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PABSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pabsw(uint16_t[8], const int16_t[8]);

#define pabsw(A, B) INTRIN_SSEVEX_X_X_(pabsw, SSSE3, "pabsw", A, B)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/packssdw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PACKSSDW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void packssdw(int16_t[8], const int32_t[4], const int32_t[4]);

#define packssdw(A, B, C)                                                    \
  INTRIN_SSEVEX_X_X_X_(packssdw, SSE2, "packssdw", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/packsswb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PACKSSWB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void packsswb(int8_t[16], const int16_t[8], const int16_t[8]);

#define packsswb(A, B, C)                                                    \
  INTRIN_SSEVEX_X_X_X_(packsswb, SSE2, "packsswb", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/packusdw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PACKUSDW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void packusdw(uint16_t[8], const int32_t[4], const int32_t[4]);

#define packusdw(A, B, C)                                                      \
  INTRIN_SSEVEX_X_X_X_(packusdw, SSE4_1, "packusdw", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/packuswb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PACKUSWB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void packuswb(uint8_t[16], const int16_t[8], const int16_t[8]);

#define packuswb(A, B, C)                                                    \
  INTRIN_SSEVEX_X_X_X_(packuswb, SSE2, "packuswb", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddb(int8_t[16], const int8_t[16], const int8_t[16]);

#define paddb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddb, SSE2, "paddb", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddd(int32_t[4], const int32_t[4], const int32_t[4]);

#define paddd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddd, SSE2, "paddd", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddq(int64_t[2], const int64_t[2], const int64_t[2]);

#define paddq(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddq, SSE2, "paddq", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddsb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddsb(int8_t[16], const int8_t[16], const int8_t[16]);

#define paddsb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddsb, SSE2, "paddsb", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define paddsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddsw, SSE2, "paddsw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddusb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDUSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddusb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define paddusb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddusb, SSE2, "paddusb", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddusw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDUSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddusw(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define paddusw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddusw, SSE2, "paddusw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/paddw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PADDW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void paddw(int16_t[8], const int16_t[8], const int16_t[8]);

#define paddw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(paddw, SSE2, "paddw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/palignr.h */

#define COSMOPOLITAN_LIBC_INTRIN_PALIGNR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void palignr(void *, const void *, const void *, unsigned long);

#if !defined(__STRICT_ANSI__) && !defined(__chibicc__)
__intrin_xmm_t __palignrs(__intrin_xmm_t, __intrin_xmm_t);
#define palignr(C, B, A, I)                                                \
  do {                                                                     \
    if (__builtin_expect(!IsModeDbg() && X86_NEED(SSE) && X86_HAVE(SSSE3), \
                         1)) {                                             \
      __intrin_xmm_t *Xmm0 = (void *)(C);                                  \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(B);            \
      const __intrin_xmm_t *Xmm2 = (const __intrin_xmm_t *)(A);            \
      if (__builtin_constant_p(I)) {                                       \
        if (!X86_NEED(AVX)) {                                              \
          asm("palignr\t%2,%1,%0"                                          \
              : "=x"(*Xmm0)                                                \
              : "x"(*Xmm2), "i"(I), "0"(*Xmm1));                           \
        } else {                                                           \
          asm("vpalignr\t%3,%2,%1,%0"                                      \
              : "=x"(*Xmm0)                                                \
              : "x"(*Xmm1), "x"(*Xmm2), "i"(I));                           \
        }                                                                  \
      } else {                                                             \
        unsigned long Vimm = (I);                                          \
        typeof(__palignrs) *Fn;                                            \
        if (__builtin_expect(Vimm < 32, 1)) {                              \
          Fn = (typeof(__palignrs) *)((uintptr_t)&__palignrs + Vimm * 8);  \
          *Xmm0 = Fn(*Xmm1, *Xmm2);                                        \
        } else {                                                           \
          memset(Xmm0, 0, 16);                                             \
        }                                                                  \
      }                                                                    \
    } else {                                                               \
      palignr(C, B, A, I);                                                 \
    }                                                                      \
  } while (0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pand.h */

#define COSMOPOLITAN_LIBC_INTRIN_PAND_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pand(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define pand(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pand, SSE2, "pand", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pandn.h */

#define COSMOPOLITAN_LIBC_INTRIN_PANDN_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pandn(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define pandn(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pandn, SSE2, "pandn", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pavgb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PAVGB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pavgb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define pavgb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pavgb, SSE2, "pavgb", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pavgw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PAVGW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pavgw(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define pavgw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pavgw, SSE2, "pavgw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpeqb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPEQB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpeqb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define pcmpeqb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpeqb, SSE2, "pcmpeqb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpeqd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPEQD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpeqd(int32_t[4], const int32_t[4], const int32_t[4]);

#define pcmpeqd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpeqd, SSE2, "pcmpeqd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpeqw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPEQW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpeqw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pcmpeqw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpeqw, SSE2, "pcmpeqw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpgtb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPGTB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpgtb(int8_t[16], const int8_t[16], const int8_t[16]);

#define pcmpgtb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpgtb, SSE2, "pcmpgtb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpgtd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPGTD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpgtd(int32_t[4], const int32_t[4], const int32_t[4]);

#define pcmpgtd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpgtd, SSE2, "pcmpgtd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pcmpgtw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PCMPGTW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pcmpgtw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pcmpgtw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pcmpgtw, SSE2, "pcmpgtw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phaddd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHADDD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phaddd(int32_t[4], const int32_t[4], const int32_t[4]);

#define phaddd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(phaddd, SSSE3, "phaddd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phaddsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHADDSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phaddsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define phaddsw(A, B, C)                                                       \
  INTRIN_SSEVEX_X_X_X_(phaddsw, SSSE3, "phaddsw", INTRIN_NONCOMMUTATIVE, A, B, \
                       C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phaddw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHADDW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phaddw(int16_t[8], const int16_t[8], const int16_t[8]);

#define phaddw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(phaddw, SSSE3, "phaddw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phsubd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHSUBD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phsubd(int32_t[4], const int32_t[4], const int32_t[4]);

#define phsubd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(phsubd, SSSE3, "phsubd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phsubsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHSUBSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phsubsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define phsubsw(A, B, C)                                                       \
  INTRIN_SSEVEX_X_X_X_(phsubsw, SSSE3, "phsubsw", INTRIN_NONCOMMUTATIVE, A, B, \
                       C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/phsubw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PHSUBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void phsubw(int16_t[8], const int16_t[8], const int16_t[8]);

#define phsubw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(phsubw, SSSE3, "phsubw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmaddubsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMADDUBSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmaddubsw(int16_t[8], const uint8_t[16], const int8_t[16]);

#define pmaddubsw(W, B, C)                                                   \
  INTRIN_SSEVEX_X_X_X_(pmaddubsw, SSSE3, "pmaddubsw", INTRIN_NONCOMMUTATIVE, \
                       W, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmaddwd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMADDWD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmaddwd(int32_t[4], const int16_t[8], const int16_t[8]);

#define pmaddwd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmaddwd, SSE2, "pmaddwd", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmaxsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMAXSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmaxsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pmaxsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmaxsw, SSE2, "pmaxsw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmaxub.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMAXUB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmaxub(unsigned char[16], const unsigned char[16],
            const unsigned char[16]);

#define pmaxub(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmaxub, SSE2, "pmaxub", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pminsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMINSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pminsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pminsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pminsw, SSE2, "pminsw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pminub.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMINUB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pminub(unsigned char[16], const unsigned char[16],
            const unsigned char[16]);

#define pminub(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pminub, SSE2, "pminub", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmovmskb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMOVMSKB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint32_t pmovmskb(const uint8_t[16]);

#define pmovmskb(A)                                            \
  ({                                                           \
    uint32_t Mask;                                             \
    if (!IsModeDbg() && X86_HAVE(SSE2)) {                      \
      const __intrin_xmm_t *Xmm = (const __intrin_xmm_t *)(A); \
      if (!X86_NEED(AVX)) {                                    \
        asm("pmovmskb\t%1,%0" : "=r"(Mask) : "x"(*Xmm));       \
      } else {                                                 \
        asm("vpmovmskb\t%1,%0" : "=r"(Mask) : "x"(*Xmm));      \
      }                                                        \
    } else {                                                   \
      Mask = pmovmskb(A);                                      \
    }                                                          \
    Mask;                                                      \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmulhrsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULHRSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmulhrsw(int16_t a[8], const int16_t b[8], const int16_t c[8]);

#define pmulhrsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmulhrsw, SSSE3, "pmulhrsw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmulhuw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULHUW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmulhuw(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define pmulhuw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmulhuw, SSE2, "pmulhuw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmulhw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULHW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmulhw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pmulhw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmulhw, SSE2, "pmulhw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmulld.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULLD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmulld(int32_t[4], const int32_t[4], const int32_t[4]);

#define pmulld(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmulld, SSE4_1, "pmulld", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmullw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULLW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmullw(int16_t[8], const int16_t[8], const int16_t[8]);

#define pmullw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmullw, SSE2, "pmullw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pmuludq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PMULUDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pmuludq(uint64_t[2], const uint32_t[4], const uint32_t[4]);

#define pmuludq(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pmuludq, SSE2, "pmuludq", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/por.h */

#define COSMOPOLITAN_LIBC_INTRIN_POR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void por(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define por(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(por, SSE2, "por", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psadbw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSADBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psadbw(uint64_t[2], const uint8_t[16], const uint8_t[16]);

#define psadbw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psadbw, SSE2, "psadbw", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshufb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshufb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define pshufb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pshufb, SSSE3, "pshufb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshufd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshufd(int32_t[4], const int32_t[4], uint8_t);

#define pshufd(A, B, I) INTRIN_SSEVEX_X_X_I_(pshufd, SSE2, "pshufd", A, B, I)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshufhw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFHW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshufhw(int16_t[8], const int16_t[8], uint8_t);

#define pshufhw(A, B, I) INTRIN_SSEVEX_X_X_I_(pshufhw, SSE2, "pshufhw", A, B, I)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshuflw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFLW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshuflw(int16_t[8], const int16_t[8], uint8_t);

#define pshuflw(A, B, I) INTRIN_SSEVEX_X_X_I_(pshuflw, SSE2, "pshuflw", A, B, I)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pshufw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSHUFW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pshufw(int16_t[4], const int16_t[4], uint8_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psignb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSIGNB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psignb(int8_t[16], const int8_t[16], const int8_t[16]);

#define psignb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psignb, SSSE3, "psignb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psignd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSIGND_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psignd(int32_t[4], const int32_t[4], const int32_t[4]);

#define psignd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psignd, SSSE3, "psignd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psignw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSIGNW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psignw(int16_t[8], const int16_t[8], const int16_t[8]);

#define psignw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psignw, SSSE3, "psignw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pslld.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSLLD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pslld(uint32_t[4], const uint32_t[4], unsigned char);
void pslldv(uint32_t[4], const uint32_t[4], const uint64_t[2]);

#define pslld(A, B, I) INTRIN_SSEVEX_X_I_(pslld, SSE2, "pslld", A, B, I)
#define pslldv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pslldv, SSE2, "pslld", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pslldq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSLLDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pslldq(uint8_t[16], const uint8_t[16], unsigned long);

#ifndef __STRICT_ANSI__
__intrin_xmm_t __pslldqs(__intrin_xmm_t);
#define pslldq(B, A, I)                                                   \
  do {                                                                    \
    if (__builtin_expect(!IsModeDbg() && X86_NEED(SSE) && X86_HAVE(SSE2), \
                         1)) {                                            \
      __intrin_xmm_t *Xmm0 = (void *)(B);                                 \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(A);           \
      if (__builtin_constant_p(I)) {                                      \
        if (!X86_NEED(AVX)) {                                             \
          asm("pslldq\t%1,%0" : "=x"(*Xmm0) : "i"(I), "0"(*Xmm1));        \
        } else {                                                          \
          asm("vpslldq\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I));    \
        }                                                                 \
      } else {                                                            \
        unsigned long Vimm = (I);                                         \
        typeof(__pslldqs) *Fn;                                            \
        if (Vimm > 16) Vimm = 16;                                         \
        Fn = (typeof(__pslldqs) *)((uintptr_t)&__pslldqs + Vimm * 8);     \
        *Xmm0 = Fn(*Xmm1);                                                \
      }                                                                   \
    } else {                                                              \
      pslldq(B, A, I);                                                    \
    }                                                                     \
  } while (0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psllq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSLLQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psllq(uint64_t[2], const uint64_t[2], unsigned char);
void psllqv(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define psllq(A, B, I) INTRIN_SSEVEX_X_I_(psllq, SSE2, "psllq", A, B, I)
#define psllqv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psllqv, SSE2, "psllq", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psllw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSLLW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psllw(uint16_t[8], const uint16_t[8], unsigned char);
void psllwv(uint16_t[8], const uint16_t[8], const uint64_t[2]);

#define psllw(A, B, I) INTRIN_SSEVEX_X_I_(psllw, SSE2, "psllw", A, B, I)
#define psllwv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psllwv, SSE2, "psllw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrad.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRAD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrad(int32_t[4], const int32_t[4], unsigned char);
void psradv(int32_t[4], const int32_t[4], const uint64_t[2]);

#define psrad(A, B, I) INTRIN_SSEVEX_X_I_(psrad, SSE2, "psrad", A, B, I)
#define psradv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psradv, SSE2, "psrad", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psraw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRAW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psraw(int16_t[8], const int16_t[8], unsigned char);
void psrawv(int16_t[8], const int16_t[8], const uint64_t[2]);

#define psraw(A, B, I) INTRIN_SSEVEX_X_I_(psraw, SSE2, "psraw", A, B, I)
#define psrawv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psrawv, SSE2, "psraw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrld.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRLD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrld(uint32_t[4], const uint32_t[4], unsigned char);
void psrldv(uint32_t[4], const uint32_t[4], const uint64_t[2]);

#define psrld(A, B, I) INTRIN_SSEVEX_X_I_(psrld, SSE2, "psrld", A, B, I)
#define psrldv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psrldv, SSE2, "psrld", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrldq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRLDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrldq(uint8_t[16], const uint8_t[16], unsigned long);

#ifndef __STRICT_ANSI__
__intrin_xmm_t __psrldqs(__intrin_xmm_t);
#define psrldq(B, A, I)                                                   \
  do {                                                                    \
    if (__builtin_expect(!IsModeDbg() && X86_NEED(SSE) && X86_HAVE(SSE2), \
                         1)) {                                            \
      __intrin_xmm_t *Xmm0 = (void *)(B);                                 \
      const __intrin_xmm_t *Xmm1 = (const __intrin_xmm_t *)(A);           \
      if (__builtin_constant_p(I)) {                                      \
        if (!X86_NEED(AVX)) {                                             \
          asm("psrldq\t%1,%0" : "=x"(*Xmm0) : "i"(I), "0"(*Xmm1));        \
        } else {                                                          \
          asm("vpsrldq\t%2,%1,%0" : "=x"(*Xmm0) : "x"(*Xmm1), "i"(I));    \
        }                                                                 \
      } else {                                                            \
        unsigned long Vimm = (I);                                         \
        typeof(__psrldqs) *Fn;                                            \
        if (Vimm > 16) Vimm = 16;                                         \
        Fn = (typeof(__psrldqs) *)((uintptr_t)&__psrldqs + Vimm * 8);     \
        *Xmm0 = Fn(*Xmm1);                                                \
      }                                                                   \
    } else {                                                              \
      psrldq(B, A, I);                                                    \
    }                                                                     \
  } while (0)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrlq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRLQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrlq(uint64_t[2], const uint64_t[2], unsigned char);
void psrlqv(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define psrlq(A, B, I) INTRIN_SSEVEX_X_I_(psrlq, SSE2, "psrlq", A, B, I)
#define psrlqv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psrlqv, SSE2, "psrlq", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psrlw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSRLW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psrlw(uint16_t[8], const uint16_t[8], unsigned char);
void psrlwv(uint16_t[8], const uint16_t[8], const uint64_t[2]);

#define psrlw(A, B, I) INTRIN_SSEVEX_X_I_(psrlw, SSE2, "psrlw", A, B, I)
#define psrlwv(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psrlwv, SSE2, "psrlw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define psubb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubb, SSE2, "psubb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubd(int32_t[4], const int32_t[4], const int32_t[4]);

#define psubd(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubd, SSE2, "psubd", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubq(int64_t[2], const int64_t[2], const int64_t[2]);

#define psubq(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubq, SSE2, "psubq", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubsb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubsb(int8_t[16], const int8_t[16], const int8_t[16]);

#define psubsb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubsb, SSE2, "psubsb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubsw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubsw(int16_t[8], const int16_t[8], const int16_t[8]);

#define psubsw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubsw, SSE2, "psubsw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubusb.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBUSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubusb(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define psubusb(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubusb, SSE2, "psubusb", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubusw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBUSW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void psubusw(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define psubusw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubusw, SSE2, "psubusw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/psubw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PSUBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void(psubw)(int16_t[8], const int16_t[8], const int16_t[8]);

#define psubw(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(psubw, SSE2, "psubw", INTRIN_NONCOMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckhbw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKHBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckhbw(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define punpckhbw(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpckhbw, SSE2, "punpckhbw", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckhdq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKHDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckhdq(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define punpckhdq(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpckhdq, SSE2, "punpckhdq", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckhqdq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKHQDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckhqdq(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define punpckhqdq(A, B, C)                                                   \
  INTRIN_SSEVEX_X_X_X_(punpckhqdq, SSE2, "punpckhqdq", INTRIN_NONCOMMUTATIVE, \
                       A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckhwd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKHWD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckhwd(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define punpckhwd(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpckhwd, SSE2, "punpckhwd", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpcklbw.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKLBW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpcklbw(uint8_t[16], const uint8_t[16], const uint8_t[16]);

#define punpcklbw(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpcklbw, SSE2, "punpcklbw", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpckldq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKLDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpckldq(uint32_t[4], const uint32_t[4], const uint32_t[4]);

#define punpckldq(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpckldq, SSE2, "punpckldq", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpcklqdq.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKLQDQ_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpcklqdq(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define punpcklqdq(A, B, C)                                                   \
  INTRIN_SSEVEX_X_X_X_(punpcklqdq, SSE2, "punpcklqdq", INTRIN_NONCOMMUTATIVE, \
                       A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/punpcklwd.h */

#define COSMOPOLITAN_LIBC_INTRIN_PUNPCKLWD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void punpcklwd(uint16_t[8], const uint16_t[8], const uint16_t[8]);

#define punpcklwd(A, B, C)                                                     \
  INTRIN_SSEVEX_X_X_X_(punpcklwd, SSE2, "punpcklwd", INTRIN_NONCOMMUTATIVE, A, \
                       B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/pxor.h */

#define COSMOPOLITAN_LIBC_INTRIN_PXOR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void pxor(uint64_t[2], const uint64_t[2], const uint64_t[2]);

#define pxor(A, B, C) \
  INTRIN_SSEVEX_X_X_X_(pxor, SSE2, "pxor", INTRIN_COMMUTATIVE, A, B, C)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/repmovsb.h */

#define COSMOPOLITAN_LIBC_INTRIN_REPMOVSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

forceinline void repmovsb(void **dest, const void **src, size_t cx) {
  char *di = (char *)*dest;
  const char *si = (const char *)*src;
  while (cx) *di++ = *si++, cx--;
  *dest = di, *src = si;
}

#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define repmovsb(DI, SI, CX)                                       \
  ({                                                               \
    void *Di = *(DI);                                              \
    const void *Si = *(SI);                                        \
    size_t Cx = (CX);                                              \
    asm("rep movsb"                                                \
        : "=D"(Di), "=S"(Si), "=c"(Cx), "=m"(*(char(*)[Cx])Di)     \
        : "0"(Di), "1"(Si), "2"(Cx), "m"(*(const char(*)[Cx])Si)); \
    *(DI) = Di, *(SI) = Si;                                        \
  })
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/repstosb.h */

#define COSMOPOLITAN_LIBC_INTRIN_REPSTOSB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

forceinline void *repstosb(void *dest, unsigned char al, size_t cx) {
  unsigned char *di = (unsigned char *)dest;
  while (cx) *di++ = al, cx--;
  return di;
}

#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define repstosb(DI, AL, CX)                         \
  ({                                                 \
    void *Di = (DI);                                 \
    size_t Cx = (CX);                                \
    unsigned char Al = (AL);                         \
    asm("rep stosb %b5,(%0)"                         \
        : "=D"(Di), "=c"(Cx), "=m"(*(char(*)[Cx])Di) \
        : "0"(Di), "1"(Cx), "a"(Al));                \
    Di;                                              \
  })
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/shufpd.h */

#define COSMOPOLITAN_LIBC_INTRIN_SHUFPD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void shufpd(double[2], const double[2], const double[2], uint8_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/intrin/shufps.h */

#define COSMOPOLITAN_LIBC_INTRIN_SHUFPS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void shufps(float[4], const float[4], const float[4], uint8_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/bsd.h */

#define COSMOPOLITAN_LIBC_LOG_BSD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § logging » berkeley logger                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void err(int, const char *, ...) printfesque(2) wontreturn;
void errx(int, const char *, ...) printfesque(2) wontreturn;
void verr(int, const char *, va_list) paramsnonnull((3)) wontreturn;
void verrx(int, const char *, va_list) paramsnonnull((3)) wontreturn;
void vwarn(const char *, va_list) paramsnonnull((2));
void vwarnx(const char *, va_list) paramsnonnull((2));
void warn(const char *, ...) printfesque(1);
void warnx(const char *, ...) printfesque(1);

#define err(EVAL, FMT, ...)  (err)(EVAL, PFLINK(FMT), ##__VA_ARGS__)
#define errx(EVAL, FMT, ...) (errx)(EVAL, PFLINK(FMT), ##__VA_ARGS__)
#define verr(EVAL, FMT, VA)  (verr)(EVAL, PFLINK(FMT), VA)
#define verrx(EVAL, FMT, VA) (verrx)(EVAL, PFLINK(FMT), VA)
#define vwarn(FMT, VA)       (vwarn)(PFLINK(FMT), VA)
#define vwarnx(FMT, VA)      (vwarnx)(PFLINK(FMT), VA)
#define warn(FMT, ...)       (warn)(PFLINK(FMT), ##__VA_ARGS__)
#define warnx(FMT, ...)      (warn)(PFLINK(FMT), ##__VA_ARGS__)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/check.h */

#define COSMOPOLITAN_LIBC_LOG_CHECK_H_

/**
 * @fileoverview Modern assertions, courtesy of Elgoog.
 */

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define CHECK(X, ...)         __CHK(ne, !=, false, "false", !!(X), #X, "" __VA_ARGS__)
#define CHECK_EQ(Y, X, ...)   __CHK(eq, ==, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_NE(Y, X, ...)   __CHK(ne, !=, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_LE(Y, X, ...)   __CHK(le, <=, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_LT(Y, X, ...)   __CHK(lt, <, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_GE(Y, X, ...)   __CHK(ge, >=, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_GT(Y, X, ...)   __CHK(gt, >, Y, #Y, X, #X, "" __VA_ARGS__)
#define CHECK_NOTNULL(X, ...) __CHK(ne, !=, NULL, "NULL", X, #X, "" __VA_ARGS__)

#define DCHECK(X, ...)       __DCHK(ne, !=, false, "false", !!(X), #X, "" __VA_ARGS__)
#define DCHECK_EQ(Y, X, ...) __DCHK(eq, ==, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_NE(Y, X, ...) __DCHK(ne, !=, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_LE(Y, X, ...) __DCHK(le, <=, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_LT(Y, X, ...) __DCHK(lt, <, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_GE(Y, X, ...) __DCHK(ge, >=, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_GT(Y, X, ...) __DCHK(gt, >, Y, #Y, X, #X, "" __VA_ARGS__)
#define DCHECK_NOTNULL(X, ...) \
  __DCHK(ne, !=, NULL, "NULL", X, #X, "" __VA_ARGS__)

#define CHECK_ALIGNED(BYTES, VAR)                            \
  do {                                                       \
    if (((uintptr_t)VAR & ((BYTES)-1u))) {                   \
      __check_fail_aligned(BYTES, (uintptr_t)VAR);           \
      unreachable;                                           \
    }                                                        \
    VAR = (typeof(VAR))__builtin_assume_aligned(VAR, BYTES); \
  } while (0)

#define DCHECK_ALIGNED(BYTES, VAR)                           \
  do {                                                       \
    if (((uintptr_t)VAR & ((BYTES)-1u))) {                   \
      __DCHK_ALIGNED(BYTES, (uintptr_t)VAR);                 \
      unreachable;                                           \
    }                                                        \
    VAR = (typeof(VAR))__builtin_assume_aligned(VAR, BYTES); \
  } while (0)

#if defined(__VSCODE_INTELLISENSE__)
#define __CHK(...)
#else
#define __CHK(SUFFIX, OP, WANT, WANTSTR, GOT, GOTSTR, ...)                   \
  do {                                                                       \
    autotype(GOT) Got = (GOT);                                               \
    autotype(WANT) Want = (WANT);                                            \
    if (!(Want OP Got)) {                                                    \
      if (!NoDebug()) {                                                      \
        __check_fail(#SUFFIX, #OP, (uint64_t)Want, (WANTSTR), (uint64_t)Got, \
                     (GOTSTR), __FILE__, __LINE__, __VA_ARGS__);             \
      } else {                                                               \
        __check_fail_##SUFFIX((uint64_t)Want, (uint64_t)Got);                \
      }                                                                      \
      unreachable;                                                           \
    }                                                                        \
  } while (0)
#endif /* defined(__VSCODE_INTELLISENSE__) */

#if defined(__VSCODE_INTELLISENSE__)
#define __DCHK(...)
#else
#ifdef NDEBUG
#define __DCHK(SUFFIX, OP, WANT, WANTSTR, GOT, ...) \
  do {                                              \
    autotype(GOT) Got = (GOT);                      \
    autotype(WANT) Want = (WANT);                   \
    if (!(Want OP Got)) {                           \
      unreachable;                                  \
    }                                               \
  } while (0)
#else
#define __DCHK(SUFFIX, OP, WANT, WANTSTR, GOT, GOTSTR, ...) \
  __CHK(SUFFIX, OP, WANT, WANTSTR, GOT, GOTSTR, __VA_ARGS__)
#endif /* NDEBUG */
#endif /* defined(__VSCODE_INTELLISENSE__) */

#ifdef NDEBUG
#define __DCHK_ALIGNED(BYTES, VAR)
#else
#define __DCHK_ALIGNED(BYTES, VAR) __check_fail_aligned(BYTES, VAR)
#endif

void __check_fail(const char *, const char *, uint64_t, const char *, uint64_t,
                  const char *, const char *, int, const char *,
                  ...) relegated wontreturn;

void __check_fail_eq(uint64_t, uint64_t) relegated wontreturn;
void __check_fail_ne(uint64_t, uint64_t) relegated wontreturn;
void __check_fail_le(uint64_t, uint64_t) relegated wontreturn;
void __check_fail_lt(uint64_t, uint64_t) relegated wontreturn;
void __check_fail_ge(uint64_t, uint64_t) relegated wontreturn;
void __check_fail_gt(uint64_t, uint64_t) relegated wontreturn;
void __check_fail_aligned(unsigned, uint64_t) relegated wontreturn;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/gdb.h */

#define COSMOPOLITAN_LIBC_LOG_GDB_H_


/*!BEGIN libc/sysv/consts/nr.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_NR_H_

#define __NR_exit                    SYMBOLIC(__NR_exit)
#define __NR_exit_group              SYMBOLIC(__NR_exit_group)
#define __NR_read                    SYMBOLIC(__NR_read)
#define __NR_write                   SYMBOLIC(__NR_write)
#define __NR_open                    SYMBOLIC(__NR_open)
#define __NR_close                   SYMBOLIC(__NR_close)
#define __NR_stat                    SYMBOLIC(__NR_stat)
#define __NR_fstat                   SYMBOLIC(__NR_fstat)
#define __NR_lstat                   SYMBOLIC(__NR_lstat)
#define __NR_poll                    SYMBOLIC(__NR_poll)
#define __NR_ppoll                   SYMBOLIC(__NR_ppoll)
#define __NR_lseek                   SYMBOLIC(__NR_lseek)
#define __NR_mmap                    SYMBOLIC(__NR_mmap)
#define __NR_msync                   SYMBOLIC(__NR_msync)
#define __NR_mprotect                SYMBOLIC(__NR_mprotect)
#define __NR_munmap                  SYMBOLIC(__NR_munmap)
#define __NR_sigaction               SYMBOLIC(__NR_sigaction)
#define __NR_sigprocmask             SYMBOLIC(__NR_sigprocmask)
#define __NR_ioctl                   SYMBOLIC(__NR_ioctl)
#define __NR_pread                   SYMBOLIC(__NR_pread)
#define __NR_pwrite                  SYMBOLIC(__NR_pwrite)
#define __NR_readv                   SYMBOLIC(__NR_readv)
#define __NR_writev                  SYMBOLIC(__NR_writev)
#define __NR_access                  SYMBOLIC(__NR_access)
#define __NR_pipe                    SYMBOLIC(__NR_pipe)
#define __NR_select                  SYMBOLIC(__NR_select)
#define __NR_pselect                 SYMBOLIC(__NR_pselect)
#define __NR_pselect6                SYMBOLIC(__NR_pselect6)
#define __NR_sched_yield             SYMBOLIC(__NR_sched_yield)
#define __NR_mremap                  SYMBOLIC(__NR_mremap)
#define __NR_mincore                 SYMBOLIC(__NR_mincore)
#define __NR_madvise                 SYMBOLIC(__NR_madvise)
#define __NR_shmget                  SYMBOLIC(__NR_shmget)
#define __NR_shmat                   SYMBOLIC(__NR_shmat)
#define __NR_shmctl                  SYMBOLIC(__NR_shmctl)
#define __NR_dup                     SYMBOLIC(__NR_dup)
#define __NR_dup2                    SYMBOLIC(__NR_dup2)
#define __NR_pause                   SYMBOLIC(__NR_pause)
#define __NR_nanosleep               SYMBOLIC(__NR_nanosleep)
#define __NR_getitimer               SYMBOLIC(__NR_getitimer)
#define __NR_setitimer               SYMBOLIC(__NR_setitimer)
#define __NR_alarm                   SYMBOLIC(__NR_alarm)
#define __NR_getpid                  SYMBOLIC(__NR_getpid)
#define __NR_sendfile                SYMBOLIC(__NR_sendfile)
#define __NR_socket                  SYMBOLIC(__NR_socket)
#define __NR_connect                 SYMBOLIC(__NR_connect)
#define __NR_accept                  SYMBOLIC(__NR_accept)
#define __NR_sendto                  SYMBOLIC(__NR_sendto)
#define __NR_recvfrom                SYMBOLIC(__NR_recvfrom)
#define __NR_sendmsg                 SYMBOLIC(__NR_sendmsg)
#define __NR_recvmsg                 SYMBOLIC(__NR_recvmsg)
#define __NR_shutdown                SYMBOLIC(__NR_shutdown)
#define __NR_bind                    SYMBOLIC(__NR_bind)
#define __NR_listen                  SYMBOLIC(__NR_listen)
#define __NR_getsockname             SYMBOLIC(__NR_getsockname)
#define __NR_getpeername             SYMBOLIC(__NR_getpeername)
#define __NR_socketpair              SYMBOLIC(__NR_socketpair)
#define __NR_setsockopt              SYMBOLIC(__NR_setsockopt)
#define __NR_getsockopt              SYMBOLIC(__NR_getsockopt)
#define __NR_fork                    SYMBOLIC(__NR_fork)
#define __NR_vfork                   SYMBOLIC(__NR_vfork)
#define __NR_posix_spawn             SYMBOLIC(__NR_posix_spawn)
#define __NR_execve                  SYMBOLIC(__NR_execve)
#define __NR_wait4                   SYMBOLIC(__NR_wait4)
#define __NR_kill                    SYMBOLIC(__NR_kill)
#define __NR_killpg                  SYMBOLIC(__NR_killpg)
#define __NR_clone                   SYMBOLIC(__NR_clone)
#define __NR_tkill                   SYMBOLIC(__NR_tkill)
#define __NR_futex                   SYMBOLIC(__NR_futex)
#define __NR_set_robust_list         SYMBOLIC(__NR_set_robust_list)
#define __NR_get_robust_list         SYMBOLIC(__NR_get_robust_list)
#define __NR_uname                   SYMBOLIC(__NR_uname)
#define __NR_semget                  SYMBOLIC(__NR_semget)
#define __NR_semop                   SYMBOLIC(__NR_semop)
#define __NR_semctl                  SYMBOLIC(__NR_semctl)
#define __NR_shmdt                   SYMBOLIC(__NR_shmdt)
#define __NR_msgget                  SYMBOLIC(__NR_msgget)
#define __NR_msgsnd                  SYMBOLIC(__NR_msgsnd)
#define __NR_msgrcv                  SYMBOLIC(__NR_msgrcv)
#define __NR_msgctl                  SYMBOLIC(__NR_msgctl)
#define __NR_fcntl                   SYMBOLIC(__NR_fcntl)
#define __NR_flock                   SYMBOLIC(__NR_flock)
#define __NR_fsync                   SYMBOLIC(__NR_fsync)
#define __NR_fdatasync               SYMBOLIC(__NR_fdatasync)
#define __NR_truncate                SYMBOLIC(__NR_truncate)
#define __NR_ftruncate               SYMBOLIC(__NR_ftruncate)
#define __NR_getcwd                  SYMBOLIC(__NR_getcwd)
#define __NR_chdir                   SYMBOLIC(__NR_chdir)
#define __NR_fchdir                  SYMBOLIC(__NR_fchdir)
#define __NR_rename                  SYMBOLIC(__NR_rename)
#define __NR_mkdir                   SYMBOLIC(__NR_mkdir)
#define __NR_rmdir                   SYMBOLIC(__NR_rmdir)
#define __NR_creat                   SYMBOLIC(__NR_creat)
#define __NR_link                    SYMBOLIC(__NR_link)
#define __NR_unlink                  SYMBOLIC(__NR_unlink)
#define __NR_symlink                 SYMBOLIC(__NR_symlink)
#define __NR_readlink                SYMBOLIC(__NR_readlink)
#define __NR_chmod                   SYMBOLIC(__NR_chmod)
#define __NR_fchmod                  SYMBOLIC(__NR_fchmod)
#define __NR_chown                   SYMBOLIC(__NR_chown)
#define __NR_fchown                  SYMBOLIC(__NR_fchown)
#define __NR_lchown                  SYMBOLIC(__NR_lchown)
#define __NR_umask                   SYMBOLIC(__NR_umask)
#define __NR_gettimeofday            SYMBOLIC(__NR_gettimeofday)
#define __NR_getrlimit               SYMBOLIC(__NR_getrlimit)
#define __NR_getrusage               SYMBOLIC(__NR_getrusage)
#define __NR_sysinfo                 SYMBOLIC(__NR_sysinfo)
#define __NR_times                   SYMBOLIC(__NR_times)
#define __NR_ptrace                  SYMBOLIC(__NR_ptrace)
#define __NR_syslog                  SYMBOLIC(__NR_syslog)
#define __NR_getuid                  SYMBOLIC(__NR_getuid)
#define __NR_getgid                  SYMBOLIC(__NR_getgid)
#define __NR_getppid                 SYMBOLIC(__NR_getppid)
#define __NR_getpgrp                 SYMBOLIC(__NR_getpgrp)
#define __NR_setsid                  SYMBOLIC(__NR_setsid)
#define __NR_getsid                  SYMBOLIC(__NR_getsid)
#define __NR_getpgid                 SYMBOLIC(__NR_getpgid)
#define __NR_setpgid                 SYMBOLIC(__NR_setpgid)
#define __NR_geteuid                 SYMBOLIC(__NR_geteuid)
#define __NR_getegid                 SYMBOLIC(__NR_getegid)
#define __NR_getgroups               SYMBOLIC(__NR_getgroups)
#define __NR_setgroups               SYMBOLIC(__NR_setgroups)
#define __NR_setreuid                SYMBOLIC(__NR_setreuid)
#define __NR_setregid                SYMBOLIC(__NR_setregid)
#define __NR_setuid                  SYMBOLIC(__NR_setuid)
#define __NR_setgid                  SYMBOLIC(__NR_setgid)
#define __NR_setresuid               SYMBOLIC(__NR_setresuid)
#define __NR_setresgid               SYMBOLIC(__NR_setresgid)
#define __NR_getresuid               SYMBOLIC(__NR_getresuid)
#define __NR_getresgid               SYMBOLIC(__NR_getresgid)
#define __NR_sigpending              SYMBOLIC(__NR_sigpending)
#define __NR_sigsuspend              SYMBOLIC(__NR_sigsuspend)
#define __NR_sigaltstack             SYMBOLIC(__NR_sigaltstack)
#define __NR_mknod                   SYMBOLIC(__NR_mknod)
#define __NR_mknodat                 SYMBOLIC(__NR_mknodat)
#define __NR_mkfifo                  SYMBOLIC(__NR_mkfifo)
#define __NR_mkfifoat                SYMBOLIC(__NR_mkfifoat)
#define __NR_statfs                  SYMBOLIC(__NR_statfs)
#define __NR_fstatfs                 SYMBOLIC(__NR_fstatfs)
#define __NR_getpriority             SYMBOLIC(__NR_getpriority)
#define __NR_setpriority             SYMBOLIC(__NR_setpriority)
#define __NR_mlock                   SYMBOLIC(__NR_mlock)
#define __NR_munlock                 SYMBOLIC(__NR_munlock)
#define __NR_mlockall                SYMBOLIC(__NR_mlockall)
#define __NR_munlockall              SYMBOLIC(__NR_munlockall)
#define __NR_setrlimit               SYMBOLIC(__NR_setrlimit)
#define __NR_chroot                  SYMBOLIC(__NR_chroot)
#define __NR_sync                    SYMBOLIC(__NR_sync)
#define __NR_acct                    SYMBOLIC(__NR_acct)
#define __NR_settimeofday            SYMBOLIC(__NR_settimeofday)
#define __NR_mount                   SYMBOLIC(__NR_mount)
#define __NR_reboot                  SYMBOLIC(__NR_reboot)
#define __NR_quotactl                SYMBOLIC(__NR_quotactl)
#define __NR_setfsuid                SYMBOLIC(__NR_setfsuid)
#define __NR_setfsgid                SYMBOLIC(__NR_setfsgid)
#define __NR_capget                  SYMBOLIC(__NR_capget)
#define __NR_capset                  SYMBOLIC(__NR_capset)
#define __NR_sigtimedwait            SYMBOLIC(__NR_sigtimedwait)
#define __NR_rt_sigqueueinfo         SYMBOLIC(__NR_rt_sigqueueinfo)
#define __NR_personality             SYMBOLIC(__NR_personality)
#define __NR_ustat                   SYMBOLIC(__NR_ustat)
#define __NR_sysfs                   SYMBOLIC(__NR_sysfs)
#define __NR_sched_setparam          SYMBOLIC(__NR_sched_setparam)
#define __NR_sched_getparam          SYMBOLIC(__NR_sched_getparam)
#define __NR_sched_setscheduler      SYMBOLIC(__NR_sched_setscheduler)
#define __NR_sched_getscheduler      SYMBOLIC(__NR_sched_getscheduler)
#define __NR_sched_get_priority_max  SYMBOLIC(__NR_sched_get_priority_max)
#define __NR_sched_get_priority_min  SYMBOLIC(__NR_sched_get_priority_min)
#define __NR_sched_rr_get_interval   SYMBOLIC(__NR_sched_rr_get_interval)
#define __NR_vhangup                 SYMBOLIC(__NR_vhangup)
#define __NR_modify_ldt              SYMBOLIC(__NR_modify_ldt)
#define __NR_pivot_root              SYMBOLIC(__NR_pivot_root)
#define __NR__sysctl                 SYMBOLIC(__NR__sysctl)
#define __NR_prctl                   SYMBOLIC(__NR_prctl)
#define __NR_arch_prctl              SYMBOLIC(__NR_arch_prctl)
#define __NR_adjtimex                SYMBOLIC(__NR_adjtimex)
#define __NR_umount2                 SYMBOLIC(__NR_umount2)
#define __NR_swapon                  SYMBOLIC(__NR_swapon)
#define __NR_swapoff                 SYMBOLIC(__NR_swapoff)
#define __NR_sethostname             SYMBOLIC(__NR_sethostname)
#define __NR_setdomainname           SYMBOLIC(__NR_setdomainname)
#define __NR_iopl                    SYMBOLIC(__NR_iopl)
#define __NR_ioperm                  SYMBOLIC(__NR_ioperm)
#define __NR_init_module             SYMBOLIC(__NR_init_module)
#define __NR_delete_module           SYMBOLIC(__NR_delete_module)
#define __NR_gettid                  SYMBOLIC(__NR_gettid)
#define __NR_readahead               SYMBOLIC(__NR_readahead)
#define __NR_setxattr                SYMBOLIC(__NR_setxattr)
#define __NR_fsetxattr               SYMBOLIC(__NR_fsetxattr)
#define __NR_getxattr                SYMBOLIC(__NR_getxattr)
#define __NR_fgetxattr               SYMBOLIC(__NR_fgetxattr)
#define __NR_listxattr               SYMBOLIC(__NR_listxattr)
#define __NR_flistxattr              SYMBOLIC(__NR_flistxattr)
#define __NR_removexattr             SYMBOLIC(__NR_removexattr)
#define __NR_fremovexattr            SYMBOLIC(__NR_fremovexattr)
#define __NR_lsetxattr               SYMBOLIC(__NR_lsetxattr)
#define __NR_lgetxattr               SYMBOLIC(__NR_lgetxattr)
#define __NR_llistxattr              SYMBOLIC(__NR_llistxattr)
#define __NR_lremovexattr            SYMBOLIC(__NR_lremovexattr)
#define __NR_sched_setaffinity       SYMBOLIC(__NR_sched_setaffinity)
#define __NR_sched_getaffinity       SYMBOLIC(__NR_sched_getaffinity)
#define __NR_cpuset_getaffinity      SYMBOLIC(__NR_cpuset_getaffinity)
#define __NR_cpuset_setaffinity      SYMBOLIC(__NR_cpuset_setaffinity)
#define __NR_io_setup                SYMBOLIC(__NR_io_setup)
#define __NR_io_destroy              SYMBOLIC(__NR_io_destroy)
#define __NR_io_getevents            SYMBOLIC(__NR_io_getevents)
#define __NR_io_submit               SYMBOLIC(__NR_io_submit)
#define __NR_io_cancel               SYMBOLIC(__NR_io_cancel)
#define __NR_lookup_dcookie          SYMBOLIC(__NR_lookup_dcookie)
#define __NR_epoll_create            SYMBOLIC(__NR_epoll_create)
#define __NR_epoll_wait              SYMBOLIC(__NR_epoll_wait)
#define __NR_epoll_ctl               SYMBOLIC(__NR_epoll_ctl)
#define __NR_getdents                SYMBOLIC(__NR_getdents)
#define __NR_set_tid_address         SYMBOLIC(__NR_set_tid_address)
#define __NR_restart_syscall         SYMBOLIC(__NR_restart_syscall)
#define __NR_semtimedop              SYMBOLIC(__NR_semtimedop)
#define __NR_fadvise                 SYMBOLIC(__NR_fadvise)
#define __NR_timer_create            SYMBOLIC(__NR_timer_create)
#define __NR_timer_settime           SYMBOLIC(__NR_timer_settime)
#define __NR_timer_gettime           SYMBOLIC(__NR_timer_gettime)
#define __NR_timer_getoverrun        SYMBOLIC(__NR_timer_getoverrun)
#define __NR_timer_delete            SYMBOLIC(__NR_timer_delete)
#define __NR_clock_settime           SYMBOLIC(__NR_clock_settime)
#define __NR_clock_gettime           SYMBOLIC(__NR_clock_gettime)
#define __NR_clock_getres            SYMBOLIC(__NR_clock_getres)
#define __NR_clock_nanosleep         SYMBOLIC(__NR_clock_nanosleep)
#define __NR_tgkill                  SYMBOLIC(__NR_tgkill)
#define __NR_mbind                   SYMBOLIC(__NR_mbind)
#define __NR_set_mempolicy           SYMBOLIC(__NR_set_mempolicy)
#define __NR_get_mempolicy           SYMBOLIC(__NR_get_mempolicy)
#define __NR_mq_open                 SYMBOLIC(__NR_mq_open)
#define __NR_mq_unlink               SYMBOLIC(__NR_mq_unlink)
#define __NR_mq_timedsend            SYMBOLIC(__NR_mq_timedsend)
#define __NR_mq_timedreceive         SYMBOLIC(__NR_mq_timedreceive)
#define __NR_mq_notify               SYMBOLIC(__NR_mq_notify)
#define __NR_mq_getsetattr           SYMBOLIC(__NR_mq_getsetattr)
#define __NR_kexec_load              SYMBOLIC(__NR_kexec_load)
#define __NR_waitid                  SYMBOLIC(__NR_waitid)
#define __NR_add_key                 SYMBOLIC(__NR_add_key)
#define __NR_request_key             SYMBOLIC(__NR_request_key)
#define __NR_keyctl                  SYMBOLIC(__NR_keyctl)
#define __NR_ioprio_set              SYMBOLIC(__NR_ioprio_set)
#define __NR_ioprio_get              SYMBOLIC(__NR_ioprio_get)
#define __NR_inotify_init            SYMBOLIC(__NR_inotify_init)
#define __NR_inotify_add_watch       SYMBOLIC(__NR_inotify_add_watch)
#define __NR_inotify_rm_watch        SYMBOLIC(__NR_inotify_rm_watch)
#define __NR_openat                  SYMBOLIC(__NR_openat)
#define __NR_mkdirat                 SYMBOLIC(__NR_mkdirat)
#define __NR_fchownat                SYMBOLIC(__NR_fchownat)
#define __NR_utime                   SYMBOLIC(__NR_utime)
#define __NR_utimes                  SYMBOLIC(__NR_utimes)
#define __NR_futimesat               SYMBOLIC(__NR_futimesat)
#define __NR_futimes                 SYMBOLIC(__NR_futimes)
#define __NR_futimens                SYMBOLIC(__NR_futimens)
#define __NR_fstatat                 SYMBOLIC(__NR_fstatat)
#define __NR_unlinkat                SYMBOLIC(__NR_unlinkat)
#define __NR_renameat                SYMBOLIC(__NR_renameat)
#define __NR_linkat                  SYMBOLIC(__NR_linkat)
#define __NR_symlinkat               SYMBOLIC(__NR_symlinkat)
#define __NR_readlinkat              SYMBOLIC(__NR_readlinkat)
#define __NR_fchmodat                SYMBOLIC(__NR_fchmodat)
#define __NR_faccessat               SYMBOLIC(__NR_faccessat)
#define __NR_unshare                 SYMBOLIC(__NR_unshare)
#define __NR_splice                  SYMBOLIC(__NR_splice)
#define __NR_tee                     SYMBOLIC(__NR_tee)
#define __NR_sync_file_range         SYMBOLIC(__NR_sync_file_range)
#define __NR_vmsplice                SYMBOLIC(__NR_vmsplice)
#define __NR_migrate_pages           SYMBOLIC(__NR_migrate_pages)
#define __NR_move_pages              SYMBOLIC(__NR_move_pages)
#define __NR_preadv                  SYMBOLIC(__NR_preadv)
#define __NR_pwritev                 SYMBOLIC(__NR_pwritev)
#define __NR_utimensat               SYMBOLIC(__NR_utimensat)
#define __NR_fallocate               SYMBOLIC(__NR_fallocate)
#define __NR_posix_fallocate         SYMBOLIC(__NR_posix_fallocate)
#define __NR_accept4                 SYMBOLIC(__NR_accept4)
#define __NR_dup3                    SYMBOLIC(__NR_dup3)
#define __NR_pipe2                   SYMBOLIC(__NR_pipe2)
#define __NR_epoll_pwait             SYMBOLIC(__NR_epoll_pwait)
#define __NR_epoll_create1           SYMBOLIC(__NR_epoll_create1)
#define __NR_perf_event_open         SYMBOLIC(__NR_perf_event_open)
#define __NR_inotify_init1           SYMBOLIC(__NR_inotify_init1)
#define __NR_rt_tgsigqueueinfo       SYMBOLIC(__NR_rt_tgsigqueueinfo)
#define __NR_signalfd                SYMBOLIC(__NR_signalfd)
#define __NR_signalfd4               SYMBOLIC(__NR_signalfd4)
#define __NR_eventfd                 SYMBOLIC(__NR_eventfd)
#define __NR_eventfd2                SYMBOLIC(__NR_eventfd2)
#define __NR_timerfd_create          SYMBOLIC(__NR_timerfd_create)
#define __NR_timerfd_settime         SYMBOLIC(__NR_timerfd_settime)
#define __NR_timerfd_gettime         SYMBOLIC(__NR_timerfd_gettime)
#define __NR_recvmmsg                SYMBOLIC(__NR_recvmmsg)
#define __NR_fanotify_init           SYMBOLIC(__NR_fanotify_init)
#define __NR_fanotify_mark           SYMBOLIC(__NR_fanotify_mark)
#define __NR_prlimit                 SYMBOLIC(__NR_prlimit)
#define __NR_name_to_handle_at       SYMBOLIC(__NR_name_to_handle_at)
#define __NR_open_by_handle_at       SYMBOLIC(__NR_open_by_handle_at)
#define __NR_clock_adjtime           SYMBOLIC(__NR_clock_adjtime)
#define __NR_syncfs                  SYMBOLIC(__NR_syncfs)
#define __NR_sendmmsg                SYMBOLIC(__NR_sendmmsg)
#define __NR_setns                   SYMBOLIC(__NR_setns)
#define __NR_getcpu                  SYMBOLIC(__NR_getcpu)
#define __NR_process_vm_readv        SYMBOLIC(__NR_process_vm_readv)
#define __NR_process_vm_writev       SYMBOLIC(__NR_process_vm_writev)
#define __NR_kcmp                    SYMBOLIC(__NR_kcmp)
#define __NR_finit_module            SYMBOLIC(__NR_finit_module)
#define __NR_sched_setattr           SYMBOLIC(__NR_sched_setattr)
#define __NR_sched_getattr           SYMBOLIC(__NR_sched_getattr)
#define __NR_renameat2               SYMBOLIC(__NR_renameat2)
#define __NR_seccomp                 SYMBOLIC(__NR_seccomp)
#define __NR_getrandom               SYMBOLIC(__NR_getrandom)
#define __NR_memfd_create            SYMBOLIC(__NR_memfd_create)
#define __NR_kexec_file_load         SYMBOLIC(__NR_kexec_file_load)
#define __NR_bpf                     SYMBOLIC(__NR_bpf)
#define __NR_execveat                SYMBOLIC(__NR_execveat)
#define __NR_userfaultfd             SYMBOLIC(__NR_userfaultfd)
#define __NR_membarrier              SYMBOLIC(__NR_membarrier)
#define __NR_mlock2                  SYMBOLIC(__NR_mlock2)
#define __NR_copy_file_range         SYMBOLIC(__NR_copy_file_range)
#define __NR_preadv2                 SYMBOLIC(__NR_preadv2)
#define __NR_pwritev2                SYMBOLIC(__NR_pwritev2)
#define __NR_pkey_mprotect           SYMBOLIC(__NR_pkey_mprotect)
#define __NR_pkey_alloc              SYMBOLIC(__NR_pkey_alloc)
#define __NR_pkey_free               SYMBOLIC(__NR_pkey_free)
#define __NR_statx                   SYMBOLIC(__NR_statx)
#define __NR_io_pgetevents           SYMBOLIC(__NR_io_pgetevents)
#define __NR_rseq                    SYMBOLIC(__NR_rseq)
#define __NR_pidfd_send_signal       SYMBOLIC(__NR_pidfd_send_signal)
#define __NR_io_uring_setup          SYMBOLIC(__NR_io_uring_setup)
#define __NR_io_uring_enter          SYMBOLIC(__NR_io_uring_enter)
#define __NR_io_uring_register       SYMBOLIC(__NR_io_uring_register)
#define __NR_pledge                  SYMBOLIC(__NR_pledge)
#define __NR_msyscall                SYMBOLIC(__NR_msyscall)
#define __NR_ktrace                  SYMBOLIC(__NR_ktrace)
#define __NR_kqueue                  SYMBOLIC(__NR_kqueue)
#define __NR_kevent                  SYMBOLIC(__NR_kevent)
#define __NR_revoke                  SYMBOLIC(__NR_revoke)
#define __NR_setlogin                SYMBOLIC(__NR_setlogin)
#define __NR_getfh                   SYMBOLIC(__NR_getfh)
#define __NR_chflags                 SYMBOLIC(__NR_chflags)
#define __NR_getfsstat               SYMBOLIC(__NR_getfsstat)
#define __NR_nfssvc                  SYMBOLIC(__NR_nfssvc)
#define __NR_adjtime                 SYMBOLIC(__NR_adjtime)
#define __NR_fchflags                SYMBOLIC(__NR_fchflags)
#define __NR_seteuid                 SYMBOLIC(__NR_seteuid)
#define __NR_setegid                 SYMBOLIC(__NR_setegid)
#define __NR_fpathconf               SYMBOLIC(__NR_fpathconf)
#define __NR_fhopen                  SYMBOLIC(__NR_fhopen)
#define __NR_unmount                 SYMBOLIC(__NR_unmount)
#define __NR_issetugid               SYMBOLIC(__NR_issetugid)
#define __NR_minherit                SYMBOLIC(__NR_minherit)
#define __NR_pathconf                SYMBOLIC(__NR_pathconf)
#define __NR_sysctl                  SYMBOLIC(__NR_sysctl)
#define __NR_ntp_adjtime             SYMBOLIC(__NR_ntp_adjtime)
#define __NR_ntp_gettime             SYMBOLIC(__NR_ntp_gettime)
#define __NR_shm_unlink              SYMBOLIC(__NR_shm_unlink)
#define __NR_shm_open                SYMBOLIC(__NR_shm_open)
#define __NR_aio_read                SYMBOLIC(__NR_aio_read)
#define __NR_aio_suspend             SYMBOLIC(__NR_aio_suspend)
#define __NR_aio_cancel              SYMBOLIC(__NR_aio_cancel)
#define __NR_aio_fsync               SYMBOLIC(__NR_aio_fsync)
#define __NR_aio_error               SYMBOLIC(__NR_aio_error)
#define __NR_aio_return              SYMBOLIC(__NR_aio_return)
#define __NR_aio_write               SYMBOLIC(__NR_aio_write)
#define __NR_aio_waitcomplete        SYMBOLIC(__NR_aio_waitcomplete)
#define __NR_aio_suspend_nocancel    SYMBOLIC(__NR_aio_suspend_nocancel)
#define __NR_aio_mlock               SYMBOLIC(__NR_aio_mlock)
#define __NR_sigwait                 SYMBOLIC(__NR_sigwait)
#define __NR_undelete                SYMBOLIC(__NR_undelete)
#define __NR_getlogin                SYMBOLIC(__NR_getlogin)
#define __NR_getdtablesize           SYMBOLIC(__NR_getdtablesize)
#define __NR_setauid                 SYMBOLIC(__NR_setauid)
#define __NR_audit                   SYMBOLIC(__NR_audit)
#define __NR_auditctl                SYMBOLIC(__NR_auditctl)
#define __NR_getaudit_addr           SYMBOLIC(__NR_getaudit_addr)
#define __NR_getdirentries           SYMBOLIC(__NR_getdirentries)
#define __NR_lio_listio              SYMBOLIC(__NR_lio_listio)
#define __NR_setaudit_addr           SYMBOLIC(__NR_setaudit_addr)
#define __NR_getauid                 SYMBOLIC(__NR_getauid)
#define __NR_semsys                  SYMBOLIC(__NR_semsys)
#define __NR_auditon                 SYMBOLIC(__NR_auditon)
#define __NR_msgsys                  SYMBOLIC(__NR_msgsys)
#define __NR_shmsys                  SYMBOLIC(__NR_shmsys)
#define __NR_fhstat                  SYMBOLIC(__NR_fhstat)
#define __NR_chflagsat               SYMBOLIC(__NR_chflagsat)
#define __NR_profil                  SYMBOLIC(__NR_profil)
#define __NR_fhstatfs                SYMBOLIC(__NR_fhstatfs)
#define __NR_utrace                  SYMBOLIC(__NR_utrace)
#define __NR_closefrom               SYMBOLIC(__NR_closefrom)
#define __NR_pthread_markcancel      SYMBOLIC(__NR_pthread_markcancel)
#define __NR_pthread_kill            SYMBOLIC(__NR_pthread_kill)
#define __NR_pthread_fchdir          SYMBOLIC(__NR_pthread_fchdir)
#define __NR_pthread_sigmask         SYMBOLIC(__NR_pthread_sigmask)
#define __NR_pthread_chdir           SYMBOLIC(__NR_pthread_chdir)
#define __NR_pthread_canceled        SYMBOLIC(__NR_pthread_canceled)
#define __NR_disable_threadsignal    SYMBOLIC(__NR_disable_threadsignal)
#define __NR_abort_with_payload      SYMBOLIC(__NR_abort_with_payload)
#define __NR_accept_nocancel         SYMBOLIC(__NR_accept_nocancel)
#define __NR_access_extended         SYMBOLIC(__NR_access_extended)
#define __NR_audit_session_join      SYMBOLIC(__NR_audit_session_join)
#define __NR_audit_session_port      SYMBOLIC(__NR_audit_session_port)
#define __NR_audit_session_self      SYMBOLIC(__NR_audit_session_self)
#define __NR_bsdthread_create        SYMBOLIC(__NR_bsdthread_create)
#define __NR_bsdthread_ctl           SYMBOLIC(__NR_bsdthread_ctl)
#define __NR_bsdthread_register      SYMBOLIC(__NR_bsdthread_register)
#define __NR_bsdthread_terminate     SYMBOLIC(__NR_bsdthread_terminate)
#define __NR_change_fdguard_np       SYMBOLIC(__NR_change_fdguard_np)
#define __NR_chmod_extended          SYMBOLIC(__NR_chmod_extended)
#define __NR_clonefileat             SYMBOLIC(__NR_clonefileat)
#define __NR_close_nocancel          SYMBOLIC(__NR_close_nocancel)
#define __NR_coalition               SYMBOLIC(__NR_coalition)
#define __NR_coalition_info          SYMBOLIC(__NR_coalition_info)
#define __NR_connect_nocancel        SYMBOLIC(__NR_connect_nocancel)
#define __NR_connectx                SYMBOLIC(__NR_connectx)
#define __NR_copyfile                SYMBOLIC(__NR_copyfile)
#define __NR_csops                   SYMBOLIC(__NR_csops)
#define __NR_csops_audittoken        SYMBOLIC(__NR_csops_audittoken)
#define __NR_csrctl                  SYMBOLIC(__NR_csrctl)
#define __NR_delete                  SYMBOLIC(__NR_delete)
#define __NR_disconnectx             SYMBOLIC(__NR_disconnectx)
#define __NR_exchangedata            SYMBOLIC(__NR_exchangedata)
#define __NR_fchmod_extended         SYMBOLIC(__NR_fchmod_extended)
#define __NR_fclonefileat            SYMBOLIC(__NR_fclonefileat)
#define __NR_fcntl_nocancel          SYMBOLIC(__NR_fcntl_nocancel)
#define __NR_ffsctl                  SYMBOLIC(__NR_ffsctl)
#define __NR_fgetattrlist            SYMBOLIC(__NR_fgetattrlist)
#define __NR_fileport_makefd         SYMBOLIC(__NR_fileport_makefd)
#define __NR_fileport_makeport       SYMBOLIC(__NR_fileport_makeport)
#define __NR_fmount                  SYMBOLIC(__NR_fmount)
#define __NR_fs_snapshot             SYMBOLIC(__NR_fs_snapshot)
#define __NR_fsctl                   SYMBOLIC(__NR_fsctl)
#define __NR_fsetattrlist            SYMBOLIC(__NR_fsetattrlist)
#define __NR_fstat_extended          SYMBOLIC(__NR_fstat_extended)
#define __NR_fsync_nocancel          SYMBOLIC(__NR_fsync_nocancel)
#define __NR_getattrlist             SYMBOLIC(__NR_getattrlist)
#define __NR_getattrlistat           SYMBOLIC(__NR_getattrlistat)
#define __NR_getattrlistbulk         SYMBOLIC(__NR_getattrlistbulk)
#define __NR_getdirentriesattr       SYMBOLIC(__NR_getdirentriesattr)
#define __NR_gethostuuid             SYMBOLIC(__NR_gethostuuid)
#define __NR_getsgroups              SYMBOLIC(__NR_getsgroups)
#define __NR_getwgroups              SYMBOLIC(__NR_getwgroups)
#define __NR_grab_pgo_data           SYMBOLIC(__NR_grab_pgo_data)
#define __NR_guarded_close_np        SYMBOLIC(__NR_guarded_close_np)
#define __NR_guarded_kqueue_np       SYMBOLIC(__NR_guarded_kqueue_np)
#define __NR_guarded_open_np         SYMBOLIC(__NR_guarded_open_np)
#define __NR_guarded_pwrite_np       SYMBOLIC(__NR_guarded_pwrite_np)
#define __NR_guarded_write_np        SYMBOLIC(__NR_guarded_write_np)
#define __NR_guarded_writev_np       SYMBOLIC(__NR_guarded_writev_np)
#define __NR_identitysvc             SYMBOLIC(__NR_identitysvc)
#define __NR_initgroups              SYMBOLIC(__NR_initgroups)
#define __NR_iopolicysys             SYMBOLIC(__NR_iopolicysys)
#define __NR_kas_info                SYMBOLIC(__NR_kas_info)
#define __NR_kdebug_trace            SYMBOLIC(__NR_kdebug_trace)
#define __NR_kdebug_trace_string     SYMBOLIC(__NR_kdebug_trace_string)
#define __NR_kdebug_typefilter       SYMBOLIC(__NR_kdebug_typefilter)
#define __NR_kevent_id               SYMBOLIC(__NR_kevent_id)
#define __NR_kevent_qos              SYMBOLIC(__NR_kevent_qos)
#define __NR_ledger                  SYMBOLIC(__NR_ledger)
#define __NR_lstat_extended          SYMBOLIC(__NR_lstat_extended)
#define __NR_memorystatus_control    SYMBOLIC(__NR_memorystatus_control)
#define __NR_memorystatus_get_level  SYMBOLIC(__NR_memorystatus_get_level)
#define __NR_microstackshot          SYMBOLIC(__NR_microstackshot)
#define __NR_mkdir_extended          SYMBOLIC(__NR_mkdir_extended)
#define __NR_mkfifo_extended         SYMBOLIC(__NR_mkfifo_extended)
#define __NR_modwatch                SYMBOLIC(__NR_modwatch)
#define __NR_mremap_encrypted        SYMBOLIC(__NR_mremap_encrypted)
#define __NR_msgrcv_nocancel         SYMBOLIC(__NR_msgrcv_nocancel)
#define __NR_msgsnd_nocancel         SYMBOLIC(__NR_msgsnd_nocancel)
#define __NR_msync_nocancel          SYMBOLIC(__NR_msync_nocancel)
#define __NR_necp_client_action      SYMBOLIC(__NR_necp_client_action)
#define __NR_necp_match_policy       SYMBOLIC(__NR_necp_match_policy)
#define __NR_necp_open               SYMBOLIC(__NR_necp_open)
#define __NR_necp_session_action     SYMBOLIC(__NR_necp_session_action)
#define __NR_necp_session_open       SYMBOLIC(__NR_necp_session_open)
#define __NR_net_qos_guideline       SYMBOLIC(__NR_net_qos_guideline)
#define __NR_netagent_trigger        SYMBOLIC(__NR_netagent_trigger)
#define __NR_nfsclnt                 SYMBOLIC(__NR_nfsclnt)
#define __NR_open_dprotected_np      SYMBOLIC(__NR_open_dprotected_np)
#define __NR_open_extended           SYMBOLIC(__NR_open_extended)
#define __NR_open_nocancel           SYMBOLIC(__NR_open_nocancel)
#define __NR_openat_nocancel         SYMBOLIC(__NR_openat_nocancel)
#define __NR_openbyid_np             SYMBOLIC(__NR_openbyid_np)
#define __NR_os_fault_with_payload   SYMBOLIC(__NR_os_fault_with_payload)
#define __NR_peeloff                 SYMBOLIC(__NR_peeloff)
#define __NR_persona                 SYMBOLIC(__NR_persona)
#define __NR_pid_hibernate           SYMBOLIC(__NR_pid_hibernate)
#define __NR_pid_resume              SYMBOLIC(__NR_pid_resume)
#define __NR_pid_shutdown_sockets    SYMBOLIC(__NR_pid_shutdown_sockets)
#define __NR_pid_suspend             SYMBOLIC(__NR_pid_suspend)
#define __NR_poll_nocancel           SYMBOLIC(__NR_poll_nocancel)
#define __NR_pread_nocancel          SYMBOLIC(__NR_pread_nocancel)
#define __NR_proc_info               SYMBOLIC(__NR_proc_info)
#define __NR_proc_rlimit_control     SYMBOLIC(__NR_proc_rlimit_control)
#define __NR_proc_trace_log          SYMBOLIC(__NR_proc_trace_log)
#define __NR_proc_uuid_policy        SYMBOLIC(__NR_proc_uuid_policy)
#define __NR_process_policy          SYMBOLIC(__NR_process_policy)
#define __NR_pselect_nocancel        SYMBOLIC(__NR_pselect_nocancel)
#define __NR_psynch_cvbroad          SYMBOLIC(__NR_psynch_cvbroad)
#define __NR_psynch_cvclrprepost     SYMBOLIC(__NR_psynch_cvclrprepost)
#define __NR_psynch_cvsignal         SYMBOLIC(__NR_psynch_cvsignal)
#define __NR_psynch_mutexdrop        SYMBOLIC(__NR_psynch_mutexdrop)
#define __NR_psynch_mutexwait        SYMBOLIC(__NR_psynch_mutexwait)
#define __NR_psynch_rw_downgrade     SYMBOLIC(__NR_psynch_rw_downgrade)
#define __NR_psynch_rw_longrdlock    SYMBOLIC(__NR_psynch_rw_longrdlock)
#define __NR_psynch_rw_rdlock        SYMBOLIC(__NR_psynch_rw_rdlock)
#define __NR_psynch_rw_unlock        SYMBOLIC(__NR_psynch_rw_unlock)
#define __NR_psynch_rw_unlock2       SYMBOLIC(__NR_psynch_rw_unlock2)
#define __NR_psynch_rw_upgrade       SYMBOLIC(__NR_psynch_rw_upgrade)
#define __NR_psynch_rw_wrlock        SYMBOLIC(__NR_psynch_rw_wrlock)
#define __NR_psynch_rw_yieldwrlock   SYMBOLIC(__NR_psynch_rw_yieldwrlock)
#define __NR_pwrite_nocancel         SYMBOLIC(__NR_pwrite_nocancel)
#define __NR_read_nocancel           SYMBOLIC(__NR_read_nocancel)
#define __NR_readv_nocancel          SYMBOLIC(__NR_readv_nocancel)
#define __NR_recvfrom_nocancel       SYMBOLIC(__NR_recvfrom_nocancel)
#define __NR_recvmsg_nocancel        SYMBOLIC(__NR_recvmsg_nocancel)
#define __NR_recvmsg_x               SYMBOLIC(__NR_recvmsg_x)
#define __NR_renameatx_np            SYMBOLIC(__NR_renameatx_np)
#define __NR_searchfs                SYMBOLIC(__NR_searchfs)
#define __NR_select_nocancel         SYMBOLIC(__NR_select_nocancel)
#define __NR_sem_close               SYMBOLIC(__NR_sem_close)
#define __NR_sem_open                SYMBOLIC(__NR_sem_open)
#define __NR_sem_post                SYMBOLIC(__NR_sem_post)
#define __NR_sem_trywait             SYMBOLIC(__NR_sem_trywait)
#define __NR_sem_unlink              SYMBOLIC(__NR_sem_unlink)
#define __NR_sem_wait                SYMBOLIC(__NR_sem_wait)
#define __NR_sem_wait_nocancel       SYMBOLIC(__NR_sem_wait_nocancel)
#define __NR_sendmsg_nocancel        SYMBOLIC(__NR_sendmsg_nocancel)
#define __NR_sendmsg_x               SYMBOLIC(__NR_sendmsg_x)
#define __NR_sendto_nocancel         SYMBOLIC(__NR_sendto_nocancel)
#define __NR_setattrlist             SYMBOLIC(__NR_setattrlist)
#define __NR_setattrlistat           SYMBOLIC(__NR_setattrlistat)
#define __NR_setprivexec             SYMBOLIC(__NR_setprivexec)
#define __NR_setsgroups              SYMBOLIC(__NR_setsgroups)
#define __NR_settid                  SYMBOLIC(__NR_settid)
#define __NR_settid_with_pid         SYMBOLIC(__NR_settid_with_pid)
#define __NR_setwgroups              SYMBOLIC(__NR_setwgroups)
#define __NR_sfi_ctl                 SYMBOLIC(__NR_sfi_ctl)
#define __NR_sfi_pidctl              SYMBOLIC(__NR_sfi_pidctl)
#define __NR_shared_region_check_np  SYMBOLIC(__NR_shared_region_check_np)
#define __NR_sigsuspend_nocancel     SYMBOLIC(__NR_sigsuspend_nocancel)
#define __NR_socket_delegate         SYMBOLIC(__NR_socket_delegate)
#define __NR_stat_extended           SYMBOLIC(__NR_stat_extended)
#define __NR_sysctlbyname            SYMBOLIC(__NR_sysctlbyname)
#define __NR_system_override         SYMBOLIC(__NR_system_override)
#define __NR_telemetry               SYMBOLIC(__NR_telemetry)
#define __NR_terminate_with_payload  SYMBOLIC(__NR_terminate_with_payload)
#define __NR_thread_selfcounts       SYMBOLIC(__NR_thread_selfcounts)
#define __NR_thread_selfid           SYMBOLIC(__NR_thread_selfid)
#define __NR_thread_selfusage        SYMBOLIC(__NR_thread_selfusage)
#define __NR_ulock_wait              SYMBOLIC(__NR_ulock_wait)
#define __NR_ulock_wake              SYMBOLIC(__NR_ulock_wake)
#define __NR_umask_extended          SYMBOLIC(__NR_umask_extended)
#define __NR_usrctl                  SYMBOLIC(__NR_usrctl)
#define __NR_vfs_purge               SYMBOLIC(__NR_vfs_purge)
#define __NR_vm_pressure_monitor     SYMBOLIC(__NR_vm_pressure_monitor)
#define __NR_wait4_nocancel          SYMBOLIC(__NR_wait4_nocancel)
#define __NR_waitevent               SYMBOLIC(__NR_waitevent)
#define __NR_waitid_nocancel         SYMBOLIC(__NR_waitid_nocancel)
#define __NR_watchevent              SYMBOLIC(__NR_watchevent)
#define __NR_work_interval_ctl       SYMBOLIC(__NR_work_interval_ctl)
#define __NR_workq_kernreturn        SYMBOLIC(__NR_workq_kernreturn)
#define __NR_workq_open              SYMBOLIC(__NR_workq_open)
#define __NR_write_nocancel          SYMBOLIC(__NR_write_nocancel)
#define __NR_writev_nocancel         SYMBOLIC(__NR_writev_nocancel)
#define __NR_abort2                  SYMBOLIC(__NR_abort2)
#define __NR_afs3_syscall            SYMBOLIC(__NR_afs3_syscall)
#define __NR_bindat                  SYMBOLIC(__NR_bindat)
#define __NR_break                   SYMBOLIC(__NR_break)
#define __NR_cap_enter               SYMBOLIC(__NR_cap_enter)
#define __NR_cap_fcntls_get          SYMBOLIC(__NR_cap_fcntls_get)
#define __NR_cap_fcntls_limit        SYMBOLIC(__NR_cap_fcntls_limit)
#define __NR_cap_getmode             SYMBOLIC(__NR_cap_getmode)
#define __NR_cap_ioctls_get          SYMBOLIC(__NR_cap_ioctls_get)
#define __NR_cap_ioctls_limit        SYMBOLIC(__NR_cap_ioctls_limit)
#define __NR_cap_rights_limit        SYMBOLIC(__NR_cap_rights_limit)
#define __NR_clock_getcpuclockid2    SYMBOLIC(__NR_clock_getcpuclockid2)
#define __NR_connectat               SYMBOLIC(__NR_connectat)
#define __NR_cpuset                  SYMBOLIC(__NR_cpuset)
#define __NR_cpuset_getdomain        SYMBOLIC(__NR_cpuset_getdomain)
#define __NR_cpuset_getid            SYMBOLIC(__NR_cpuset_getid)
#define __NR_cpuset_setdomain        SYMBOLIC(__NR_cpuset_setdomain)
#define __NR_cpuset_setid            SYMBOLIC(__NR_cpuset_setid)
#define __NR_eaccess                 SYMBOLIC(__NR_eaccess)
#define __NR_extattr_delete_fd       SYMBOLIC(__NR_extattr_delete_fd)
#define __NR_extattr_delete_file     SYMBOLIC(__NR_extattr_delete_file)
#define __NR_extattr_delete_link     SYMBOLIC(__NR_extattr_delete_link)
#define __NR_extattr_get_fd          SYMBOLIC(__NR_extattr_get_fd)
#define __NR_extattr_get_file        SYMBOLIC(__NR_extattr_get_file)
#define __NR_extattr_get_link        SYMBOLIC(__NR_extattr_get_link)
#define __NR_extattr_list_fd         SYMBOLIC(__NR_extattr_list_fd)
#define __NR_extattr_list_file       SYMBOLIC(__NR_extattr_list_file)
#define __NR_extattr_list_link       SYMBOLIC(__NR_extattr_list_link)
#define __NR_extattr_set_fd          SYMBOLIC(__NR_extattr_set_fd)
#define __NR_extattr_set_file        SYMBOLIC(__NR_extattr_set_file)
#define __NR_extattr_set_link        SYMBOLIC(__NR_extattr_set_link)
#define __NR_extattrctl              SYMBOLIC(__NR_extattrctl)
#define __NR_fexecve                 SYMBOLIC(__NR_fexecve)
#define __NR_ffclock_getcounter      SYMBOLIC(__NR_ffclock_getcounter)
#define __NR_ffclock_getestimate     SYMBOLIC(__NR_ffclock_getestimate)
#define __NR_ffclock_setestimate     SYMBOLIC(__NR_ffclock_setestimate)
#define __NR_fhlink                  SYMBOLIC(__NR_fhlink)
#define __NR_fhlinkat                SYMBOLIC(__NR_fhlinkat)
#define __NR_fhreadlink              SYMBOLIC(__NR_fhreadlink)
#define __NR_getaudit                SYMBOLIC(__NR_getaudit)
#define __NR_getcontext              SYMBOLIC(__NR_getcontext)
#define __NR_getfhat                 SYMBOLIC(__NR_getfhat)
#define __NR_gethostid               SYMBOLIC(__NR_gethostid)
#define __NR_getkerninfo             SYMBOLIC(__NR_getkerninfo)
#define __NR_getloginclass           SYMBOLIC(__NR_getloginclass)
#define __NR_getpagesize             SYMBOLIC(__NR_getpagesize)
#define __NR_gssd_syscall            SYMBOLIC(__NR_gssd_syscall)
#define __NR_jail                    SYMBOLIC(__NR_jail)
#define __NR_jail_attach             SYMBOLIC(__NR_jail_attach)
#define __NR_jail_get                SYMBOLIC(__NR_jail_get)
#define __NR_jail_remove             SYMBOLIC(__NR_jail_remove)
#define __NR_jail_set                SYMBOLIC(__NR_jail_set)
#define __NR_kenv                    SYMBOLIC(__NR_kenv)
#define __NR_kldfind                 SYMBOLIC(__NR_kldfind)
#define __NR_kldfirstmod             SYMBOLIC(__NR_kldfirstmod)
#define __NR_kldload                 SYMBOLIC(__NR_kldload)
#define __NR_kldnext                 SYMBOLIC(__NR_kldnext)
#define __NR_kldstat                 SYMBOLIC(__NR_kldstat)
#define __NR_kldsym                  SYMBOLIC(__NR_kldsym)
#define __NR_kldunload               SYMBOLIC(__NR_kldunload)
#define __NR_kldunloadf              SYMBOLIC(__NR_kldunloadf)
#define __NR_kmq_notify              SYMBOLIC(__NR_kmq_notify)
#define __NR_kmq_setattr             SYMBOLIC(__NR_kmq_setattr)
#define __NR_kmq_timedreceive        SYMBOLIC(__NR_kmq_timedreceive)
#define __NR_kmq_timedsend           SYMBOLIC(__NR_kmq_timedsend)
#define __NR_kmq_unlink              SYMBOLIC(__NR_kmq_unlink)
#define __NR_ksem_close              SYMBOLIC(__NR_ksem_close)
#define __NR_ksem_destroy            SYMBOLIC(__NR_ksem_destroy)
#define __NR_ksem_getvalue           SYMBOLIC(__NR_ksem_getvalue)
#define __NR_ksem_init               SYMBOLIC(__NR_ksem_init)
#define __NR_ksem_open               SYMBOLIC(__NR_ksem_open)
#define __NR_ksem_post               SYMBOLIC(__NR_ksem_post)
#define __NR_ksem_timedwait          SYMBOLIC(__NR_ksem_timedwait)
#define __NR_ksem_trywait            SYMBOLIC(__NR_ksem_trywait)
#define __NR_ksem_unlink             SYMBOLIC(__NR_ksem_unlink)
#define __NR_ksem_wait               SYMBOLIC(__NR_ksem_wait)
#define __NR_ktimer_create           SYMBOLIC(__NR_ktimer_create)
#define __NR_ktimer_delete           SYMBOLIC(__NR_ktimer_delete)
#define __NR_ktimer_getoverrun       SYMBOLIC(__NR_ktimer_getoverrun)
#define __NR_ktimer_gettime          SYMBOLIC(__NR_ktimer_gettime)
#define __NR_ktimer_settime          SYMBOLIC(__NR_ktimer_settime)
#define __NR_lchflags                SYMBOLIC(__NR_lchflags)
#define __NR_lchmod                  SYMBOLIC(__NR_lchmod)
#define __NR_lgetfh                  SYMBOLIC(__NR_lgetfh)
#define __NR_lpathconf               SYMBOLIC(__NR_lpathconf)
#define __NR_lutimes                 SYMBOLIC(__NR_lutimes)
#define __NR_mac_syscall             SYMBOLIC(__NR_mac_syscall)
#define __NR_modfind                 SYMBOLIC(__NR_modfind)
#define __NR_modfnext                SYMBOLIC(__NR_modfnext)
#define __NR_modnext                 SYMBOLIC(__NR_modnext)
#define __NR_modstat                 SYMBOLIC(__NR_modstat)
#define __NR_nfstat                  SYMBOLIC(__NR_nfstat)
#define __NR_nlm_syscall             SYMBOLIC(__NR_nlm_syscall)
#define __NR_nlstat                  SYMBOLIC(__NR_nlstat)
#define __NR_nmount                  SYMBOLIC(__NR_nmount)
#define __NR_nnpfs_syscall           SYMBOLIC(__NR_nnpfs_syscall)
#define __NR_nstat                   SYMBOLIC(__NR_nstat)
#define __NR_pdfork                  SYMBOLIC(__NR_pdfork)
#define __NR_pdgetpid                SYMBOLIC(__NR_pdgetpid)
#define __NR_pdkill                  SYMBOLIC(__NR_pdkill)
#define __NR_posix_openpt            SYMBOLIC(__NR_posix_openpt)
#define __NR_procctl                 SYMBOLIC(__NR_procctl)
#define __NR_psynch_cvwait           SYMBOLIC(__NR_psynch_cvwait)
#define __NR_quota                   SYMBOLIC(__NR_quota)
#define __NR_rctl_add_rule           SYMBOLIC(__NR_rctl_add_rule)
#define __NR_rctl_get_limits         SYMBOLIC(__NR_rctl_get_limits)
#define __NR_rctl_get_racct          SYMBOLIC(__NR_rctl_get_racct)
#define __NR_rctl_get_rules          SYMBOLIC(__NR_rctl_get_rules)
#define __NR_rctl_remove_rule        SYMBOLIC(__NR_rctl_remove_rule)
#define __NR_recv                    SYMBOLIC(__NR_recv)
#define __NR_rfork                   SYMBOLIC(__NR_rfork)
#define __NR_rtprio                  SYMBOLIC(__NR_rtprio)
#define __NR_rtprio_thread           SYMBOLIC(__NR_rtprio_thread)
#define __NR_send                    SYMBOLIC(__NR_send)
#define __NR_setaudit                SYMBOLIC(__NR_setaudit)
#define __NR_setcontext              SYMBOLIC(__NR_setcontext)
#define __NR_setfib                  SYMBOLIC(__NR_setfib)
#define __NR_sethostid               SYMBOLIC(__NR_sethostid)
#define __NR_setloginclass           SYMBOLIC(__NR_setloginclass)
#define __NR_sigblock                SYMBOLIC(__NR_sigblock)
#define __NR_sigqueue                SYMBOLIC(__NR_sigqueue)
#define __NR_sigsetmask              SYMBOLIC(__NR_sigsetmask)
#define __NR_sigstack                SYMBOLIC(__NR_sigstack)
#define __NR_sigvec                  SYMBOLIC(__NR_sigvec)
#define __NR_sigwaitinfo             SYMBOLIC(__NR_sigwaitinfo)
#define __NR_sstk                    SYMBOLIC(__NR_sstk)
#define __NR_swapcontext             SYMBOLIC(__NR_swapcontext)
#define __NR_thr_create              SYMBOLIC(__NR_thr_create)
#define __NR_thr_exit                SYMBOLIC(__NR_thr_exit)
#define __NR_thr_kill                SYMBOLIC(__NR_thr_kill)
#define __NR_thr_kill2               SYMBOLIC(__NR_thr_kill2)
#define __NR_thr_new                 SYMBOLIC(__NR_thr_new)
#define __NR_thr_self                SYMBOLIC(__NR_thr_self)
#define __NR_thr_set_name            SYMBOLIC(__NR_thr_set_name)
#define __NR_thr_suspend             SYMBOLIC(__NR_thr_suspend)
#define __NR_thr_wake                SYMBOLIC(__NR_thr_wake)
#define __NR_uuidgen                 SYMBOLIC(__NR_uuidgen)
#define __NR_vadvise                 SYMBOLIC(__NR_vadvise)
#define __NR_wait                    SYMBOLIC(__NR_wait)
#define __NR_wait6                   SYMBOLIC(__NR_wait6)
#define __NR_yield                   SYMBOLIC(__NR_yield)
#define __NR_tfork                   SYMBOLIC(__NR_tfork)
#define __NR_thrsleep                SYMBOLIC(__NR_thrsleep)
#define __NR_thrwakeup               SYMBOLIC(__NR_thrwakeup)
#define __NR_threxit                 SYMBOLIC(__NR_threxit)
#define __NR_thrsigdivert            SYMBOLIC(__NR_thrsigdivert)
#define __NR_set_tcb                 SYMBOLIC(__NR_set_tcb)
#define __NR_get_tcb                 SYMBOLIC(__NR_get_tcb)
#define __NR_adjfreq                 SYMBOLIC(__NR_adjfreq)
#define __NR_getdtablecount          SYMBOLIC(__NR_getdtablecount)
#define __NR_getlogin_r              SYMBOLIC(__NR_getlogin_r)
#define __NR_getrtable               SYMBOLIC(__NR_getrtable)
#define __NR_getthrid                SYMBOLIC(__NR_getthrid)
#define __NR_kbind                   SYMBOLIC(__NR_kbind)
#define __NR_mquery                  SYMBOLIC(__NR_mquery)
#define __NR_obreak                  SYMBOLIC(__NR_obreak)
#define __NR_sendsyslog              SYMBOLIC(__NR_sendsyslog)
#define __NR_setrtable               SYMBOLIC(__NR_setrtable)
#define __NR_swapctl                 SYMBOLIC(__NR_swapctl)
#define __NR_thrkill                 SYMBOLIC(__NR_thrkill)
#define __NR_unveil                  SYMBOLIC(__NR_unveil)
#define __NR_mac_get_link            SYMBOLIC(__NR_mac_get_link)
#define __NR_mac_set_link            SYMBOLIC(__NR_mac_set_link)
#define __NR_mac_get_fd              SYMBOLIC(__NR_mac_get_fd)
#define __NR_mac_get_file            SYMBOLIC(__NR_mac_get_file)
#define __NR_mac_get_proc            SYMBOLIC(__NR_mac_get_proc)
#define __NR_mac_set_fd              SYMBOLIC(__NR_mac_set_fd)
#define __NR_mac_get_pid             SYMBOLIC(__NR_mac_get_pid)
#define __NR_mac_set_proc            SYMBOLIC(__NR_mac_set_proc)
#define __NR_mac_set_file            SYMBOLIC(__NR_mac_set_file)
#define __NR_mac_execve              SYMBOLIC(__NR_mac_execve)
#define __NR_acl_get_link            SYMBOLIC(__NR_acl_get_link)
#define __NR_sigwait_nocancel        SYMBOLIC(__NR_sigwait_nocancel)
#define __NR_cap_rights_get          SYMBOLIC(__NR_cap_rights_get)
#define __NR_semwait_signal          SYMBOLIC(__NR_semwait_signal)
#define __NR_acl_set_link            SYMBOLIC(__NR_acl_set_link)
#define __NR_acl_set_fd              SYMBOLIC(__NR_acl_set_fd)
#define __NR_old_semwait_signal      SYMBOLIC(__NR_old_semwait_signal)
#define __NR_setugid                 SYMBOLIC(__NR_setugid)
#define __NR_acl_aclcheck_fd         SYMBOLIC(__NR_acl_aclcheck_fd)
#define __NR_acl_get_fd              SYMBOLIC(__NR_acl_get_fd)
#define __NR___sysctl                SYMBOLIC(__NR___sysctl)
#define __NR_mac_getfsstat           SYMBOLIC(__NR_mac_getfsstat)
#define __NR_mac_get_mount           SYMBOLIC(__NR_mac_get_mount)
#define __NR_acl_delete_link         SYMBOLIC(__NR_acl_delete_link)
#define __NR_mac_mount               SYMBOLIC(__NR_mac_mount)
#define __NR_acl_get_file            SYMBOLIC(__NR_acl_get_file)
#define __NR_acl_aclcheck_file       SYMBOLIC(__NR_acl_aclcheck_file)
#define __NR_acl_delete_fd           SYMBOLIC(__NR_acl_delete_fd)
#define __NR_acl_aclcheck_link       SYMBOLIC(__NR_acl_aclcheck_link)
#define __NR___mac_syscall           SYMBOLIC(__NR___mac_syscall)
#define __NR_acl_set_file            SYMBOLIC(__NR_acl_set_file)
#define __NR_acl_delete_file         SYMBOLIC(__NR_acl_delete_file)
#define __NR_syscall                 SYMBOLIC(__NR_syscall)
#define __NR__umtx_op                SYMBOLIC(__NR__umtx_op)
#define __NR_semwait_signal_nocancel SYMBOLIC(__NR_semwait_signal_nocancel)
#define __NR_old_semwait_signal_nocancel \
  SYMBOLIC(__NR_old_semwait_signal_nocancel)
#define __NR_sctp_peeloff             SYMBOLIC(__NR_sctp_peeloff)
#define __NR_sctp_generic_recvmsg     SYMBOLIC(__NR_sctp_generic_recvmsg)
#define __NR_sctp_generic_sendmsg     SYMBOLIC(__NR_sctp_generic_sendmsg)
#define __NR_sctp_generic_sendmsg_iov SYMBOLIC(__NR_sctp_generic_sendmsg_iov)
#define __NR_shared_region_map_and_slide_np \
  SYMBOLIC(__NR_shared_region_map_and_slide_np)
#define __NR_guarded_open_dprotected_np \
  SYMBOLIC(__NR_guarded_open_dprotected_np)
#define __NR_stack_snapshot_with_config \
  SYMBOLIC(__NR_stack_snapshot_with_config)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long __NR_exit;
extern const long __NR_exit_group;
extern const long __NR_read;
extern const long __NR_write;
extern const long __NR_open;
extern const long __NR_close;
extern const long __NR_stat;
extern const long __NR_fstat;
extern const long __NR_lstat;
extern const long __NR_poll;
extern const long __NR_ppoll;
extern const long __NR_lseek;
extern const long __NR_mmap;
extern const long __NR_msync;
extern const long __NR_mprotect;
extern const long __NR_munmap;
extern const long __NR_sigaction;
extern const long __NR_sigprocmask;
extern const long __NR_ioctl;
extern const long __NR_pread;
extern const long __NR_pwrite;
extern const long __NR_readv;
extern const long __NR_writev;
extern const long __NR_access;
extern const long __NR_pipe;
extern const long __NR_select;
extern const long __NR_pselect;
extern const long __NR_pselect6;
extern const long __NR_sched_yield;
extern const long __NR_mremap;
extern const long __NR_mincore;
extern const long __NR_madvise;
extern const long __NR_shmget;
extern const long __NR_shmat;
extern const long __NR_shmctl;
extern const long __NR_dup;
extern const long __NR_dup2;
extern const long __NR_pause;
extern const long __NR_nanosleep;
extern const long __NR_getitimer;
extern const long __NR_setitimer;
extern const long __NR_alarm;
extern const long __NR_getpid;
extern const long __NR_sendfile;
extern const long __NR_socket;
extern const long __NR_connect;
extern const long __NR_accept;
extern const long __NR_sendto;
extern const long __NR_recvfrom;
extern const long __NR_sendmsg;
extern const long __NR_recvmsg;
extern const long __NR_shutdown;
extern const long __NR_bind;
extern const long __NR_listen;
extern const long __NR_getsockname;
extern const long __NR_getpeername;
extern const long __NR_socketpair;
extern const long __NR_setsockopt;
extern const long __NR_getsockopt;
extern const long __NR_fork;
extern const long __NR_vfork;
extern const long __NR_posix_spawn;
extern const long __NR_execve;
extern const long __NR_wait4;
extern const long __NR_kill;
extern const long __NR_killpg;
extern const long __NR_clone;
extern const long __NR_tkill;
extern const long __NR_futex;
extern const long __NR_set_robust_list;
extern const long __NR_get_robust_list;
extern const long __NR_uname;
extern const long __NR_semget;
extern const long __NR_semop;
extern const long __NR_semctl;
extern const long __NR_shmdt;
extern const long __NR_msgget;
extern const long __NR_msgsnd;
extern const long __NR_msgrcv;
extern const long __NR_msgctl;
extern const long __NR_fcntl;
extern const long __NR_flock;
extern const long __NR_fsync;
extern const long __NR_fdatasync;
extern const long __NR_truncate;
extern const long __NR_ftruncate;
extern const long __NR_getcwd;
extern const long __NR_chdir;
extern const long __NR_fchdir;
extern const long __NR_rename;
extern const long __NR_mkdir;
extern const long __NR_rmdir;
extern const long __NR_creat;
extern const long __NR_link;
extern const long __NR_unlink;
extern const long __NR_symlink;
extern const long __NR_readlink;
extern const long __NR_chmod;
extern const long __NR_fchmod;
extern const long __NR_chown;
extern const long __NR_fchown;
extern const long __NR_lchown;
extern const long __NR_umask;
extern const long __NR_gettimeofday;
extern const long __NR_getrlimit;
extern const long __NR_getrusage;
extern const long __NR_sysinfo;
extern const long __NR_times;
extern const long __NR_ptrace;
extern const long __NR_syslog;
extern const long __NR_getuid;
extern const long __NR_getgid;
extern const long __NR_getppid;
extern const long __NR_getpgrp;
extern const long __NR_setsid;
extern const long __NR_getsid;
extern const long __NR_getpgid;
extern const long __NR_setpgid;
extern const long __NR_geteuid;
extern const long __NR_getegid;
extern const long __NR_getgroups;
extern const long __NR_setgroups;
extern const long __NR_setreuid;
extern const long __NR_setregid;
extern const long __NR_setuid;
extern const long __NR_setgid;
extern const long __NR_setresuid;
extern const long __NR_setresgid;
extern const long __NR_getresuid;
extern const long __NR_getresgid;
extern const long __NR_sigpending;
extern const long __NR_sigsuspend;
extern const long __NR_sigaltstack;
extern const long __NR_mknod;
extern const long __NR_mknodat;
extern const long __NR_mkfifo;
extern const long __NR_mkfifoat;
extern const long __NR_statfs;
extern const long __NR_fstatfs;
extern const long __NR_getpriority;
extern const long __NR_setpriority;
extern const long __NR_mlock;
extern const long __NR_munlock;
extern const long __NR_mlockall;
extern const long __NR_munlockall;
extern const long __NR_setrlimit;
extern const long __NR_chroot;
extern const long __NR_sync;
extern const long __NR_acct;
extern const long __NR_settimeofday;
extern const long __NR_mount;
extern const long __NR_reboot;
extern const long __NR_quotactl;
extern const long __NR_setfsuid;
extern const long __NR_setfsgid;
extern const long __NR_capget;
extern const long __NR_capset;
extern const long __NR_sigtimedwait;
extern const long __NR_rt_sigqueueinfo;
extern const long __NR_personality;
extern const long __NR_ustat;
extern const long __NR_sysfs;
extern const long __NR_sched_setparam;
extern const long __NR_sched_getparam;
extern const long __NR_sched_setscheduler;
extern const long __NR_sched_getscheduler;
extern const long __NR_sched_get_priority_max;
extern const long __NR_sched_get_priority_min;
extern const long __NR_sched_rr_get_interval;
extern const long __NR_vhangup;
extern const long __NR_modify_ldt;
extern const long __NR_pivot_root;
extern const long __NR__sysctl;
extern const long __NR_prctl;
extern const long __NR_arch_prctl;
extern const long __NR_adjtimex;
extern const long __NR_umount2;
extern const long __NR_swapon;
extern const long __NR_swapoff;
extern const long __NR_sethostname;
extern const long __NR_setdomainname;
extern const long __NR_iopl;
extern const long __NR_ioperm;
extern const long __NR_init_module;
extern const long __NR_delete_module;
extern const long __NR_gettid;
extern const long __NR_readahead;
extern const long __NR_setxattr;
extern const long __NR_fsetxattr;
extern const long __NR_getxattr;
extern const long __NR_fgetxattr;
extern const long __NR_listxattr;
extern const long __NR_flistxattr;
extern const long __NR_removexattr;
extern const long __NR_fremovexattr;
extern const long __NR_lsetxattr;
extern const long __NR_lgetxattr;
extern const long __NR_llistxattr;
extern const long __NR_lremovexattr;
extern const long __NR_sched_setaffinity;
extern const long __NR_sched_getaffinity;
extern const long __NR_cpuset_getaffinity;
extern const long __NR_cpuset_setaffinity;
extern const long __NR_io_setup;
extern const long __NR_io_destroy;
extern const long __NR_io_getevents;
extern const long __NR_io_submit;
extern const long __NR_io_cancel;
extern const long __NR_lookup_dcookie;
extern const long __NR_epoll_create;
extern const long __NR_epoll_wait;
extern const long __NR_epoll_ctl;
extern const long __NR_getdents;
extern const long __NR_set_tid_address;
extern const long __NR_restart_syscall;
extern const long __NR_semtimedop;
extern const long __NR_fadvise;
extern const long __NR_timer_create;
extern const long __NR_timer_settime;
extern const long __NR_timer_gettime;
extern const long __NR_timer_getoverrun;
extern const long __NR_timer_delete;
extern const long __NR_clock_settime;
extern const long __NR_clock_gettime;
extern const long __NR_clock_getres;
extern const long __NR_clock_nanosleep;
extern const long __NR_tgkill;
extern const long __NR_mbind;
extern const long __NR_set_mempolicy;
extern const long __NR_get_mempolicy;
extern const long __NR_mq_open;
extern const long __NR_mq_unlink;
extern const long __NR_mq_timedsend;
extern const long __NR_mq_timedreceive;
extern const long __NR_mq_notify;
extern const long __NR_mq_getsetattr;
extern const long __NR_kexec_load;
extern const long __NR_waitid;
extern const long __NR_add_key;
extern const long __NR_request_key;
extern const long __NR_keyctl;
extern const long __NR_ioprio_set;
extern const long __NR_ioprio_get;
extern const long __NR_inotify_init;
extern const long __NR_inotify_add_watch;
extern const long __NR_inotify_rm_watch;
extern const long __NR_openat;
extern const long __NR_mkdirat;
extern const long __NR_fchownat;
extern const long __NR_utime;
extern const long __NR_utimes;
extern const long __NR_futimesat;
extern const long __NR_futimes;
extern const long __NR_futimens;
extern const long __NR_fstatat;
extern const long __NR_unlinkat;
extern const long __NR_renameat;
extern const long __NR_linkat;
extern const long __NR_symlinkat;
extern const long __NR_readlinkat;
extern const long __NR_fchmodat;
extern const long __NR_faccessat;
extern const long __NR_unshare;
extern const long __NR_splice;
extern const long __NR_tee;
extern const long __NR_sync_file_range;
extern const long __NR_vmsplice;
extern const long __NR_migrate_pages;
extern const long __NR_move_pages;
extern const long __NR_preadv;
extern const long __NR_pwritev;
extern const long __NR_utimensat;
extern const long __NR_fallocate;
extern const long __NR_posix_fallocate;
extern const long __NR_accept4;
extern const long __NR_dup3;
extern const long __NR_pipe2;
extern const long __NR_epoll_pwait;
extern const long __NR_epoll_create1;
extern const long __NR_perf_event_open;
extern const long __NR_inotify_init1;
extern const long __NR_rt_tgsigqueueinfo;
extern const long __NR_signalfd;
extern const long __NR_signalfd4;
extern const long __NR_eventfd;
extern const long __NR_eventfd2;
extern const long __NR_timerfd_create;
extern const long __NR_timerfd_settime;
extern const long __NR_timerfd_gettime;
extern const long __NR_recvmmsg;
extern const long __NR_fanotify_init;
extern const long __NR_fanotify_mark;
extern const long __NR_prlimit;
extern const long __NR_name_to_handle_at;
extern const long __NR_open_by_handle_at;
extern const long __NR_clock_adjtime;
extern const long __NR_syncfs;
extern const long __NR_sendmmsg;
extern const long __NR_setns;
extern const long __NR_getcpu;
extern const long __NR_process_vm_readv;
extern const long __NR_process_vm_writev;
extern const long __NR_kcmp;
extern const long __NR_finit_module;
extern const long __NR_sched_setattr;
extern const long __NR_sched_getattr;
extern const long __NR_renameat2;
extern const long __NR_seccomp;
extern const long __NR_getrandom;
extern const long __NR_memfd_create;
extern const long __NR_kexec_file_load;
extern const long __NR_bpf;
extern const long __NR_execveat;
extern const long __NR_userfaultfd;
extern const long __NR_membarrier;
extern const long __NR_mlock2;
extern const long __NR_copy_file_range;
extern const long __NR_preadv2;
extern const long __NR_pwritev2;
extern const long __NR_pkey_mprotect;
extern const long __NR_pkey_alloc;
extern const long __NR_pkey_free;
extern const long __NR_statx;
extern const long __NR_io_pgetevents;
extern const long __NR_rseq;
extern const long __NR_pidfd_send_signal;
extern const long __NR_io_uring_setup;
extern const long __NR_io_uring_enter;
extern const long __NR_io_uring_register;
extern const long __NR_pledge;
extern const long __NR_msyscall;
extern const long __NR_ktrace;
extern const long __NR_kqueue;
extern const long __NR_kevent;
extern const long __NR_revoke;
extern const long __NR_setlogin;
extern const long __NR_getfh;
extern const long __NR_chflags;
extern const long __NR_getfsstat;
extern const long __NR_nfssvc;
extern const long __NR_adjtime;
extern const long __NR_fchflags;
extern const long __NR_seteuid;
extern const long __NR_setegid;
extern const long __NR_fpathconf;
extern const long __NR_fhopen;
extern const long __NR_unmount;
extern const long __NR_issetugid;
extern const long __NR_minherit;
extern const long __NR_pathconf;
extern const long __NR_sysctl;
extern const long __NR_ntp_adjtime;
extern const long __NR_ntp_gettime;
extern const long __NR_shm_unlink;
extern const long __NR_shm_open;
extern const long __NR_aio_read;
extern const long __NR_aio_suspend;
extern const long __NR_aio_cancel;
extern const long __NR_aio_fsync;
extern const long __NR_aio_error;
extern const long __NR_aio_return;
extern const long __NR_aio_write;
extern const long __NR_aio_waitcomplete;
extern const long __NR_aio_suspend_nocancel;
extern const long __NR_aio_mlock;
extern const long __NR_sigwait;
extern const long __NR_undelete;
extern const long __NR_getlogin;
extern const long __NR_getdtablesize;
extern const long __NR_setauid;
extern const long __NR_audit;
extern const long __NR_auditctl;
extern const long __NR_getaudit_addr;
extern const long __NR_getdirentries;
extern const long __NR_lio_listio;
extern const long __NR_setaudit_addr;
extern const long __NR_getauid;
extern const long __NR_semsys;
extern const long __NR_auditon;
extern const long __NR_msgsys;
extern const long __NR_shmsys;
extern const long __NR_fhstat;
extern const long __NR_chflagsat;
extern const long __NR_profil;
extern const long __NR_fhstatfs;
extern const long __NR_utrace;
extern const long __NR_closefrom;
extern const long __NR_pthread_markcancel;
extern const long __NR_pthread_kill;
extern const long __NR_pthread_fchdir;
extern const long __NR_pthread_sigmask;
extern const long __NR_pthread_chdir;
extern const long __NR_pthread_canceled;
extern const long __NR_disable_threadsignal;
extern const long __NR_abort_with_payload;
extern const long __NR_accept_nocancel;
extern const long __NR_access_extended;
extern const long __NR_audit_session_join;
extern const long __NR_audit_session_port;
extern const long __NR_audit_session_self;
extern const long __NR_bsdthread_create;
extern const long __NR_bsdthread_ctl;
extern const long __NR_bsdthread_register;
extern const long __NR_bsdthread_terminate;
extern const long __NR_change_fdguard_np;
extern const long __NR_chmod_extended;
extern const long __NR_clonefileat;
extern const long __NR_close_nocancel;
extern const long __NR_coalition;
extern const long __NR_coalition_info;
extern const long __NR_connect_nocancel;
extern const long __NR_connectx;
extern const long __NR_copyfile;
extern const long __NR_csops;
extern const long __NR_csops_audittoken;
extern const long __NR_csrctl;
extern const long __NR_delete;
extern const long __NR_disconnectx;
extern const long __NR_exchangedata;
extern const long __NR_fchmod_extended;
extern const long __NR_fclonefileat;
extern const long __NR_fcntl_nocancel;
extern const long __NR_ffsctl;
extern const long __NR_fgetattrlist;
extern const long __NR_fileport_makefd;
extern const long __NR_fileport_makeport;
extern const long __NR_fmount;
extern const long __NR_fs_snapshot;
extern const long __NR_fsctl;
extern const long __NR_fsetattrlist;
extern const long __NR_fstat_extended;
extern const long __NR_fsync_nocancel;
extern const long __NR_getattrlist;
extern const long __NR_getattrlistat;
extern const long __NR_getattrlistbulk;
extern const long __NR_getdirentriesattr;
extern const long __NR_gethostuuid;
extern const long __NR_getsgroups;
extern const long __NR_getwgroups;
extern const long __NR_grab_pgo_data;
extern const long __NR_guarded_close_np;
extern const long __NR_guarded_kqueue_np;
extern const long __NR_guarded_open_np;
extern const long __NR_guarded_pwrite_np;
extern const long __NR_guarded_write_np;
extern const long __NR_guarded_writev_np;
extern const long __NR_identitysvc;
extern const long __NR_initgroups;
extern const long __NR_iopolicysys;
extern const long __NR_kas_info;
extern const long __NR_kdebug_trace;
extern const long __NR_kdebug_trace_string;
extern const long __NR_kdebug_typefilter;
extern const long __NR_kevent_id;
extern const long __NR_kevent_qos;
extern const long __NR_ledger;
extern const long __NR_lstat_extended;
extern const long __NR_memorystatus_control;
extern const long __NR_memorystatus_get_level;
extern const long __NR_microstackshot;
extern const long __NR_mkdir_extended;
extern const long __NR_mkfifo_extended;
extern const long __NR_modwatch;
extern const long __NR_mremap_encrypted;
extern const long __NR_msgrcv_nocancel;
extern const long __NR_msgsnd_nocancel;
extern const long __NR_msync_nocancel;
extern const long __NR_necp_client_action;
extern const long __NR_necp_match_policy;
extern const long __NR_necp_open;
extern const long __NR_necp_session_action;
extern const long __NR_necp_session_open;
extern const long __NR_net_qos_guideline;
extern const long __NR_netagent_trigger;
extern const long __NR_nfsclnt;
extern const long __NR_open_dprotected_np;
extern const long __NR_open_extended;
extern const long __NR_open_nocancel;
extern const long __NR_openat_nocancel;
extern const long __NR_openbyid_np;
extern const long __NR_os_fault_with_payload;
extern const long __NR_peeloff;
extern const long __NR_persona;
extern const long __NR_pid_hibernate;
extern const long __NR_pid_resume;
extern const long __NR_pid_shutdown_sockets;
extern const long __NR_pid_suspend;
extern const long __NR_poll_nocancel;
extern const long __NR_pread_nocancel;
extern const long __NR_proc_info;
extern const long __NR_proc_rlimit_control;
extern const long __NR_proc_trace_log;
extern const long __NR_proc_uuid_policy;
extern const long __NR_process_policy;
extern const long __NR_pselect_nocancel;
extern const long __NR_psynch_cvbroad;
extern const long __NR_psynch_cvclrprepost;
extern const long __NR_psynch_cvsignal;
extern const long __NR_psynch_mutexdrop;
extern const long __NR_psynch_mutexwait;
extern const long __NR_psynch_rw_downgrade;
extern const long __NR_psynch_rw_longrdlock;
extern const long __NR_psynch_rw_rdlock;
extern const long __NR_psynch_rw_unlock;
extern const long __NR_psynch_rw_unlock2;
extern const long __NR_psynch_rw_upgrade;
extern const long __NR_psynch_rw_wrlock;
extern const long __NR_psynch_rw_yieldwrlock;
extern const long __NR_pwrite_nocancel;
extern const long __NR_read_nocancel;
extern const long __NR_readv_nocancel;
extern const long __NR_recvfrom_nocancel;
extern const long __NR_recvmsg_nocancel;
extern const long __NR_recvmsg_x;
extern const long __NR_renameatx_np;
extern const long __NR_searchfs;
extern const long __NR_select_nocancel;
extern const long __NR_sem_close;
extern const long __NR_sem_open;
extern const long __NR_sem_post;
extern const long __NR_sem_trywait;
extern const long __NR_sem_unlink;
extern const long __NR_sem_wait;
extern const long __NR_sem_wait_nocancel;
extern const long __NR_sendmsg_nocancel;
extern const long __NR_sendmsg_x;
extern const long __NR_sendto_nocancel;
extern const long __NR_setattrlist;
extern const long __NR_setattrlistat;
extern const long __NR_setprivexec;
extern const long __NR_setsgroups;
extern const long __NR_settid;
extern const long __NR_settid_with_pid;
extern const long __NR_setwgroups;
extern const long __NR_sfi_ctl;
extern const long __NR_sfi_pidctl;
extern const long __NR_shared_region_check_np;
extern const long __NR_sigsuspend_nocancel;
extern const long __NR_socket_delegate;
extern const long __NR_stat_extended;
extern const long __NR_sysctlbyname;
extern const long __NR_system_override;
extern const long __NR_telemetry;
extern const long __NR_terminate_with_payload;
extern const long __NR_thread_selfcounts;
extern const long __NR_thread_selfid;
extern const long __NR_thread_selfusage;
extern const long __NR_ulock_wait;
extern const long __NR_ulock_wake;
extern const long __NR_umask_extended;
extern const long __NR_usrctl;
extern const long __NR_vfs_purge;
extern const long __NR_vm_pressure_monitor;
extern const long __NR_wait4_nocancel;
extern const long __NR_waitevent;
extern const long __NR_waitid_nocancel;
extern const long __NR_watchevent;
extern const long __NR_work_interval_ctl;
extern const long __NR_workq_kernreturn;
extern const long __NR_workq_open;
extern const long __NR_write_nocancel;
extern const long __NR_writev_nocancel;
extern const long __NR_abort2;
extern const long __NR_afs3_syscall;
extern const long __NR_bindat;
extern const long __NR_break;
extern const long __NR_cap_enter;
extern const long __NR_cap_fcntls_get;
extern const long __NR_cap_fcntls_limit;
extern const long __NR_cap_getmode;
extern const long __NR_cap_ioctls_get;
extern const long __NR_cap_ioctls_limit;
extern const long __NR_cap_rights_limit;
extern const long __NR_clock_getcpuclockid2;
extern const long __NR_connectat;
extern const long __NR_cpuset;
extern const long __NR_cpuset_getdomain;
extern const long __NR_cpuset_getid;
extern const long __NR_cpuset_setdomain;
extern const long __NR_cpuset_setid;
extern const long __NR_eaccess;
extern const long __NR_extattr_delete_fd;
extern const long __NR_extattr_delete_file;
extern const long __NR_extattr_delete_link;
extern const long __NR_extattr_get_fd;
extern const long __NR_extattr_get_file;
extern const long __NR_extattr_get_link;
extern const long __NR_extattr_list_fd;
extern const long __NR_extattr_list_file;
extern const long __NR_extattr_list_link;
extern const long __NR_extattr_set_fd;
extern const long __NR_extattr_set_file;
extern const long __NR_extattr_set_link;
extern const long __NR_extattrctl;
extern const long __NR_fexecve;
extern const long __NR_ffclock_getcounter;
extern const long __NR_ffclock_getestimate;
extern const long __NR_ffclock_setestimate;
extern const long __NR_fhlink;
extern const long __NR_fhlinkat;
extern const long __NR_fhreadlink;
extern const long __NR_getaudit;
extern const long __NR_getcontext;
extern const long __NR_getfhat;
extern const long __NR_gethostid;
extern const long __NR_getkerninfo;
extern const long __NR_getloginclass;
extern const long __NR_getpagesize;
extern const long __NR_gssd_syscall;
extern const long __NR_jail;
extern const long __NR_jail_attach;
extern const long __NR_jail_get;
extern const long __NR_jail_remove;
extern const long __NR_jail_set;
extern const long __NR_kenv;
extern const long __NR_kldfind;
extern const long __NR_kldfirstmod;
extern const long __NR_kldload;
extern const long __NR_kldnext;
extern const long __NR_kldstat;
extern const long __NR_kldsym;
extern const long __NR_kldunload;
extern const long __NR_kldunloadf;
extern const long __NR_kmq_notify;
extern const long __NR_kmq_setattr;
extern const long __NR_kmq_timedreceive;
extern const long __NR_kmq_timedsend;
extern const long __NR_kmq_unlink;
extern const long __NR_ksem_close;
extern const long __NR_ksem_destroy;
extern const long __NR_ksem_getvalue;
extern const long __NR_ksem_init;
extern const long __NR_ksem_open;
extern const long __NR_ksem_post;
extern const long __NR_ksem_timedwait;
extern const long __NR_ksem_trywait;
extern const long __NR_ksem_unlink;
extern const long __NR_ksem_wait;
extern const long __NR_ktimer_create;
extern const long __NR_ktimer_delete;
extern const long __NR_ktimer_getoverrun;
extern const long __NR_ktimer_gettime;
extern const long __NR_ktimer_settime;
extern const long __NR_lchflags;
extern const long __NR_lchmod;
extern const long __NR_lgetfh;
extern const long __NR_lpathconf;
extern const long __NR_lutimes;
extern const long __NR_mac_syscall;
extern const long __NR_modfind;
extern const long __NR_modfnext;
extern const long __NR_modnext;
extern const long __NR_modstat;
extern const long __NR_nfstat;
extern const long __NR_nlm_syscall;
extern const long __NR_nlstat;
extern const long __NR_nmount;
extern const long __NR_nnpfs_syscall;
extern const long __NR_nstat;
extern const long __NR_pdfork;
extern const long __NR_pdgetpid;
extern const long __NR_pdkill;
extern const long __NR_posix_openpt;
extern const long __NR_procctl;
extern const long __NR_psynch_cvwait;
extern const long __NR_quota;
extern const long __NR_rctl_add_rule;
extern const long __NR_rctl_get_limits;
extern const long __NR_rctl_get_racct;
extern const long __NR_rctl_get_rules;
extern const long __NR_rctl_remove_rule;
extern const long __NR_recv;
extern const long __NR_rfork;
extern const long __NR_rtprio;
extern const long __NR_rtprio_thread;
extern const long __NR_send;
extern const long __NR_setaudit;
extern const long __NR_setcontext;
extern const long __NR_setfib;
extern const long __NR_sethostid;
extern const long __NR_setloginclass;
extern const long __NR_sigblock;
extern const long __NR_sigqueue;
extern const long __NR_sigsetmask;
extern const long __NR_sigstack;
extern const long __NR_sigvec;
extern const long __NR_sigwaitinfo;
extern const long __NR_sstk;
extern const long __NR_swapcontext;
extern const long __NR_thr_create;
extern const long __NR_thr_exit;
extern const long __NR_thr_kill;
extern const long __NR_thr_kill2;
extern const long __NR_thr_new;
extern const long __NR_thr_self;
extern const long __NR_thr_set_name;
extern const long __NR_thr_suspend;
extern const long __NR_thr_wake;
extern const long __NR_uuidgen;
extern const long __NR_vadvise;
extern const long __NR_wait;
extern const long __NR_wait6;
extern const long __NR_yield;
extern const long __NR_tfork;
extern const long __NR_thrsleep;
extern const long __NR_thrwakeup;
extern const long __NR_threxit;
extern const long __NR_thrsigdivert;
extern const long __NR_set_tcb;
extern const long __NR_get_tcb;
extern const long __NR_adjfreq;
extern const long __NR_getdtablecount;
extern const long __NR_getlogin_r;
extern const long __NR_getrtable;
extern const long __NR_getthrid;
extern const long __NR_kbind;
extern const long __NR_mquery;
extern const long __NR_obreak;
extern const long __NR_sendsyslog;
extern const long __NR_setrtable;
extern const long __NR_swapctl;
extern const long __NR_thrkill;
extern const long __NR_unveil;
extern const long __NR_mac_get_link;
extern const long __NR_mac_set_link;
extern const long __NR_mac_get_fd;
extern const long __NR_mac_get_file;
extern const long __NR_mac_get_proc;
extern const long __NR_mac_set_fd;
extern const long __NR_mac_get_pid;
extern const long __NR_mac_set_proc;
extern const long __NR_mac_set_file;
extern const long __NR_mac_execve;
extern const long __NR_acl_get_link;
extern const long __NR_sigwait_nocancel;
extern const long __NR_cap_rights_get;
extern const long __NR_semwait_signal;
extern const long __NR_acl_set_link;
extern const long __NR_acl_set_fd;
extern const long __NR_old_semwait_signal;
extern const long __NR_setugid;
extern const long __NR_acl_aclcheck_fd;
extern const long __NR_acl_get_fd;
extern const long __NR___sysctl;
extern const long __NR_mac_getfsstat;
extern const long __NR_mac_get_mount;
extern const long __NR_acl_delete_link;
extern const long __NR_mac_mount;
extern const long __NR_acl_get_file;
extern const long __NR_acl_aclcheck_file;
extern const long __NR_acl_delete_fd;
extern const long __NR_acl_aclcheck_link;
extern const long __NR___mac_syscall;
extern const long __NR_acl_set_file;
extern const long __NR_acl_delete_file;
extern const long __NR_syscall;
extern const long __NR__umtx_op;
extern const long __NR_semwait_signal_nocancel;
extern const long __NR_old_semwait_signal_nocancel;
extern const long __NR_sctp_peeloff;
extern const long __NR_sctp_generic_recvmsg;
extern const long __NR_sctp_generic_sendmsg;
extern const long __NR_sctp_generic_sendmsg_iov;
extern const long __NR_shared_region_map_and_slide_np;
extern const long __NR_guarded_open_dprotected_np;
extern const long __NR_stack_snapshot_with_config;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/w.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_W_H_

#define WNOHANG    SYMBOLIC(WNOHANG)
#define WUNTRACED  SYMBOLIC(WUNTRACED)
#define WCONTINUED SYMBOLIC(WCONTINUED)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long WNOHANG;
extern const long WUNTRACED;
extern const long WCONTINUED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview GDB Attach Support Code.
 *
 * The goal of these macros is to make the backtrace into the failing
 * code as short as possible. It also helps avoid GDB getting confused
 * about how we don't use its readability destroying unwind directives.
 */

extern volatile int g_gdbsync;

int gdbexec(const char *);
int attachdebugger(intptr_t);

#define attachdebugger(CONTINUE_TO_ADDR) /* shorten backtraces */ \
  SYNCHRONIZE_DEBUGGER((attachdebugger)(CONTINUE_TO_ADDR))

#define SYNCHRONIZE_DEBUGGER(PID)                                    \
  ({                                                                 \
    int Rc, Pid = (PID);                                             \
    if (Pid != -1) {                                                 \
      while ((Rc = __inline_wait4(Pid, NULL, WNOHANG, NULL)) == 0) { \
        if (g_gdbsync) {                                             \
          g_gdbsync = 0;                                             \
          if (Rc > 0) Pid = 0;                                       \
          break;                                                     \
        } else {                                                     \
          sched_yield();                                             \
        }                                                            \
      }                                                              \
    }                                                                \
    Pid;                                                             \
  })

#define __inline_wait4(PID, OPT_OUT_WSTATUS, OPTIONS, OPT_OUT_RUSAGE) \
  ({                                                                  \
    int64_t WaAx;                                                     \
    if (!IsWindows()) {                                               \
      asm volatile("mov\t%5,%%r10\n\t"                                \
                   "syscall"                                          \
                   : "=a"(WaAx)                                       \
                   : "0"(__NR_wait4), "D"(PID), "S"(OPT_OUT_WSTATUS), \
                     "d"(OPTIONS), "g"(OPT_OUT_RUSAGE)                \
                   : "rcx", "r10", "r11", "cc", "memory");            \
    } else {                                                          \
      WaAx = sys_wait4_nt(PID, OPT_OUT_WSTATUS, OPTIONS, OPT_OUT_RUSAGE); \
    }                                                                 \
    WaAx;                                                             \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/log/log.h */

#define COSMOPOLITAN_LIBC_LOG_LOG_H_


/*!BEGIN libc/stdio/stdio.h */

#define COSMOPOLITAN_LIBC_STDIO_STDIO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard i/o                                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef struct FILE {
  uint8_t bufmode;              /* 0x00 _IOFBF, etc. (ignored if fd=-1) */
  bool noclose;                 /* 0x01 for fake dup() */
  uint32_t iomode;              /* 0x04 O_RDONLY, etc. (ignored if fd=-1) */
  int32_t state;                /* 0x08 0=OK, -1=EOF, >0=errno */
  int fd;                       /* 0x0c ≥0=fd, -1=closed|buffer */
  uint32_t beg;                 /* 0x10 */
  uint32_t end;                 /* 0x14 */
  uint8_t *buf;                 /* 0x18 */
  uint32_t size;                /* 0x20 */
  uint32_t nofree;              /* 0x24 */
  int (*reader)(struct FILE *); /* 0x28 */
  int (*writer)(struct FILE *); /* 0x30 */
  int pid;                      /* 0x34 */
} FILE;

extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;

errno_t ferror(FILE *) paramsnonnull();
void clearerr(FILE *) paramsnonnull();
int feof(FILE *) paramsnonnull();
int getc(FILE *) paramsnonnull();
int putc(int, FILE *) paramsnonnull();
int fflush(FILE *);
int fgetc(FILE *) paramsnonnull();
int ungetc(int, FILE *) paramsnonnull();
int fileno(FILE *) paramsnonnull() nosideeffect;
int fputc(int, FILE *) paramsnonnull();
int fputs(const char *, FILE *) paramsnonnull();
int fputws(const wchar_t *, FILE *) paramsnonnull();
char *fgets(char *, int, FILE *) paramsnonnull();
wchar_t *fgetws(wchar_t *, int, FILE *) paramsnonnull();
wint_t fputwc(wchar_t, FILE *) paramsnonnull();
wint_t putwchar(wchar_t);
wint_t getwchar(void);
wint_t fgetwc(FILE *) paramsnonnull();
int getchar(void);
int putchar(int);
int puts(const char *) paramsnonnull();
ssize_t getline(char **, size_t *, FILE *) paramsnonnull();
ssize_t getdelim(char **, size_t *, int, FILE *) paramsnonnull();
FILE *fopen(const char *, const char *) paramsnonnull() nodiscard;
FILE *fdopen(int, const char *) paramsnonnull() nodiscard;
FILE *fmemopen(void *, size_t, const char *) paramsnonnull((3)) nodiscard;
FILE *freopen(const char *, const char *, FILE *) paramsnonnull((2, 3));
size_t fread(void *, size_t, size_t, FILE *) paramsnonnull();
size_t fwrite(const void *, size_t, size_t, FILE *) paramsnonnull();
int fclose(FILE *);
int fclose_s(FILE **) paramsnonnull();
long fseek(FILE *, long, int) paramsnonnull();
long ftell(FILE *) paramsnonnull();
void rewind(FILE *) paramsnonnull();
int fopenflags(const char *) paramsnonnull();
unsigned favail(FILE *);
void setbuf(FILE *, char *);
void setbuffer(FILE *, char *, size_t);
int setvbuf(FILE *, char *, int, size_t);
FILE *popen(const char *, const char *);
int pclose(FILE *);

typedef uint64_t fpos_t;
compatfn char *gets(char *) paramsnonnull();
compatfn int fgetpos(FILE *, fpos_t *) paramsnonnull();
compatfn int fsetpos(FILE *, const fpos_t *) paramsnonnull();
compatfn int64_t fseeko(FILE *, long, int) paramsnonnull();
compatfn int64_t ftello(FILE *) paramsnonnull();

int system(const char *);
int systemexec(const char *);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard i/o » formatting                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int printf(const char *, ...) printfesque(1)
    paramsnonnull((1)) nothrow nocallback;
int vprintf(const char *, va_list) paramsnonnull() nothrow nocallback;
int fprintf(FILE *, const char *, ...) printfesque(2)
    paramsnonnull((1, 2)) nothrow nocallback;
int vfprintf(FILE *, const char *, va_list) paramsnonnull() nothrow nocallback;
int scanf(const char *, ...) scanfesque(1);
int vscanf(const char *, va_list);
int fscanf(FILE *, const char *, ...) scanfesque(2);
int vfscanf(FILE *, const char *, va_list);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard i/o » optimizations                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define getc(f)    (f->beg < f->end ? f->buf[f->beg++] : fgetc(f))
#define putc(c, f) fputc(c, f)

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define printf(FMT, ...)     (printf)(PFLINK(FMT), ##__VA_ARGS__)
#define vprintf(FMT, VA)     (vprintf)(PFLINK(FMT), VA)
#define fprintf(F, FMT, ...) (fprintf)(F, PFLINK(FMT), ##__VA_ARGS__)
#define vfprintf(F, FMT, VA) (vfprintf)(F, PFLINK(FMT), VA)
#define vscanf(FMT, VA)      (vscanf)(SFLINK(FMT), VA)
#define scanf(FMT, ...)      (scanf)(SFLINK(FMT), ##__VA_ARGS__)
#define fscanf(F, FMT, ...)  (fscanf)(F, SFLINK(FMT), ##__VA_ARGS__)
#define vfscanf(F, FMT, VA)  (vfscanf)(F, SFLINK(FMT), VA)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define stdin  SYMBOLIC(stdin)
#define stdout SYMBOLIC(stdout)
#define stderr SYMBOLIC(stderr)

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § liblog                                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kLogFatal   0
#define kLogError   1
#define kLogWarn    2
#define kLogInfo    3
#define kLogVerbose 4
#define kLogDebug   5

/**
 * Log level for compile-time DCE.
 */
#ifndef LOGGABLELEVEL
#ifndef TINY
#define LOGGABLELEVEL kLogDebug
/* #elif IsTiny() */
/* #define LOGGABLELEVEL kLogInfo */
#else
#define LOGGABLELEVEL kLogVerbose
#endif
#endif

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern FILE *g_logfile;

void perror(const char *) relegated;   /* print the last system error */
void __die(void) relegated wontreturn; /* print backtrace and abort() */
void meminfo(int);                     /* shows malloc statistics &c. */
void memsummary(int);                  /* light version of same thing */
uint16_t getttycols(uint16_t);
int getttysize(int, struct winsize *) paramsnonnull();
bool IsTerminalInarticulate(void) nosideeffect;
const char *commandvenv(const char *, const char *);
const char *GetAddr2linePath(void);
const char *GetGdbPath(void);

void showcrashreports(void);
void callexitontermination(struct sigset *);
bool32 IsDebuggerPresent(bool);
bool IsRunningUnderMake(void);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § liblog » logging                                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#ifndef __STRICT_ANSI__

extern unsigned g_loglevel; /* log level for runtime check */

#define LOGGABLE(LEVEL)                                          \
  ((!__builtin_constant_p(LEVEL) || (LEVEL) <= LOGGABLELEVEL) && \
   (LEVEL) <= g_loglevel)

#define LOGF(FMT, ...)                                               \
  do {                                                               \
    if (LOGGABLE(kLogInfo)) {                                        \
      flogf(kLogInfo, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
    }                                                                \
  } while (0)

#define VFLOG(FMT, VA)                                     \
  do {                                                     \
    if (LOGGABLE(kLogInfo)) {                              \
      vflogf(kLogInfo, __FILE__, __LINE__, NULL, FMT, VA); \
    }                                                      \
  } while (0)

#define FLOGF(F, FMT, ...)                                        \
  do {                                                            \
    if (LOGGABLE(kLogInfo)) {                                     \
      flogf(kLogInfo, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
    }                                                             \
  } while (0)

#define VFLOGF(F, FMT, VA)                              \
  do {                                                  \
    if (LOGGABLE(kLogInfo)) {                           \
      vflogf(kLogInfo, __FILE__, __LINE__, F, FMT, VA); \
    }                                                   \
  } while (0)

#define WARNF(FMT, ...)                                              \
  do {                                                               \
    if (LOGGABLE(kLogWarn)) {                                        \
      flogf(kLogWarn, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
    }                                                                \
  } while (0)

#define VWARNF(FMT, VA)                                    \
  do {                                                     \
    if (LOGGABLE(kLogWarn)) {                              \
      vflogf(kLogWarn, __FILE__, __LINE__, NULL, FMT, VA); \
    }                                                      \
  } while (0)

#define FWARNF(F, FMT, ...)                                       \
  do {                                                            \
    if (LOGGABLE(kLogWarn)) {                                     \
      flogf(kLogWarn, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
    }                                                             \
  } while (0)

#define VFWARNF(F, FMT, VA)                             \
  do {                                                  \
    if (LOGGABLE(kLogWarn)) {                           \
      vflogf(kLogWarn, __FILE__, __LINE__, F, FMT, VA); \
    }                                                   \
  } while (0)

#define FATALF(FMT, ...)                                              \
  do {                                                                \
    ffatalf(kLogFatal, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
    unreachable;                                                      \
  } while (0)

#define VFATALF(FMT, VA)                                    \
  do {                                                      \
    vffatalf(kLogFatal, __FILE__, __LINE__, NULL, FMT, VA); \
    unreachable;                                            \
  } while (0)

#define FFATALF(F, FMT, ...)                                       \
  do {                                                             \
    ffatalf(kLogFatal, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
    unreachable;                                                   \
  } while (0)

#define VFFATALF(F, FMT, VA)                             \
  do {                                                   \
    vffatalf(kLogFatal, __FILE__, __LINE__, F, FMT, VA); \
    unreachable;                                         \
  } while (0)

#define DEBUGF(FMT, ...)                                                \
  do {                                                                  \
    if (LOGGABLE(kLogDebug)) {                                          \
      fdebugf(kLogDebug, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
    }                                                                   \
  } while (0)

#define VERBOSEF(FMT, ...)                                                  \
  do {                                                                      \
    if (LOGGABLE(kLogVerbose)) {                                            \
      fverbosef(kLogVerbose, __FILE__, __LINE__, NULL, FMT, ##__VA_ARGS__); \
    }                                                                       \
  } while (0)

#define VDEBUGF(FMT, VA)                                      \
  do {                                                        \
    if (LOGGABLE(kLogDebug)) {                                \
      vfdebugf(kLogDebug, __FILE__, __LINE__, NULL, FMT, VA); \
    }                                                         \
  } while (0)

#define FDEBUGF(F, FMT, ...)                                         \
  do {                                                               \
    if (LOGGABLE(kLogDebug)) {                                       \
      fdebugf(kLogDebug, __FILE__, __LINE__, F, FMT, ##__VA_ARGS__); \
    }                                                                \
  } while (0)

#define VFVERBOSEF(F, FMT, VA)                                 \
  do {                                                         \
    if (LOGGABLE(kLogVerbose)) {                               \
      vfverbosef(kLogVerbose, __FILE__, __LINE__, F, FMT, VA); \
    }                                                          \
  } while (0)

#define VFDEBUGF(F, FMT, VA)                               \
  do {                                                     \
    if (LOGGABLE(kLogDebug)) {                             \
      vfdebugf(kLogDebug, __FILE__, __LINE__, F, FMT, VA); \
    }                                                      \
  } while (0)

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § liblog » on error resume next                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define LOGIFNEG1(FORM)                                 \
  ({                                                    \
    autotype(FORM) Ax = (FORM);                         \
    if (Ax == (typeof(Ax))(-1) && LOGGABLE(kLogWarn)) { \
      __logerrno(__FILE__, __LINE__, #FORM);            \
    }                                                   \
    Ax;                                                 \
  })

#define LOGIFNULL(FORM)                      \
  ({                                         \
    autotype(FORM) Ax = (FORM);              \
    if (Ax == NULL && LOGGABLE(kLogWarn)) {  \
      __logerrno(__FILE__, __LINE__, #FORM); \
    }                                        \
    Ax;                                      \
  })

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § liblog » implementation details                           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void __logerrno(const char *, int, const char *) relegated;

#define ARGS  unsigned, const char *, int, FILE *, const char *
#define ATTR  paramsnonnull((5)) printfesque(5)
#define ATTRV paramsnonnull((5, 6))
void flogf(ARGS, ...) ATTR libcesque;
void vflogf(ARGS, va_list) ATTRV libcesque;
void fverbosef(ARGS, ...) asm("flogf") ATTR relegated libcesque;
void vfverbosef(ARGS, va_list) asm("vflogf") ATTRV relegated libcesque;
void fdebugf(ARGS, ...) asm("flogf") ATTR relegated libcesque;
void vfdebugf(ARGS, va_list) asm("vflogf") ATTRV relegated libcesque;
void ffatalf(ARGS, ...) asm("flogf") ATTR relegated wontreturn libcesque;
void vffatalf(ARGS, va_list) asm("vflogf") ATTRV relegated wontreturn libcesque;
#undef ARGS
#undef ATTR
#undef ATTRV

#endif /* __STRICT_ANSI__ */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/alloca.h */

#define COSMOPOLITAN_LIBC_MEM_ALLOCA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define alloca(size) __builtin_alloca(size)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/mem/fmt.h */

#define COSMOPOLITAN_LIBC_MEM_FMT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int asprintf(char **, const char *, ...) printfesque(2)
    paramsnonnull((1, 2)) libcesque;
int vasprintf(char **, const char *, va_list) paramsnonnull() libcesque;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define asprintf(SP, FMT, ...) (asprintf)(SP, PFLINK(FMT), ##__VA_ARGS__)
#define vasprintf(SP, FMT, VA) (vasprintf)(SP, PFLINK(FMT), VA)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/bench.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_BENCH_H_


/*!BEGIN libc/nexgen32e/rdtsc.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_RDTSC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * Reads CPU timestamp counter.
 *
 * This macro inhibits compiler magic.
 * This macro does not inhibit CPU magic.
 *
 * @see X86_HAVE(INVTSC)
 */
#define rdtsc() __RDTSC("rdtsc")

/**
 * Reads CPU timestamp counter w/ full serialization.
 *
 * This macro inhibits CPU magic.
 * This macro inhibits compiler magic.
 *
 * The clock isn't read until:
 *
 *   1. previous instructions finish executing; and
 *   2. previous loads are globally visible; and
 *   3. previous stores are globally visible.
 *
 * Later instructions won't dispatch until RDTSC completes.
 *
 * @see X86_HAVE(INVTSC)
 */
#define mfence_lfence_rdtsc_lfence() \
  __RDTSC("mfence\n\tlfence\n\trdtsc\n\tlfence")

#define __RDTSC(ASM)                                                       \
  ({                                                                       \
    uint64_t Rax, Rdx;                                                     \
    asm volatile(ASM : "=a"(Rax), "=d"(Rdx) : /* no inputs */ : "memory"); \
    Rdx << 32 | Rax;                                                       \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * @fileoverview NexGen32e Microbenchmarking.
 *
 * @see X86_HAVE(INVTSC)
 * @see libc/testlib/bench.h
 */

#define __startbench()                            \
  ({                                              \
    uint64_t Ticks;                               \
    asm volatile("lfence\n\t"                     \
                 "push\t%%rbx\n\t"                \
                 "cpuid\n\t"                      \
                 "pop\t%%rbx\n\t"                 \
                 "rdtsc\n\t"                      \
                 "shl\t%2,%%rdx\n\t"              \
                 "or\t%%rdx,%0"                   \
                 : "=a"(Ticks)                    \
                 : "0"(0), "J"(32)                \
                 : "rcx", "rdx", "memory", "cc"); \
    Ticks;                                        \
  })

#define __endbench()                                     \
  ({                                                     \
    uint64_t Ticks;                                      \
    asm volatile("rdtscp\n\t"                            \
                 "shl\t%1,%%rdx\n\t"                     \
                 "or\t%%rdx,%%rax\n\t"                   \
                 "mov\t%%rax,%0\n\t"                     \
                 "xor\t%%eax,%%eax\n\t"                  \
                 "push\t%%rbx\n\t"                       \
                 "cpuid\n\t"                             \
                 "pop\t%%rbx"                            \
                 : "=r"(Ticks)                           \
                 : "J"(32)                               \
                 : "rax", "rcx", "rdx", "memory", "cc"); \
    Ticks;                                               \
  })

#define __startbench_m() mfence_lfence_rdtsc_lfence()
#define __endbench_m()   __startbench_m()
#define __marker()       asm("nop")
#define __ordered()      asm volatile("" ::: "memory")
#define __fakeread(X)    asm volatile("" : /* no outputs */ : "g"(X))
#define __fakereadwrite(X)                 \
  ({                                       \
    autotype(X) Res = (X);                 \
    asm volatile("" : "=g"(Res) : "0"(X)); \
    Res;                                   \
  })

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/bsf.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_BSF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*
 * BIT SCANNING 101
 *                          ctz(𝑥)         31^clz(𝑥)   clz(𝑥)
 *      uint32 𝑥   bsf(𝑥) tzcnt(𝑥)   ffs(𝑥)   bsr(𝑥) lzcnt(𝑥)
 *    0x00000000      wut       32        0      wut       32
 *    0x00000001        0        0        1        0       31
 *    0x80000001        0        0        1       31        0
 *    0x80000000       31       31       32       31        0
 *    0x00000010        4        4        5        4       27
 *    0x08000010        4        4        5       27        4
 *    0x08000000       27       27       28       27        4
 *    0xffffffff        0        0        1       31        0
 */

int bsf(int);
int bsfl(long);
int bsfll(long long);
int bsfmax(uintmax_t);

#ifdef __GNUC__
#define bsf(u)   __builtin_ctz(u)
#define bsfl(u)  __builtin_ctzl(u)
#define bsfll(u) __builtin_ctzll(u)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/bsr.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_BSR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*
 * BIT SCANNING 101
 *                          ctz(𝑥)         31^clz(𝑥)   clz(𝑥)
 *      uint32 𝑥   bsf(𝑥) tzcnt(𝑥)   ffs(𝑥)   bsr(𝑥) lzcnt(𝑥)
 *    0x00000000      wut       32        0      wut       32
 *    0x00000001        0        0        1        0       31
 *    0x80000001        0        0        1       31        0
 *    0x80000000       31       31       32       31        0
 *    0x00000010        4        4        5        4       27
 *    0x08000010        4        4        5       27        4
 *    0x08000000       27       27       28       27        4
 *    0xffffffff        0        0        1       31        0
 */

int bsr(int);
int bsrl(long);
int bsrll(long long);
int bsrmax(uintmax_t);

#ifdef __GNUC__
#define bsr(u)   ((sizeof(int) * 8 - 1) ^ __builtin_clz(u))
#define bsrl(u)  ((sizeof(long) * 8 - 1) ^ __builtin_clzl(u))
#define bsrll(u) ((sizeof(long long) * 8 - 1) ^ __builtin_clzll(u))
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/cachesize.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_CACHESIZE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define kCpuCacheTypeData        1
#define kCpuCacheTypeInstruction 2
#define kCpuCacheTypeUnified     3

unsigned getcachesize(int, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/crc32.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_CRC32_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void crc32init(uint32_t[hasatleast 256], uint32_t);
uint32_t crc32_z(uint32_t, const void *, size_t);
extern uint32_t (*const crc32c)(uint32_t, const void *, size_t);
uint32_t crc32c_pure(uint32_t, const void *, size_t) strlenesque hidden;
uint32_t crc32c_sse42(uint32_t, const void *, size_t) strlenesque hidden;
uint32_t crc32_pclmul(uint32_t, const void *, size_t) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/ffs.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_FFS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/*
 * BIT SCANNING 101
 *                          ctz(𝑥)         31^clz(𝑥)   clz(𝑥)
 *      uint32 𝑥   bsf(𝑥) tzcnt(𝑥)   ffs(𝑥)   bsr(𝑥) lzcnt(𝑥)
 *    0x00000000      wut       32        0      wut       32
 *    0x00000001        0        0        1        0       31
 *    0x80000001        0        0        1       31        0
 *    0x80000000       31       31       32       31        0
 *    0x00000010        4        4        5        4       27
 *    0x08000010        4        4        5       27        4
 *    0x08000000       27       27       28       27        4
 *    0xffffffff        0        0        1       31        0
 */

int ffs(int) pureconst;
int ffsl(long) pureconst;
int ffsll(long long) pureconst;

#ifdef __GNUC__
#define ffs(u)   __builtin_ffs(u)
#define ffsl(u)  __builtin_ffsl(u)
#define ffsll(u) __builtin_ffsll(u)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/kompressor.h */

#define COSMOPOLITAN_LIBC_KOMPRESSOR_KOMPRESSOR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
#if 0
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § standard library » compression                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#endif

struct RlDecode {
  uint8_t repititions;
  uint8_t byte;
};

void rldecode(void *dest, const struct RlDecode *) hidden;
const uint8_t *lz4check(const void *data) hidden;
void *lz4cpy(void *dest, const void *blockdata, size_t blocksize) hidden;
void *lz4decode(void *dest, const void *src) hidden;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/lz4.h */

#define COSMOPOLITAN_LIBC_LZ4_H_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § lz4                                                       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  LZ4 is a framing format for REP MOVSB designed by Yann Collet.

  @see https://github.com/lz4/lz4/blob/master/doc/lz4_Frame_format.md
  @see https://github.com/lz4/lz4/blob/master/doc/lz4_Block_format.md
  @see http://ticki.github.io/blog/how-lz4-works/ */

#define LZ4_EOF                0
#define LZ4_VERSION            1
#define LZ4_MAGICNUMBER        0x184D2204
#define LZ4_SKIPPABLE0         0x184D2A50
#define LZ4_SKIPPABLEMASK      0xFFFFFFF0
#define LZ4_MAXHEADERSIZE      (MAGICNUMBER_SIZE + 2 + 8 + 4 + 1)
#define LZ4_BLOCKMAXSIZE_64KB  4
#define LZ4_BLOCKMAXSIZE_256KB 5
#define LZ4_BLOCKMAXSIZE_1MB   6
#define LZ4_BLOCKMAXSIZE_4MB   7

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § lz4 » frames                                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define LZ4_MAGIC(FRAME)                      READ32LE(FRAME)
#define LZ4_FRAME_VERSION(FRAME)              ((_LZ4_FRAME_FLG(FRAME) >> 6) & 3)
#define LZ4_FRAME_BLOCKINDEPENDENCE(FRAME)    ((_LZ4_FRAME_FLG(FRAME) >> 5) & 1)
#define LZ4_FRAME_BLOCKCHECKSUMFLAG(FRAME)    ((_LZ4_FRAME_FLG(FRAME) >> 4) & 1)
#define LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME) ((_LZ4_FRAME_FLG(FRAME) >> 3) & 1)
#define LZ4_FRAME_BLOCKCONTENTCHECKSUMFLAG(FRAME) \
  ((_LZ4_FRAME_FLG(FRAME) >> 2) & 1)
#define LZ4_FRAME_DICTIONARYIDFLAG(FRAME) ((_LZ4_FRAME_FLG(FRAME) >> 0) & 1)
#define LZ4_FRAME_BLOCKMAXSIZE(FRAME)     ((_LZ4_FRAME_BD(FRAME) >> 4) & 7)
#define LZ4_FRAME_RESERVED1(FRAME)        ((_LZ4_FRAME_FLG(FRAME) >> 1) & 1)
#define LZ4_FRAME_RESERVED2(FRAME)        ((_LZ4_FRAME_BD(FRAME) >> 7) & 1)
#define LZ4_FRAME_RESERVED3(FRAME)        ((_LZ4_FRAME_BD(FRAME) >> 0) & 15)
#define LZ4_FRAME_BLOCKCONTENTSIZE(FRAME) \
  (LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME) ? READ64LE((FRAME) + 4 + 1 + 1) : 0)
#define LZ4_FRAME_DICTIONARYID(FRAME)                          \
  (LZ4_FRAME_DICTIONARYIDFLAG(FRAME)                           \
       ? READ32LE(((FRAME) + 4 + 1 + 1 +                       \
                   8 * LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME))) \
       : 0)
#define LZ4_FRAME_HEADERCHECKSUM(FRAME)                                \
  (*((FRAME) + 4 + 1 + 1 + 8 * LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME) + \
     4 * LZ4_FRAME_DICTIONARYIDFLAG(FRAME)))
#define LZ4_FRAME_HEADERSIZE(FRAME)                        \
  (4 + 1 + 1 + 8 * LZ4_FRAME_BLOCKCONTENTSIZEFLAG(FRAME) + \
   4 * LZ4_FRAME_DICTIONARYIDFLAG(FRAME) + 1)
#define _LZ4_FRAME_FLG(FRAME) (*((FRAME) + 4))
#define _LZ4_FRAME_BD(FRAME)  (*((FRAME) + 5))

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § lz4 » blocks                                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define LZ4_BLOCK_DATA(block)         (block + sizeof(uint32_t))
#define LZ4_BLOCK_DATASIZE(block)     (READ32LE(block) & 0x7fffffff)
#define LZ4_BLOCK_ISEOF(block)        (READ32LE(block) == LZ4_EOF)
#define LZ4_BLOCK_ISCOMPRESSED(block) ((READ32LE(block) & 0x80000000) == 0)
#define LZ4_BLOCK_SIZE(frame, block)              \
  (sizeof(uint32_t) + LZ4_BLOCK_DATASIZE(block) + \
   (LZ4_FRAME_BLOCKCHECKSUMFLAG(frame) ? sizeof(uint8_t) : 0))

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/lzcnt.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_LZCNT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

unsigned lzcnt(unsigned) libcesque pureconst;
unsigned long lzcntl(unsigned long) libcesque pureconst;

#define lzcnt(X)                                           \
  ({                                                       \
    typeof(X) Res;                                         \
    if (X86_HAVE(ABM)) {                                   \
      /* amd piledriver+ (a.k.a. bdver1) c. 2011 */        \
      /* intel haswell+ c. 2013 */                         \
      asm("lzcnt\t%1,%0" : "=r,r"(Res) : "r,m"(X) : "cc"); \
    } else {                                               \
      Res = (lzcnt)(X);                                    \
    }                                                      \
    Res;                                                   \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/macros.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_MACROS_H_
#ifdef __ASSEMBLER__
#else

/* let's give auto-import tooling a helping hand */
#define pbroadcastb pbroadcastb

#endif /* __ASSEMBLER__ */


/*!BEGIN libc/nexgen32e/msr.h */

#define COSMOPOLITAN_LIBC_MSR_H_
/*─────────────────────────────────────────────────────────────────────────────╗
│ cosmopolitan § model specific registers                                      │
╚─────────────────────────────────────────────────────────────────────────────*/

#define MSR_P5_TSC 0x10       /* time stamp register */
#define MSR_P5_CESR 0x11      /* control and event select register */
#define MSR_P5_CTR0 0x12      /* counter #0 */
#define MSR_P5_CTR1 0x13      /* counter #1 */
#define MSR_P5_CESR_PC 0x0200 /* pin control */
#define MSR_P5_CESR_CC 0x01C0 /* counter control mask */
#define MSR_P5_CESR_ES 0x003F /* event control mask */
#define MSR_P5_CESR_SHIFT 16  /* shift to get counter 1 */
#define MSR_P5_CESR_MASK      /* mask Counter */ \
  (MSR_P5_CESR_PC | MSR_P5_CESR_CC | MSR_P5_CESR_ES)

#define MSR_CORE_THREAD_COUNT 0x35
#define MSR_FLEX_RATIO 0x194
#define MSR_IA32_APERF 0xE8
#define MSR_IA32_APIC_BASE 0x1b
#define MSR_IA32_APIC_BASE_BASE (0xfffff << 12)
#define MSR_IA32_APIC_BASE_BSP (1 << 8)
#define MSR_IA32_APIC_BASE_ENABLE (1 << 11)
#define MSR_IA32_APIC_BASE_EXTENDED (1 << 10)
#define MSR_IA32_BBL_CR_CTL 0x119
#define MSR_IA32_BIOS_SIGN_ID 0x8b
#define MSR_IA32_CLOCK_MODULATION 0x19a
#define MSR_IA32_CORE_C3_RESIDENCY 0x3FC
#define MSR_IA32_CORE_C6_RESIDENCY 0x3FD
#define MSR_IA32_CORE_C7_RESIDENCY 0x3FE
#define MSR_IA32_CR_PAT 0x277
#define MSR_IA32_CSTAR 0xC0000083
#define MSR_IA32_DDR_ENERGY_STATUS 0x619
#define MSR_IA32_DEBUGCTLMSR 0x1d9
#define MSR_IA32_DS_AREA 0x600
#define MSR_IA32_EBL_CR_POWERON 0x2a
#define MSR_IA32_EFER 0xC0000080
#define MSR_IA32_EFER_LMA 0x00000400
#define MSR_IA32_EFER_LME 0x00000100
#define MSR_IA32_EFER_NXE 0x00000800
#define MSR_IA32_EFER_SCE 0x00000001
#define MSR_IA32_EVNTSEL0 0x186
#define MSR_IA32_EVNTSEL1 0x187
#define MSR_IA32_EVNTSEL2 0x188
#define MSR_IA32_EVNTSEL3 0x189
#define MSR_IA32_FEATCTL_CSTATE_SMI (1 << 16)
#define MSR_IA32_FEATCTL_LOCK (1 << 0)
#define MSR_IA32_FEATCTL_VMXON (1 << 2)
#define MSR_IA32_FEATCTL_VMXON_SMX (1 << 1)
#define MSR_IA32_FEATURE_CONTROL 0x3a
#define MSR_IA32_FMASK 0xC0000084
#define MSR_IA32_FS_BASE 0xC0000100
#define MSR_IA32_GS_BASE 0xC0000101
#define MSR_IA32_GS_BASE_KERNEL 0xC0000102
#define MSR_IA32_GT_PERF_LIMIT_REASONS 0x6B0
#define MSR_IA32_IA_PERF_LIMIT_REASONS 0x690
#define MSR_IA32_IA_PERF_LIMIT_REASONS_SKL 0x64F
#define MSR_IA32_LASTBRANCHFROMIP 0x1db
#define MSR_IA32_LASTBRANCHTOIP 0x1dc
#define MSR_IA32_LASTINTFROMIP 0x1dd
#define MSR_IA32_LASTINTTOIP 0x1de
#define MSR_IA32_LLC_FLUSHED_RESIDENCY_TIMER 0x61D
#define MSR_IA32_LSTAR 0xC0000082
#define MSR_IA32_MC0_ADDR 0x402
#define MSR_IA32_MC0_CTL 0x400
#define MSR_IA32_MC0_MISC 0x403
#define MSR_IA32_MC0_STATUS 0x401
#define MSR_IA32_MCG_CAP 0x179
#define MSR_IA32_MCG_CTL 0x17b
#define MSR_IA32_MCG_STATUS 0x17a
#define MSR_IA32_MISC_ENABLE 0x1a0
#define MSR_IA32_MPERF 0xE7
#define MSR_IA32_MTRRCAP 0xfe
#define MSR_IA32_MTRR_DEF_TYPE 0x2ff
#define MSR_IA32_MTRR_FIX16K_80000 0x258
#define MSR_IA32_MTRR_FIX16K_A0000 0x259
#define MSR_IA32_MTRR_FIX4K_C0000 0x268
#define MSR_IA32_MTRR_FIX4K_C8000 0x269
#define MSR_IA32_MTRR_FIX4K_D0000 0x26a
#define MSR_IA32_MTRR_FIX4K_D8000 0x26b
#define MSR_IA32_MTRR_FIX4K_E0000 0x26c
#define MSR_IA32_MTRR_FIX4K_E8000 0x26d
#define MSR_IA32_MTRR_FIX4K_F0000 0x26e
#define MSR_IA32_MTRR_FIX4K_F8000 0x26f
#define MSR_IA32_MTRR_FIX64K_00000 0x250
#define MSR_IA32_MTRR_PHYSBASE(n) (0x200 + 2 * (n))
#define MSR_IA32_MTRR_PHYSMASK(n) (0x200 + 2 * (n) + 1)
#define MSR_IA32_P5_MC_ADDR 0
#define MSR_IA32_P5_MC_TYPE 1
#define MSR_IA32_PACKAGE_THERM_INTERRUPT 0x1b2
#define MSR_IA32_PACKAGE_THERM_STATUS 0x1b1
#define MSR_IA32_PERFCTR0 0xc1
#define MSR_IA32_PERFCTR1 0xc2
#define MSR_IA32_PERFCTR3 0xc3
#define MSR_IA32_PERFCTR4 0xc4
#define MSR_IA32_PERF_CTL 0x199
#define MSR_IA32_PERF_FIXED_CTR0 0x309
#define MSR_IA32_PERF_FIXED_CTR_CTRL 0x38D
#define MSR_IA32_PERF_GLOBAL_CTRL 0x38F
#define MSR_IA32_PERF_GLOBAL_OVF_CTRL 0x390
#define MSR_IA32_PERF_GLOBAL_STATUS 0x38E
#define MSR_IA32_PERF_STS 0x198
#define MSR_IA32_PKG_C10_RESIDENCY 0x632
#define MSR_IA32_PKG_C2_RESIDENCY 0x60D
#define MSR_IA32_PKG_C3_RESIDENCY 0x3F8
#define MSR_IA32_PKG_C6_RESIDENCY 0x3F9
#define MSR_IA32_PKG_C7_RESIDENCY 0x3FA
#define MSR_IA32_PKG_C8_RESIDENCY 0x630
#define MSR_IA32_PKG_C9_RESIDENCY 0x631
#define MSR_IA32_PKG_ENERGY_STATUS 0x611
#define MSR_IA32_PKG_POWER_SKU_UNIT 0x606
#define MSR_IA32_PLATFORM_ID 0x17
#define MSR_IA32_PP0_ENERGY_STATUS 0x639
#define MSR_IA32_PP1_ENERGY_STATUS 0x641
#define MSR_IA32_RING_PERF_STATUS 0x621
#define MSR_IA32_STAR 0xC0000081
#define MSR_IA32_SYSENTER_CS 0x174
#define MSR_IA32_SYSENTER_EIP 0x176
#define MSR_IA32_SYSENTER_ESP 0x175
#define MSR_IA32_TSC_AUX 0xC0000103
#define MSR_IA32_TSC_DEADLINE 0x6e0
#define MSR_IA32_UCODE_REV MSR_IA32_BIOS_SIGN_ID
#define MSR_IA32_UCODE_WRITE MSR_IA32_UPDT_TRIG
#define MSR_IA32_UPDT_TRIG 0x79
#define MSR_IA32_VMX_BASE 0x480
#define MSR_IA32_VMX_BASIC MSR_IA32_VMX_BASE
#define MSR_IA32_VMX_CR0_FIXED0 MSR_IA32_VMX_BASE + 6
#define MSR_IA32_VMX_CR0_FIXED1 MSR_IA32_VMX_BASE + 7
#define MSR_IA32_VMX_CR4_FIXED0 MSR_IA32_VMX_BASE + 8
#define MSR_IA32_VMX_CR4_FIXED1 MSR_IA32_VMX_BASE + 9
#define MSR_IA32_VMX_ENTRY_CTLS MSR_IA32_VMX_BASE + 4
#define MSR_IA32_VMX_EPT_VPID_CAP MSR_IA32_VMX_BASE + 12
#define MSR_IA32_VMX_EPT_VPID_CAP_AD_SHIFT 21
#define MSR_IA32_VMX_EXIT_CTLS MSR_IA32_VMX_BASE + 3
#define MSR_IA32_VMX_MISC MSR_IA32_VMX_BASE + 5
#define MSR_IA32_VMX_PINBASED_CTLS MSR_IA32_VMX_BASE + 1
#define MSR_IA32_VMX_PROCBASED_CTLS MSR_IA32_VMX_BASE + 2
#define MSR_IA32_VMX_PROCBASED_CTLS2 MSR_IA32_VMX_BASE + 11
#define MSR_IA32_VMX_TRUE_PINBASED_CTLS MSR_IA32_VMX_BASE + 13
#define MSR_IA32_VMX_TRUE_PROCBASED_CTLS MSR_IA32_VMX_BASE + 14
#define MSR_IA32_VMX_TRUE_VMENTRY_CTLS MSR_IA32_VMX_BASE + 16
#define MSR_IA32_VMX_TRUE_VMEXIT_CTLS MSR_IA32_VMX_BASE + 15
#define MSR_IA32_VMX_VMCS_ENUM MSR_IA32_VMX_BASE + 10
#define MSR_IA32_VMX_VMFUNC MSR_IA32_VMX_BASE + 17
#define MSR_P5_CESR_CC_CLOCK 0x0100   /* Clock Counting (otherwise Event) */
#define MSR_P5_CESR_CC_CPL 0x00C0     /* Count regardless of the CPL */
#define MSR_P5_CESR_CC_CPL012 0x0040  /* Count if the CPL == 0, 1, 2 */
#define MSR_P5_CESR_CC_CPL3 0x0080    /* Count if the CPL == 3 */
#define MSR_P5_CESR_CC_DISABLE 0x0000 /* Disable counter */
#define MSR_P5_CESR_ES_AGI 0x011111   /* Stall because of AGI */
#define MSR_P5_CESR_ES_BANK_CONFLICTS 0x001010  /* Bank conflicts */
#define MSR_P5_CESR_ES_BRANCHE 0x010010         /* Branches */
#define MSR_P5_CESR_ES_BRANCHE_BTB 0x010100     /* Taken branch or BTB Hit */
#define MSR_P5_CESR_ES_BREAK_DR0 0x100011       /* Breakpoint matches on DR0 */
#define MSR_P5_CESR_ES_BREAK_DR1 0x100100       /* Breakpoint matches on DR1 */
#define MSR_P5_CESR_ES_BREAK_DR2 0x100101       /* Breakpoint matches on DR2 */
#define MSR_P5_CESR_ES_BREAK_DR3 0x100110       /* Breakpoint matches on DR3 */
#define MSR_P5_CESR_ES_BTB_HIT 0x010011         /* BTB Hits */
#define MSR_P5_CESR_ES_BUS_CYCLE 0x011000       /* Clocks while bus cycle */
#define MSR_P5_CESR_ES_CACHE_SNOOP_HIT 0x001000 /* Data cache snoop hits */
#define MSR_P5_CESR_ES_CODE_CACHE_MISS 0x001110 /* Code Cache miss */
#define MSR_P5_CESR_ES_CODE_READ 0x001100       /* Code Read */
#define MSR_P5_CESR_ES_CODE_TLB_MISS 0x001101   /* Code TLB miss */
#define MSR_P5_CESR_ES_DATA_CACHE_WB 0x000110   /* Cache lines written back */
#define MSR_P5_CESR_ES_DATA_MEM_READ 0x011010   /* Pipeline waiting for read */
#define MSR_P5_CESR_ES_DATA_READ 0x000000       /* Data Read */
#define MSR_P5_CESR_ES_DATA_READ_MISS 0x000011  /* Data Read Miss */
#define MSR_P5_CESR_ES_DATA_RW 0x101000         /* Data Read or Write */
#define MSR_P5_CESR_ES_DATA_RW_MISS 0x101001    /* Data Read or Write Miss */
#define MSR_P5_CESR_ES_DATA_TLB_MISS 0x000010   /* Data TLB Miss */
#define MSR_P5_CESR_ES_DATA_WRITE 0x000001      /* Data Write */
#define MSR_P5_CESR_ES_DATA_WRITE_MISS 0x000100 /* Data Write Miss */
#define MSR_P5_CESR_ES_EXTERNAL_SNOOP 0x000111  /* External Snoop */
#define MSR_P5_CESR_ES_FLOP 0x100010            /* Floating Point operations */
#define MSR_P5_CESR_ES_FULL_WRITE_BUF 0x011001  /* Clocks while full wrt buf */
#define MSR_P5_CESR_ES_HARDWARE_IT 0x100111     /* Hardware interrupts */
#define MSR_P5_CESR_ES_HIT_EM 0x000101          /* Write (hit) to M|E state */
#define MSR_P5_CESR_ES_INSTRUCTION 0x010110     /* Instruction executed */
#define MSR_P5_CESR_ES_INSTRUCTION_V 0x010111   /* Inst. executed (v-pipe) */
#define MSR_P5_CESR_ES_IO_CYCLE 0x011101        /* I/O Read or Write cycles */
#define MSR_P5_CESR_ES_LOCKED_CYCLE 0x011100    /* Locked bus cycles */
#define MSR_P5_CESR_ES_MEM_ACCESS_PIPE 0x001001 /* mem access both pipes */
#define MSR_P5_CESR_ES_MISALIGNED 0x001011      /* Misaligned Memory or I/O */
#define MSR_P5_CESR_ES_NON_CACHEABLE 0x011110   /* Non-cacheable Mem. read */
#define MSR_P5_CESR_ES_PIPELINE_FLUSH 0x010101  /* Pipeline Flushes */
#define MSR_P5_CESR_ES_SEGMENT_LOADED 0x001111  /* Any segment reg. loaded */
#define MSR_P5_CESR_ES_WRITE_EM 0x011011        /* Stall on write E|M state */
#define MSR_PLATFORM_INFO 0xce



/*!BEGIN libc/nexgen32e/nexgen32e.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_NEXGEN32E_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern long kHalfCache3;

void imapxlatab(void *);
void insertionsort(int32_t *, size_t);

int64_t div10int64(int64_t) libcesque pureconst;
int64_t div100int64(int64_t) libcesque pureconst;
int64_t div1000int64(int64_t) libcesque pureconst;
int64_t div10000int64(int64_t) libcesque pureconst;
int64_t div1000000int64(int64_t) libcesque pureconst;
int64_t div1000000000int64(int64_t) libcesque pureconst;

int64_t rem10int64(int64_t) libcesque pureconst;
int64_t rem100int64(int64_t) libcesque pureconst;
int64_t rem1000int64(int64_t) libcesque pureconst;
int64_t rem10000int64(int64_t) libcesque pureconst;
int64_t rem1000000int64(int64_t) libcesque pureconst;
int64_t rem1000000000int64(int64_t) libcesque pureconst;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/nt2sysv.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_NT2SYSV_H_


/*!BEGIN libc/nexgen32e/trampoline.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_TRAMPOLINE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define TRAMPOLINE(FUNCTION, THUNK)   \
  ({                                  \
    typeof(FUNCTION) *Tramp;          \
    asm(".section .text.trampoline\n" \
        "183:\n\t"                    \
        "mov\t%1,%%eax\n\t"           \
        "jmp\t" #THUNK "\n\t"         \
        ".previous\n\t"               \
        "mov\t$183b,%k0"              \
        : "=r"(Tramp)                 \
        : "i"(FUNCTION));             \
    Tramp;                            \
  })

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Creates function to thunk FUNCTION from MSX64 to System V ABI.
 *
 * This macro should be used when specifying callbacks in the WIN32 API.
 */
#define NT2SYSV(FUNCTION) TRAMPOLINE(FUNCTION, __nt2sysv)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/rdtscp.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_RDTSCP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define TSC_AUX_CORE(MSR) ((MSR)&0xfff)
#define TSC_AUX_NODE(MSR) (((MSR) >> 12) & 0xfff)

/**
 * Reads CPU timestamp counter and IA32_TSC_AUX.
 *
 * This macro inhibits compiler magic.
 * This macro does not inhibit CPU magic.
 *
 * @see X86_HAVE(RDTSCP)
 */
#define rdtscp(OPT_OUT_IA32_TSC_AUX)               \
  ({                                               \
    uint32_t Ecx, *EcxOut;                         \
    uint64_t Rax, Rcx, Rdx;                        \
    asm volatile("rdtscp"                          \
                 : "=a"(Rax), "=c"(Ecx), "=d"(Rdx) \
                 : /* no inputs */                 \
                 : "memory");                      \
    EcxOut = (OPT_OUT_IA32_TSC_AUX);               \
    if (EcxOut) *EcxOut = Ecx;                     \
    Rdx << 32 | Rax;                               \
  })

/**
 * Reads timestamp counter auxiliary model specific register value.
 */
#define rdpid()                                                           \
  ({                                                                      \
    bool Ok;                                                              \
    long Msr;                                                             \
    Ok = false;                                                           \
    if (X86_HAVE(RDPID)) {                                                \
      asm volatile("rdpid\t%0" : "=r"(Msr) : /* no inputs */ : "memory"); \
      Ok = true;                                                          \
    } else if (IsLinux()) {                                               \
      asm volatile(ZFLAG_ASM("lsl\t%2,%1")                                \
                   : ZFLAG_CONSTRAINT(Ok), "=r"(Msr)                      \
                   : "r"(0x7b)                                            \
                   : "memory");                                           \
    }                                                                     \
    if (!Ok && X86_HAVE(RDTSCP)) {                                        \
      asm volatile("rdtscp"                                               \
                   : "=c"(Msr)                                            \
                   : /* no inputs */                                      \
                   : "eax", "edx", "memory");                             \
      Ok = true;                                                          \
    }                                                                     \
    if (!Ok) {                                                            \
      Msr = -1;                                                           \
    }                                                                     \
    Msr;                                                                  \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/slowcall.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_SLOWCALL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define slowcall(fn, arg1, arg2, arg3, arg4, arg5, arg6)                \
  ({                                                                    \
    void *ax;                                                           \
    asm volatile("push\t%7\n\t"                                         \
                 "push\t%6\n\t"                                         \
                 "push\t%5\n\t"                                         \
                 "push\t%4\n\t"                                         \
                 "push\t%3\n\t"                                         \
                 "push\t%2\n\t"                                         \
                 "push\t%1\n\t"                                         \
                 "call\tslowcall"                                       \
                 : "=a"(ax)                                             \
                 : "g"(fn), "g"(arg1), "g"(arg2), "g"(arg3), "g"(arg4), \
                   "g"(arg5), "g"(arg6)                                 \
                 : "memory");                                           \
    ax;                                                                 \
  })

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/stackframe.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_STACKFRAME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct StackFrame {
  struct StackFrame *next;
  intptr_t addr;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/tzcnt.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_TZCNT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

unsigned tzcnt(unsigned) libcesque pureconst;
unsigned long tzcntl(unsigned long) libcesque pureconst;

#define tzcnt(X)                                           \
  ({                                                       \
    typeof(X) Res;                                         \
    if (X86_HAVE(BMI)) {                                   \
      /* amd piledriver+ (a.k.a. bdver1) c. 2011 */        \
      /* intel haswell+ c. 2013 */                         \
      asm("tzcnt\t%1,%0" : "=r,r"(Res) : "r,m"(X) : "cc"); \
    } else {                                               \
      Res = (tzcnt)(X);                                    \
    }                                                      \
    Res;                                                   \
  })

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nexgen32e/x86info.h */

#define COSMOPOLITAN_LIBC_NEXGEN32E_X86INFO_H_

#define kX86CpuStepping    ((KCPUIDS(1H, EAX) >> 0) & 15)
#define kX86CpuModelid     ((KCPUIDS(1H, EAX) >> 4) & 15)
#define kX86CpuFamilyid    ((KCPUIDS(1H, EAX) >> 8) & 15)
#define kX86CpuType        ((KCPUIDS(1H, EAX) >> 12) & 3)
#define kX86CpuExtmodelid  ((KCPUIDS(1H, EAX) >> 16) & 15)
#define kX86CpuExtfamilyid ((KCPUIDS(1H, EAX) >> 20) & 255)

#define kX86CpuFamily \
  (kX86CpuFamilyid + (kX86CpuFamily == 15 ? kX86CpuExtfamilyid : 0))

#define kX86CpuModel \
  (kX86CpuModelid |  \
   (kX86CpuFamily == 6 || kX86CpuFamily == 15 ? kX86CpuExtmodelid : 0) << 4)

#define kX86ProcessorModelKey                                                 \
  (kX86CpuExtfamilyid << 12 | kX86CpuFamilyid << 8 | kX86CpuExtmodelid << 4 | \
   kX86CpuModelid)

#define X86_MARCH_UNKNOWN        0
#define X86_MARCH_CORE2          1
#define X86_MARCH_NEHALEM        2
#define X86_MARCH_WESTMERE       3
#define X86_MARCH_SANDYBRIDGE    4
#define X86_MARCH_IVYBRIDGE      5
#define X86_MARCH_HASWELL        6
#define X86_MARCH_BROADWELL      7
#define X86_MARCH_SKYLAKE        8
#define X86_MARCH_KABYLAKE       9
#define X86_MARCH_CANNONLAKE     10
#define X86_MARCH_ICELAKE        11
#define X86_MARCH_TIGERLAKE      12
#define X86_MARCH_BONNELL        13
#define X86_MARCH_SALTWELL       14
#define X86_MARCH_SILVERMONT     15
#define X86_MARCH_AIRMONT        16
#define X86_MARCH_GOLDMONT       17
#define X86_MARCH_GOLDMONTPLUS   18
#define X86_MARCH_TREMONT        19
#define X86_MARCH_KNIGHTSLANDING 20
#define X86_MARCH_KNIGHTSMILL    21

#define X86_GRADE_UNKNOWN   0
#define X86_GRADE_APPLIANCE 1
#define X86_GRADE_MOBILE    2
#define X86_GRADE_TABLET    3
#define X86_GRADE_DESKTOP   4
#define X86_GRADE_CLIENT    5
#define X86_GRADE_DENSITY   6
#define X86_GRADE_SERVER    7
#define X86_GRADE_SCIENCE   8

struct X86ProcessorModel {
  short key;
  unsigned char march;
  unsigned char grade;
};

extern const size_t kX86ProcessorModelCount;
extern const struct X86ProcessorModel kX86ProcessorModels[];

const struct X86ProcessorModel *getx86processormodel(short) nosideeffect;



/*!BEGIN libc/nt/enum/accessmask.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_ACCESSMASK_H_

/**
 * Can also be described as follows:
 *
 *   struct NtAccessMask {
 *     union {
 *       uint32_t value;
 *       struct {
 *         uint16_t SpecificRights;
 *         unsigned char StandardRights;
 *         unsigned AccessSystemAcl : 1;
 *         unsigned Reserved : 3;
 *         unsigned GenericAll : 1;
 *         unsigned GenericExecute : 1;
 *         unsigned GenericWrite : 1;
 *         unsigned GenericRead : 1;
 *       };
 *     };
 *   };
 */
#define kNtGenericRead 0x80000000u
#define kNtGenericWrite 0x40000000u
#define kNtGenericExecute 0x20000000u
#define kNtGenericAll 0x10000000u
#define kNtDelete 0x00010000u
#define kNtReadControl 0x00020000u
#define kNtWriteDac 0x00040000u
#define kNtWriteOwner 0x00080000u
#define kNtSynchronize 0x00100000u
#define kNtStandardRightsRequired 0x000F0000u
#define kNtStandardRightsRead kNtReadControl
#define kNtStandardRightsWrite kNtReadControl
#define kNtStandardRightsExecute kNtReadControl
#define kNtStandardRightsAll 0x001F0000u
#define kNtSpecificRightsAll 0x0000FFFFu
#define kNtAccessSystemSecurity 0x01000000u
#define kNtMaximumAllowed 0x02000000u
#define kNtFileReadData 0x0001u
#define kNtFileListDirectory 0x0001u
#define kNtFileWriteData 0x0002u
#define kNtFileAddFile 0x0002u
#define kNtFileAppendData 0x0004u
#define kNtFileAddSubdirectory 0x0004u
#define kNtFileCreatePipeInstance 0x0004u
#define kNtFileReadEa 0x0008u
#define kNtFileWriteEa 0x0010u
#define kNtFileExecute 0x0020u
#define kNtFileTraverse 0x0020u
#define kNtFileDeleteChild 0x0040u
#define kNtFileReadAttributes 0x0080u
#define kNtFileWriteAttributes 0x0100u
#define kNtFileAllAccess (kNtStandardRightsRequired | kNtSynchronize | 0x1FFu)
#define kNtFileGenericRead                                           \
  (kNtStandardRightsRead | kNtFileReadData | kNtFileReadAttributes | \
   kNtFileReadEa | kNtSynchronize)
#define kNtFileGenericWrite                                             \
  (kNtStandardRightsWrite | kNtFileWriteData | kNtFileWriteAttributes | \
   kNtFileWriteEa | kNtFileAppendData | kNtSynchronize)
#define kNtFileGenericExecute                                          \
  (kNtStandardRightsExecute | kNtFileReadAttributes | kNtFileExecute | \
   kNtSynchronize)
#define kNtTokenAssignPrimary 0x0001u
#define kNtTokenDuplicate 0x0002u
#define kNtTokenImpersonate 0x0004u
#define kNtTokenQuery 0x0008u
#define kNtTokenQuerySource 0x0010u
#define kNtTokenAdjustPrivileges 0x0020u
#define kNtTokenAdjustGroups 0x0040u
#define kNtTokenAdjustDefault 0x0080u
#define kNtTokenAdjustSessionid 0x0100u
#define kNtTokenAllAccessP                                                 \
  (kNtStandardRightsRequired | kNtTokenAssignPrimary | kNtTokenDuplicate | \
   kNtTokenImpersonate | kNtTokenQuery | kNtTokenQuerySource |             \
   kNtTokenAdjustPrivileges | kNtTokenAdjustGroups | kNtTokenAdjustDefault)
#define kNtTokenAllAccess kNtTokenAllAccessP | kNtTokenAdjustSessionid
#define kNtTokenRead kNtStandardRightsRead | kNtTokenQuery
#define kNtTokenWrite                                                         \
  (kNtStandardRightsWrite | kNtTokenAdjustPrivileges | kNtTokenAdjustGroups | \
   kNtTokenAdjustDefault)
#define kNtTokenExecute kNtStandardRightsExecute
#define kNtTokenTrustConstraintMask \
  (kNtStandardRightsRead | kNtTokenQuery | kNtTokenQuerySource)
#define kNtTokenAccessPseudoHandleWin8 kNtTokenQuery | kNtTokenQuerySource
#define kNtTokenAccessPseudoHandle kNtTokenAccessPseudoHandleWin8



/*!BEGIN libc/nt/enum/afd.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_AFD_H_

#define kNtAfdPollReceive          0x0001
#define kNtAfdPollReceiveExpedited 0x0002
#define kNtAfdPollSend             0x0004
#define kNtAfdPollDisconnect       0x0008
#define kNtAfdPollAbort            0x0010
#define kNtAfdPollLocalClose       0x0020
#define kNtAfdPollAccept           0x0080
#define kNtAfdPollConnectFail      0x0100



/*!BEGIN libc/nt/enum/bitblt.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_BITBLT_H_

#define kNtSrccopy     0x00CC0020u /* src */
#define kNtSrcpaint    0x00EE0086u /* src | dst */
#define kNtSrcand      0x008800C6u /* src & dst */
#define kNtSrcinvert   0x00660046u /* src ^ dst */
#define kNtSrcerase    0x00440328u /* src & ~dst */
#define kNtNotsrccopy  0x00330008u /* ~src */
#define kNtNotsrcerase 0x001100A6u /* ~src & ~dst */
#define kNtMergecopy   0x00C000CAu /* (src & pattern) */
#define kNtMergepaint  0x00BB0226u /* ~src | dst */
#define kNtPatcopy     0x00F00021u /* pat */
#define kNtPatpaint    0x00FB0A09u /* wut */
#define kNtPatinvert   0x005A0049u /* pat ^ dst */
#define kNtDstinvert   0x00550009u /* ~dst */
#define kNtBlackness   0x00000042u /* black */
#define kNtWhiteness   0x00FF0062u /* white */



/*!BEGIN libc/nt/enum/callback.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CALLBACK_H_

#define kNtCallbackChunkFinished 0
#define kNtCallbackStreamSwitch  1



/*!BEGIN libc/nt/enum/color.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_COLOR_H_

#define kNtColorScrollbar               0
#define kNtColorBackground              1
#define kNtColorActivecaption           2
#define kNtColorInactivecaption         3
#define kNtColorMenu                    4
#define kNtColorWindow                  5
#define kNtColorWindowframe             6
#define kNtColorMenutext                7
#define kNtColorWindowtext              8
#define kNtColorCaptiontext             9
#define kNtColorActiveborder            10
#define kNtColorInactiveborder          11
#define kNtColorAppworkspace            12
#define kNtColorHighlight               13
#define kNtColorHighlighttext           14
#define kNtColorBtnface                 15
#define kNtColorBtnshadow               16
#define kNtColorGraytext                17
#define kNtColorBtntext                 18
#define kNtColorInactivecaptiontext     19
#define kNtColorBtnhighlight            20
#define kNtColor3ddkshadow              21
#define kNtColor3dlight                 22
#define kNtColorInfotext                23
#define kNtColorInfobk                  24
#define kNtColorHotlight                26
#define kNtColorGradientactivecaption   27
#define kNtColorGradientinactivecaption 28
#define kNtColorMenuhilight             29
#define kNtColorMenubar                 30



/*!BEGIN libc/nt/enum/computernameformat.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_COMPUTERNAMEFORMAT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtComputerNameNetBios                   0
#define kNtComputerNameDnsHostname               1
#define kNtComputerNameDnsDomain                 2
#define kNtComputerNameDnsFullyQualified         3
#define kNtComputerNamePhysicalNetBios           4
#define kNtComputerNamePhysicalDnsHostname       5
#define kNtComputerNamePhysicalDnsDomain         6
#define kNtComputerNamePhysicalDnsFullyQualified 7
#define kNtComputerName_MAX                      8

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/consolemodeflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CONSOLEMODEFLAGS_H_

/* input mode */
#define kNtEnableProcessedInput 0x0001u
#define kNtEnableLineInput 0x0002u
#define kNtEnableEchoInput 0x0004u
#define kNtEnableWindowInput 0x0008u
#define kNtEnableMouseInput 0x0010u
#define kNtEnableInsertMode 0x0020u
#define kNtEnableQuickEditMode 0x0040u
#define kNtEnableExtendedFlags 0x0080u
#define kNtEnableAutoPosition 0x0100u
#define kNtEnableVirtualTerminalInput 0x0200u

/* output mode */
#define kNtEnableProcessedOutput 0x0001u
#define kNtEnableWrapAtEolOutput 0x0002u
#define kNtEnableVirtualTerminalProcessing 0x0004u
#define kNtDisableNewlineAutoReturn 0x0008u
#define kNtEnableLvbGridWorldwide 0x0010u



/*!BEGIN libc/nt/enum/consoleselectionflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CONSOLESELECTIONFLAGS_H_

#define kNtConsoleNoSelection 0x0000u
#define kNtConsoleSelectionInProgress 0x0001u
#define kNtConsoleSelectionNotEmpty 0x0002u
#define kNtConsoleMouseSelection 0x0004u
#define kNtConsoleMouseDown 0x0008u



/*!BEGIN libc/nt/enum/copyfile.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_COPYFILE_H_

#define kNtCopyFileFailIfExists              0x00000001
#define kNtCopyFileRestartable               0x00000002
#define kNtCopyFileOpenSourceForWrite        0x00000004
#define kNtCopyFileAllowDecryptedDestination 0x00000008
#define kNtCopyFileCopySymlink               0x00000800
#define kNtCopyFileNoBuffering               0x00001000
#define kNtCopyFileRequestSecurityPrivileges 0x00002000 /* Win8+ */
#define kNtCopyFileResumeFromPause           0x00004000 /* Win8+ */
#define kNtCopyFileRequestSecurityPrivileges 0x00002000 /* Win8+ */
#define kNtCopyFileNoOffload                 0x00040000 /* Win8+ */
#define kNtCopyFileIgnoreEdpBlock            0x00400000 /* Win10+ */
#define kNtCopyFileIgnoreSourceEncryption    0x00800000 /* Win10+ */



/*!BEGIN libc/nt/enum/creationdisposition.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CREATIONDISPOSITION_H_

#define kNtCreateNew 1
#define kNtCreateAlways 2
#define kNtOpenExisting 3
#define kNtOpenAlways 4
#define kNtTruncateExisting 5



/*!BEGIN libc/nt/enum/cs.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CS_H_

#define kNtCsVredraw         0x00000001
#define kNtCsHredraw         0x00000002
#define kNtCsDblclks         0x00000008
#define kNtCsOwndc           0x00000020
#define kNtCsClassdc         0x00000040
#define kNtCsParentdc        0x00000080
#define kNtCsNoclose         0x00000200
#define kNtCsSavebits        0x00000800
#define kNtCsBytealignclient 0x00001000
#define kNtCsBytealignwindow 0x00002000
#define kNtCsGlobalclass     0x00004000
#define kNtCsIme             0x00010000
#define kNtCsDropshadow      0x00020000



/*!BEGIN libc/nt/enum/ctrlevent.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CTRLEVENT_H_

#define kNtCtrlCEvent 0      /* SIGINT */
#define kNtCtrlBreakEvent 1  /* SIGQUIT */
#define kNtCtrlCloseEvent 2  /* SIGHUP */
#define kNtCtrlLogoffEvent 5 /* SIGTERM */
#define kNtCtrlShutdownEvent 6



/*!BEGIN libc/nt/enum/cw.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_CW_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtCwUsedefault ((int)0x80000000)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/dialogresult.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_DIALOGRESULT_H_

#define kNtIdok       1
#define kNtIdcancel   2
#define kNtIdabort    3
#define kNtIdretry    4
#define kNtIdignore   5
#define kNtIdyes      6
#define kNtIdno       7
#define kNtIdclose    8
#define kNtIdhelp     9
#define kNtIdtryagain 10
#define kNtIdcontinue 11



/*!BEGIN libc/nt/enum/errormodeflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_ERRORMODEFLAGS_H_

#define kNtErrorModeDefault      0x0
#define kNtSemFailcriticalerrors 0x1
#define kNtSemNogpfaulterrorbox  0x2
#define kNtSemNoopenfileerrorbox 0x8000



/*!BEGIN libc/nt/enum/event.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_EVENT_H_

#define kNtEventSystemSound            0x0001
#define kNtEventSystemAlert            0x0002
#define kNtEventSystemForeground       0x0003
#define kNtEventSystemMenustart        0x0004
#define kNtEventSystemMenuend          0x0005
#define kNtEventSystemMenupopupstart   0x0006
#define kNtEventSystemMenupopupend     0x0007
#define kNtEventSystemCapturestart     0x0008
#define kNtEventSystemCaptureend       0x0009
#define kNtEventSystemMovesizestart    0x000A
#define kNtEventSystemMovesizeend      0x000B
#define kNtEventSystemContexthelpstart 0x000C
#define kNtEventSystemContexthelpend   0x000D
#define kNtEventSystemDragdropstart    0x000E
#define kNtEventSystemDragdropend      0x000F
#define kNtEventSystemDialogstart      0x0010
#define kNtEventSystemDialogend        0x0011
#define kNtEventSystemScrollingstart   0x0012
#define kNtEventSystemScrollingend     0x0013
#define kNtEventSystemSwitchstart      0x0014
#define kNtEventSystemSwitchend        0x0015
#define kNtEventSystemMinimizestart    0x0016
#define kNtEventSystemMinimizeend      0x0017

#define kNtEventConsoleCaret            0x4001
#define kNtEventConsoleUpdateRegion     0x4002
#define kNtEventConsoleUpdateSimple     0x4003
#define kNtEventConsoleUpdateScroll     0x4004
#define kNtEventConsoleLayout           0x4005
#define kNtEventConsoleStartApplication 0x4006
#define kNtEventConsoleEndApplication   0x4007

#define kNtEventObjectCreate            0x8000
#define kNtEventObjectDestroy           0x8001
#define kNtEventObjectShow              0x8002
#define kNtEventObjectHide              0x8003
#define kNtEventObjectReorder           0x8004
#define kNtEventObjectFocus             0x8005
#define kNtEventObjectSelection         0x8006
#define kNtEventObjectSelectionadd      0x8007
#define kNtEventObjectSelectionremove   0x8008
#define kNtEventObjectSelectionwithin   0x8009
#define kNtEventObjectStatechange       0x800A
#define kNtEventObjectLocationchange    0x800B
#define kNtEventObjectNamechange        0x800C
#define kNtEventObjectDescriptionchange 0x800D
#define kNtEventObjectValuechange       0x800E
#define kNtEventObjectParentchange      0x800F
#define kNtEventObjectHelpchange        0x8010
#define kNtEventObjectDefactionchange   0x8011
#define kNtEventObjectAcceleratorchange 0x8012



/*!BEGIN libc/nt/enum/eventtype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_EVENTTYPE_H_

#define kNtNotificationEvent    0
#define kNtSynchronizationEvent 1



/*!BEGIN libc/nt/enum/exceptionhandleractions.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_EXCEPTIONHANDLERACTIONS_H_

#define kNtExceptionExecuteHandler 0x1u
#define kNtExceptionContinueExecution 0xffffffffu
#define kNtExceptionContinueSearch 0x0u



/*!BEGIN libc/nt/enum/fileflagandattributes.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEFLAGANDATTRIBUTES_H_

/**
 * MS-DOS File Attributes.
 *
 * @see GetFileInformationByHandle()
 * @see libc/sysv/consts.sh
 */
#define kNtFileAttributeReadonly 0x00000001u
#define kNtFileAttributeHidden 0x00000002u
#define kNtFileAttributeSystem 0x00000004u
#define kNtFileAttributeVolumelabel 0x00000008u
#define kNtFileAttributeDirectory 0x00000010u
#define kNtFileAttributeArchive 0x00000020u

/**
 * NT File Attributes.
 */
#define kNtFileAttributeDevice 0x00000040u
#define kNtFileAttributeNormal 0x00000080u
#define kNtFileAttributeTemporary 0x00000100u
#define kNtFileAttributeSparseFile 0x00000200u
#define kNtFileAttributeReparsePoint 0x00000400u
#define kNtFileAttributeCompressed 0x00000800u
#define kNtFileAttributeOffline 0x00001000u
#define kNtFileAttributeNotContentIndexed 0x00002000u
#define kNtFileAttributeEncrypted 0x00004000u

/**
 * NT File Flags.
 */
#define kNtFileFlagWriteThrough 0x80000000u
#define kNtFileFlagOverlapped 0x40000000u
#define kNtFileFlagNoBuffering 0x20000000u
#define kNtFileFlagRandomAccess 0x10000000u
#define kNtFileFlagSequentialScan 0x08000000u
#define kNtFileFlagDeleteOnClose 0x04000000u
#define kNtFileFlagBackupSemantics 0x02000000u
#define kNtFileFlagPosixSemantics 0x01000000u
#define kNtFileFlagOpenReparsePoint 0x00200000u /* or symlink */
#define kNtFileFlagOpenNoRecall 0x00100000u
#define kNtFileFlagFirstPipeInstance 0x00080000u



/*!BEGIN libc/nt/enum/fileinfobyhandleclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEINFOBYHANDLECLASS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtFileBasicInfo 0        /* struct NtFileBasicInformation */
#define kNtFileStandardInfo 1     /* struct NtFileStandardInformation */
#define kNtFileNameInfo 2         /* struct NtFileNameInformation */
#define kNtFileStreamInfo 7       /* struct NtFileStreamInformation */
#define kNtFileCompressionInfo 8  /* struct NtFileCompressionInfo */
#define kNtFileAttributeTagInfo 9 /* struct NtFileAttributeTagInformation */
#define kNtFileIdBothDirectoryInfo 10
#define kNtFileIdBothDirectoryRestartInfo 11
#define kNtFileRemoteProtocolInfo 13
#define kNtFileFullDirectoryInfo 14 /* NtFileFullDirectoryInformation */
#define kNtFileFullDirectoryRestartInfo 15
#define kNtFileStorageInfo 16                /* win8+ */
#define kNtFileAlignmentInfo 17              /* win8+ */
#define kNtFileIdInfo 18                     /* win8+ */
#define kNtFileIdExtdDirectoryInfo 19        /* win8+ */
#define kNtFileIdExtdDirectoryRestartInfo 20 /* win8+ */

/* #define kNtFileRenameInfo 4 */
/* #define kNtFileDispositionInfo 5 */
/* #define kNtFileAllocationInfo 6 */
/* #define kNtFileEndOfFileInfo 7 */
/* #define kNtFileIoPriorityHintInfo 13 */
/* #define kNtFileDispositionInfoEx 22          /\* win10+ *\/ */
/* #define kNtFileRenameInfoEx 23               /\* win10+ *\/ */

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/fileinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEINFORMATIONCLASS_H_

#define kNtFileDirectoryInformation 1 /*→ struct NtFileDirectoryInformation */
#define kNtFileFullDirectoryInformation 2 /*→ etc. */
#define kNtFileBothDirectoryInformation 3
#define kNtFileBasicInformation 4
#define kNtFileStandardInformation 5
#define kNtFileInternalInformation 6
#define kNtFileEaInformation 7
#define kNtFileAccessInformation 8
#define kNtFileNameInformation 9
#define kNtFileRenameInformation 10
#define kNtFileLinkInformation 11
#define kNtFileNamesInformation 12
#define kNtFileDispositionInformation 13
#define kNtFilePositionInformation 14
#define kNtFileFullEaInformation 15
#define kNtFileModeInformation 16
#define kNtFileAlignmentInformation 17
#define kNtFileAllInformation 18
#define kNtFileAllocationInformation 19
#define kNtFileEndOfFileInformation 20
#define kNtFileAlternateNameInformation 21
#define kNtFileStreamInformation 22
#define kNtFilePipeInformation 23
#define kNtFilePipeLocalInformation 24
#define kNtFilePipeRemoteInformation 25
#define kNtFileMailslotQueryInformation 26
#define kNtFileMailslotSetInformation 27
#define kNtFileCompressionInformation 28
#define kNtFileObjectIdInformation 29
#define kNtFileCompletionInformation 30
#define kNtFileMoveClusterInformation 31
#define kNtFileQuotaInformation 32
#define kNtFileReparsePointInformation 33
#define kNtFileNetworkOpenInformation 34
#define kNtFileAttributeTagInformation 35
#define kNtFileTrackingInformation 36
#define kNtFileIdBothDirectoryInformation 37
#define kNtFileIdFullDirectoryInformation 38
#define kNtFileValidDataLengthInformation 39
#define kNtFileShortNameInformation 40
#define kNtFileInformation_MAX 40



/*!BEGIN libc/nt/enum/filelockflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILELOCKFLAGS_H_

#define kNtLockfileFailImmediately 1
#define kNtLockfileExclusiveLock   2



/*!BEGIN libc/nt/enum/filemapflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEMAPFLAGS_H_

#define kNtFileMapCopy           0x00000001u
#define kNtFileMapWrite          0x00000002u
#define kNtFileMapRead           0x00000004u
#define kNtFileMapExecute        0x00000020u
#define kNtFileMapReserve        0x80000000u
#define kNtFileMapTargetsInvalid 0x40000000u
#define kNtFileMapLargePages     0x20000000u



/*!BEGIN libc/nt/enum/filemovemethod.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILEMOVEMETHOD_H_

#define kNtFileBegin   0
#define kNtFileCurrent 1
#define kNtFileEnd     2



/*!BEGIN libc/nt/enum/filesharemode.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILESHAREFLAGS_H_

#define kNtFileShareExclusive 0x00000000u
#define kNtFileShareRead 0x00000001u
#define kNtFileShareWrite 0x00000002u
#define kNtFileShareDelete 0x00000004u



/*!BEGIN libc/nt/enum/filetype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FILETYPE_H_

#define kNtFileTypeUnknown 0x0000
#define kNtFileTypeDisk    0x0001 /* @see S_ISBLK() */
#define kNtFileTypeChar    0x0002 /* @see S_ISCHR() */
#define kNtFileTypePipe    0x0003 /* @see S_ISFIFO() */
#define kNtFileTypeRemote  0x8000 /* unused -MSDN */



/*!BEGIN libc/nt/enum/fillattribute.h */

#define COSMOPOLITAN_LIBC_NT_NTFILLATTRIBUTE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtForegroundBlue 0x0001
#define kNtForegroundGreen 0x0002
#define kNtForegroundRed 0x0004
#define kNtForegroundIntensity 0x0008
#define kNtBackgroundBlue 0x0010
#define kNtBackgroundGreen 0x0020
#define kNtBackgroundRed 0x0040
#define kNtBackgroundIntensity 0x0080

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/findexinfolevels.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FINDEXINFOLEVELS_H_

#define kNtFindExInfoStandard     0
#define kNtFindExInfoBasic        1
#define kNtFindExInfoMaxInfoLevel 2



/*!BEGIN libc/nt/enum/findexsearchops.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FINDEXSEARCHOPS_H_

#define kNtFindExSearchNameMatch          0
#define kNtFindExSearchLimitToDirectories 1
#define kNtFindExSearchLimitToDevices     2
#define kNtFindExSearchMaxSearchOp        3



/*!BEGIN libc/nt/enum/formatmessageflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FORMATMESSAGEFLAGS_H_

#define kNtFormatMessageAllocateBuffer 0x100
#define kNtFormatMessageIgnoreInserts  0x200
#define kNtFormatMessageFromString     0x400
#define kNtFormatMessageFromHmodule    0x800
#define kNtFormatMessageFromSystem     0x1000
#define kNtFormatMessageArgumentArray  0x2000
#define kNtFormatMessageMaxWidthMask   0xff



/*!BEGIN libc/nt/enum/fsctl.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FSCTL_H_

#define kNtFsctlDisableLocalBuffering 0x000902B8u
#define kNtFsctlFilePrefetch 0x00090120u
#define kNtFsctlFilesystemGetStatistics 0x00090060u
#define kNtFsctlGetCompression 0x0009003Cu
#define kNtFsctlGetNtfsFileRecord 0x00090068u
#define kNtFsctlGetNtfsVolumeData 0x00090064u
#define kNtFsctlQueryAllocatedRanges 0x000940CFu
#define kNtFsctlScrubData 0x000902B0u
#define kNtFsctlSetCompression 0x0009C040u
#define kNtFsctlSetSparse 0x000900C4u
#define kNtFsctlSetZeroData 0x000980C8u



/*!BEGIN libc/nt/enum/fsinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_FSINFORMATIONCLASS_H_

#define kNtFileFsVolumeInformation 1
#define kNtFileFsLabelInformation 2
#define kNtFileFsSizeInformation 3
#define kNtFileFsDeviceInformation 4
#define kNtFileFsAttributeInformation 5
#define kNtFileFsControlInformation 6
#define kNtFileFsFullSizeInformation 7
#define kNtFileFsObjectIdInformation 8
#define kNtFileFsDriverPathInformation 9
#define kNtFileFsInformation_MAX 10



/*!BEGIN libc/nt/enum/getfileexinfolevels.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_GETFILEEXINFOLEVELS_H_

#define kNtGetFileExInfoStandard 0



/*!BEGIN libc/nt/enum/ht.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_HT_H_

#define kNtHterror       -2
#define kNtHttransparent -1
#define kNtHtnowhere     0
#define kNtHtclient      1
#define kNtHtcaption     2
#define kNtHtsysmenu     3
#define kNtHtgrowbox     4
#define kNtHtsize        kNtHtgrowbox
#define kNtHtmenu        5
#define kNtHthscroll     6
#define kNtHtvscroll     7
#define kNtHtminbutton   8
#define kNtHtmaxbutton   9
#define kNtHtleft        10
#define kNtHtright       11
#define kNtHttop         12
#define kNtHttopleft     13
#define kNtHttopright    14
#define kNtHtbottom      15
#define kNtHtbottomleft  16
#define kNtHtbottomright 17
#define kNtHtborder      18
#define kNtHtreduce      kNtHtminbutton
#define kNtHtzoom        kNtHtmaxbutton
#define kNtHtsizefirst   kNtHtleft
#define kNtHtsizelast    kNtHtbottomright
#define kNtHtobject      19
#define kNtHtclose       20
#define kNtHthelp        21



/*!BEGIN libc/nt/enum/idc.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IDC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define kNtIdcArrow    ((const char16_t *)32512)
#define kNtIdcIbeam    ((const char16_t *)32513)
#define kNtIdcWait     ((const char16_t *)32514)
#define kNtIdcCross    ((const char16_t *)32515)
#define kNtIdcUparrow  ((const char16_t *)32516)
#define kNtIdcSizenwse ((const char16_t *)32642)
#define kNtIdcSizenesw ((const char16_t *)32643)
#define kNtIdcSizewe   ((const char16_t *)32644)
#define kNtIdcSizens   ((const char16_t *)32645)
#define kNtIdcSizeall  ((const char16_t *)32646)
#define kNtIdcNo       ((const char16_t *)32648)
#define kNtIdcHand     ((const char16_t *)32649)
#define kNtIdcHelp     ((const char16_t *)32651)
#define kNtIdcPin      ((const char16_t *)32671)
#define kNtIdcPerson   ((const char16_t *)32672)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/imageauxsymboltype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IMAGEAUXSYMBOLTYPE_H_

#define kNtImageAuxSymbolTypeTokenDef 1



/*!BEGIN libc/nt/enum/importobjectnametype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IMPORTOBJECTNAMETYPE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

enum NtImportObjectNameType {
  IMPORT_OBJECT_ORDINAL,
  IMPORT_OBJECT_NAME,
  IMPORT_OBJECT_NAME_NO_PREFIX,
  IMPORT_OBJECT_NAME_UNDECORATE,
  IMPORT_OBJECT_NAME_EXPORTAS
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/importobjecttype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IMPORTOBJECTTYPE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

enum NtImportObjectType {
  IMPORT_OBJECT_CODE,
  IMPORT_OBJECT_DATA,
  IMPORT_OBJECT_CONST
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/ioctl.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_IOCTL_H_

#define kNtIoctlDiskGetDriveGeometry 0x00070000u
#define kNtIoctlAfdPoll              0x00012024u



/*!BEGIN libc/nt/enum/jobobjectinfoclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_JOBOBJECTINFOCLASS_H_

#define kNtJobObjectBasicAccountingInformation         1
#define kNtJobObjectBasicLimitInformation              2
#define kNtJobObjectBasicProcessIdList                 3
#define kNtJobObjectBasicUIRestrictions                4
#define kNtJobObjectSecurityLimitInformation           5
#define kNtJobObjectEndOfJobTimeInformation            6
#define kNtJobObjectAssociateCompletionPortInformation 7
#define kNtJobObjectBasicAndIoAccountingInformation    8
#define kNtJobObjectExtendedLimitInformation           9
#define kNtJobObjectJobSetInformation                  10



/*!BEGIN libc/nt/enum/keyaccess.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_KEYACCESS_H_

#define kNtKeyRead      0x00020019
#define kNtKeyWrite     0x00020006
#define kNtKeyExecute   0x00020019
#define kNtKeyAllAccess 0x000f003f



/*!BEGIN libc/nt/enum/keyedevent.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_KEYEDEVENT_H_

#define kNtKeyedeventWait 0x00000001u
#define kNtKeyedeventWake 0x00000002u
#define kNtKeyedeventAllAccess \
  (kNtStandardRightsRequired | kNtKeyedeventWait | kNtKeyedeventWake)



/*!BEGIN libc/nt/enum/keyinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_KEYINFORMATIONCLASS_H_

#define kNtKeyBasicInformation 0
#define kNtKeyNodeInformation  1
#define kNtKeyFullInformation  2
#define kNtKeyNameInformation  3



/*!BEGIN libc/nt/enum/kwaitreason.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_KWAITREASON_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtExecutive 0
#define kNtFreePage 1
#define kNtPageIn 2
#define kNtPoolAllocation 3
#define kNtDelayExecution 4
#define kNtSuspended 5
#define kNtUserRequest 6
#define kNtWrExecutive 7
#define kNtWrFreePage 8
#define kNtWrPageIn 9
#define kNtWrPoolAllocation 10
#define kNtWrDelayExecution 11
#define kNtWrSuspended 12
#define kNtWrUserRequest 13
#define kNtWrEventPair 14
#define kNtWrQueue 15
#define kNtWrLpcReceive 16
#define kNtWrLpcReply 17
#define kNtWrVirtualMemory 18
#define kNtWrPageOut 19
#define kNtWrRendezvous 20
#define kNtSpare2 21
#define kNtSpare3 22
#define kNtSpare4 23
#define kNtSpare5 24
#define kNtSpare6 25
#define kNtWrKernel 26
#define kNtMaximumWaitReason 27

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/loadlibrarysearch.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_LOADLIBRARYSEARCH_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtLoadLibrarySearchApplicationDir 0x00000200u
#define kNtLoadLibrarySearchSearchSystem32 0x00000800u
#define kNtLoadLibrarySearchUserDirs       0x00000400u
#define kNtLoadLibrarySearchDefaultDirs    0x00001000u

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/mb.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtMbOk                      0x00000000
#define kNtMbOkcancel                0x00000001
#define kNtMbAbortretryignore        0x00000002
#define kNtMbYesnocancel             0x00000003
#define kNtMbYesno                   0x00000004
#define kNtMbRetrycancel             0x00000005
#define kNtMbCanceltrycontinue       0x00000006
#define kNtMbIconhand                0x00000010
#define kNtMbIconquestion            0x00000020
#define kNtMbIconexclamation         0x00000030
#define kNtMbIconasterisk            0x00000040
#define kNtMbUsericon                0x00000080
#define kNtMbIconwarning             kNtMbIconexclamation
#define kNtMbIconerror               kNtMbIconhand
#define kNtMbIconinformation         kNtMbIconasterisk
#define kNtMbIconstop                kNtMbIconhand
#define kNtMbDefbutton1              0x00000000
#define kNtMbDefbutton2              0x00000100
#define kNtMbDefbutton3              0x00000200
#define kNtMbDefbutton4              0x00000300
#define kNtMbApplmodal               0x00000000
#define kNtMbSystemmodal             0x00001000
#define kNtMbTaskmodal               0x00002000
#define kNtMbHelp                    0x00004000
#define kNtMbNofocus                 0x00008000
#define kNtMbSetforeground           0x00010000
#define kNtMbDefaultDesktopOnly      0x00020000
#define kNtMbTopmost                 0x00040000
#define kNtMbRight                   0x00080000
#define kNtMbRtlreading              0x00100000
#define kNtMbServiceNotification     0x00200000
#define kNtMbServiceNotificationNt3x 0x00040000
#define kNtMbTypemask                0x0000000F
#define kNtMbIconmask                0x000000F0
#define kNtMbDefmask                 0x00000F00
#define kNtMbModemask                0x00003000
#define kNtMbMiscmask                0x0000C000

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/memflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MEMFLAGS_H_

#define kNtMemCommit 0x1000  /* perform physical memory reservation step */
#define kNtMemReserve 0x2000 /* perform virtual memory reservation step */
#define kNtMemDecommit 0x4000
#define kNtMemRelease 0x8000
#define kNtMemFree 0x10000
#define kNtMemPrivate 0x20000
#define kNtMemMapped 0x40000
#define kNtMemReset 0x80000
#define kNtMemTopDown 0x100000
#define kNtMemWriteWatch 0x200000
#define kNtMemPhysical 0x400000
#define kNtMemLargePages 0x20000000
#define kNtMem4mbPages 0x80000000



/*!BEGIN libc/nt/enum/memoryinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MEMORYINFORMATIONCLASS_H_

#define kNtMemoryBasicInformation    0
#define kNtMemoryWorkingSetList      1
#define kNtMemorySectionName         2
#define kNtMemoryBasicVlmInformation 3



/*!BEGIN libc/nt/enum/mf.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MF_H_

#define kNtMfInsert          0x00000000
#define kNtMfChange          0x00000080
#define kNtMfAppend          0x00000100
#define kNtMfDelete          0x00000200
#define kNtMfRemove          0x00001000
#define kNtMfBycommand       0x00000000
#define kNtMfByposition      0x00000400
#define kNtMfSeparator       0x00000800
#define kNtMfEnabled         0x00000000
#define kNtMfGrayed          0x00000001
#define kNtMfDisabled        0x00000002
#define kNtMfUnchecked       0x00000000
#define kNtMfChecked         0x00000008
#define kNtMfUsecheckbitmaps 0x00000200
#define kNtMfString          0x00000000
#define kNtMfBitmap          0x00000004
#define kNtMfOwnerdraw       0x00000100
#define kNtMfPopup           0x00000010
#define kNtMfMenubarbreak    0x00000020
#define kNtMfMenubreak       0x00000040
#define kNtMfUnhilite        0x00000000
#define kNtMfHilite          0x00000080
#define kNtMfDefault         0x00001000
#define kNtMfSysmenu         0x00002000
#define kNtMfHelp            0x00004000
#define kNtMfRightjustify    0x00004000
#define kNtMfMouseselect     0x00008000



/*!BEGIN libc/nt/enum/mk.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MK_H_

#define kNtMkLbutton  0x0001
#define kNtMkRbutton  0x0002
#define kNtMkShift    0x0004
#define kNtMkControl  0x0008
#define kNtMkMbutton  0x0010
#define kNtMkXbutton1 0x0020
#define kNtMkXbutton2 0x0040



/*!BEGIN libc/nt/enum/movefileexflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_MOVEFILEEXFLAGS_H_

#define kNtMovefileReplaceExisting    1
#define kNtMovefileCopyAllowed        2
#define kNtMovefileDelayUntilReboot   4
#define kNtMovefileCreateHardlink     16
#define kNtMovefileFailIfNotTrackable 32
#define kNtMovefileWriteThrough       8



/*!BEGIN libc/nt/enum/objectinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_OBJECTINFORMATIONCLASS_H_

#define kNtObjectBasicInformation 0 /*→ struct NtObjectBasicInformation */
#define kNtObjectNameInformation  1 /*→ etc. */
#define kNtObjectTypeInformation  2
#define kNtObjectAllInformation   3
#define kNtObjectDataInformation  4



/*!BEGIN libc/nt/enum/offerpriority.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_OFFERPRIORITY_H_

/* TODO(jart): Are these values correct? */
#define kNtVmOfferPriorityVeryLow     1 /* 0x00001000? */
#define kNtVmOfferPriorityLow         2 /* 0x00002000? */
#define kNtVmOfferPriorityBelowNormal 3 /* 0x00002000? */
#define kNtVmOfferPriorityNormal      4 /* 0x00002000? */



/*!BEGIN libc/nt/enum/ofn.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_OFN_H_

#define kNtOfnReadonly             0x00000001
#define kNtOfnOverwriteprompt      0x00000002
#define kNtOfnHidereadonly         0x00000004
#define kNtOfnNochangedir          0x00000008
#define kNtOfnShowhelp             0x00000010
#define kNtOfnEnablehook           0x00000020
#define kNtOfnEnabletemplate       0x00000040
#define kNtOfnEnabletemplatehandle 0x00000080
#define kNtOfnNovalidate           0x00000100
#define kNtOfnAllowmultiselect     0x00000200
#define kNtOfnExtensiondifferent   0x00000400
#define kNtOfnPathmustexist        0x00000800
#define kNtOfnFilemustexist        0x00001000
#define kNtOfnCreateprompt         0x00002000
#define kNtOfnShareaware           0x00004000
#define kNtOfnNoreadonlyreturn     0x00008000
#define kNtOfnNotestfilecreate     0x00010000
#define kNtOfnNonetworkbutton      0x00020000
#define kNtOfnNolongnames          0x00040000
#define kNtOfnExplorer             0x00080000
#define kNtOfnNodereferencelinks   0x00100000
#define kNtOfnLongnames            0x00200000
#define kNtOfnEnableincludenotify  0x00400000
#define kNtOfnEnablesizing         0x00800000
#define kNtOfnDontaddtorecent      0x02000000
#define kNtOfnForceshowhidden      0x10000000



/*!BEGIN libc/nt/enum/pageflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PAGEFLAGS_H_

/* Pick One */
#define kNtPageNoaccess 0x01
#define kNtPageReadonly 0x02
#define kNtPageReadwrite 0x04
#define kNtPageWritecopy 0x08
#define kNtPageExecute 0x10
#define kNtPageExecuteRead 0x20
#define kNtPageExecuteReadwrite 0x40
#define kNtPageExecuteWritecopy 0x80
#define kNtPageGuard 0x100
#define kNtPageNocache 0x200
#define kNtPageWritecombine 0x400

/* These may be OR'd */
#define kNtSecReserve 0x4000000
#define kNtSecCommit 0x8000000 /* ←default */
#define kNtSecImage 0x1000000
#define kNtSecImageNoExecute 0x11000000
#define kNtSecLargePages 0x80000000
#define kNtSecNocache 0x10000000
#define kNtSecWritecombine 0x40000000



/*!BEGIN libc/nt/enum/processaccess.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROCESSACCESS_H_

#define kNtProcessCreateProcess 0x0080u
#define kNtProcessCreateThread 0x0002u
#define kNtProcessDupHandle 0x0040u
#define kNtProcessQueryInformation 0x0400u
#define kNtProcessQueryLimitedInformation 0x1000u
#define kNtProcessSetInformation 0x0200u
#define kNtProcessSetQuota 0x0100u
#define kNtProcessSuspendResume 0x0800u
#define kNtProcessTerminate 0x0001u
#define kNtProcessVmOperation 0x0008u
#define kNtProcessVmRead 0x0010u
#define kNtProcessVmWrite 0x0020u
#define kNtProcessSynchronize kNtSynchronize
#define kNtProcessAllAccess \
  (kNtStandardRightsRequired | kNtSynchronize | 0xffffu)



/*!BEGIN libc/nt/enum/processcreationflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROCESSCREATIONFLAGS_H_

#define kNtIdlePriorityClass        0x00000040u
#define kNtBelowNormalPriorityClass 0x00004000u
#define kNtNormalPriorityClass      0x00000020u
#define kNtAboveNormalPriorityClass 0x00008000u
#define kNtHighPriorityClass        0x00000080u
#define kNtRealtimePriorityClass    0x00000100u

#define kNtDebugProcess                 0x00000001u
#define kNtDebugOnlyThisProcess         0x00000002u
#define kNtCreateSuspended              0x00000004u
#define kNtDetachedProcess              0x00000008u
#define kNtCreateNewConsole             0x00000010u
#define kNtCreateNewProcessGroup        0x00000200u
#define kNtCreateUnicodeEnvironment     0x00000400u
#define kNtCreateSeparateWowVdm         0x00000800u
#define kNtCreateSharedWowVdm           0x00001000u
#define kNtCreateForcedos               0x00002000u
#define kNtInheritParentAffinity        0x00010000u
#define kNtCreateProtectedProcess       0x00040000u
#define kNtExtendedStartupinfoPresent   0x00080000u
#define kNtProcessModeBackgroundBegin   0x00100000u
#define kNtProcessModeBackgroundEnd     0x00200000u
#define kNtCreateSecureProcess          0x00400000u
#define kNtCreateBreakawayFromJob       0x01000000u
#define kNtCreatePreserveCodeAuthzLevel 0x02000000u
#define kNtCreateDefaultErrorMode       0x04000000u
#define kNtCreateNoWindow               0x08000000u
#define kNtProfileUser                  0x10000000u
#define kNtProfileKernel                0x20000000u
#define kNtProfileServer                0x40000000u
#define kNtCreateIgnoreSystemDefault    0x80000000u



/*!BEGIN libc/nt/enum/processinfoclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROCESSINFOCLASS_H_

#define kNtProcessBasicInformation 0
#define kNtProcessQuotaLimits      1
#define kNtProcessIoCounters       2
#define kNtProcessVmCounters       3
#define kNtProcessTimes            4
#define kNtProcessBasePriority     5
#define kNtProcessRaisePriority    6
#define kNtProcessDebugPort        7
#define kNtProcessExceptionPort    8
#define kNtProcessAccessToken      9
#define kNtProcessWow64Information 26
#define kNtProcessImageFileName    27



/*!BEGIN libc/nt/enum/procthreadattributes.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROCTHREADATTRIBUTES_H_

#define kNtProcThreadAttributeReplaceValue 1
#define kNtProcThreadAttributeHandleList 0x00020002



/*!BEGIN libc/nt/enum/progress.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PROGRESS_H_

#define kNtProgressContinue 0
#define kNtProgressCancel   1
#define kNtProgressStop     2
#define kNtProgressQuiet    3



/*!BEGIN libc/nt/enum/pwr.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_PWR_H_

#define kNtPwrOk             1
#define kNtPwrFail           (-1)
#define kNtPwrSuspendrequest 1
#define kNtPwrSuspendresume  2
#define kNtPwrCriticalresume 3



/*!BEGIN libc/nt/enum/rdw.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_RDW_H_

#define kNtRdwInvalidate      0x0001
#define kNtRdwInternalpaint   0x0002
#define kNtRdwErase           0x0004
#define kNtRdwValidate        0x0008
#define kNtRdwNointernalpaint 0x0010
#define kNtRdwNoerase         0x0020
#define kNtRdwNochildren      0x0040
#define kNtRdwAllchildren     0x0080
#define kNtRdwUpdatenow       0x0100
#define kNtRdwErasenow        0x0200
#define kNtRdwFrame           0x0400
#define kNtRdwNoframe         0x0800



/*!BEGIN libc/nt/enum/reggetvalueflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_REGGETVALUEFLAGS_H_

#define kNtRrfRtRegNone        0x00000001
#define kNtRrfRtRegSz          0x00000002
#define kNtRrfRtRegExpandSz    0x00000004
#define kNtRrfRtRegBinary      0x00000008
#define kNtRrfRtRegDword       0x00000010
#define kNtRrfRtRegMultiSz     0x00000020
#define kNtRrfRtRegQword       0x00000040
#define kNtRrfRtDword          (kNtRrfRtRegBinary | kNtRrfRtRegDword)
#define kNtRrfRtQword          (kNtRrfRtRegBinary | kNtRrfRtRegQword)
#define kNtRrfRtAny            0x0000ffff
#define kNtRrfSubkeyWow6464key 0x00010000
#define kNtRrfSubkeyWow6432key 0x00020000
#define kNtRrfWow64Mask        0x00030000
#define kNtRrfNoexpand         0x10000000
#define kNtRrfZeroonfailure    0x20000000



/*!BEGIN libc/nt/enum/regtype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_REGTYPE_H_

#define kNtRegNone                     0
#define kNtRegSz                       1 /* UTF-16 string */
#define kNtRegExpandSz                 2 /* UTF-16 string w/ env vars refs */
#define kNtRegBinary                   3
#define kNtRegDword                    4
#define kNtRegDwordBigEndian           5
#define kNtRegLink                     6
#define kNtRegMultiSz                  7 /* UTF-16 double-nul-terminated */
#define kNtRegResourceList             8
#define kNtRegFullResourceDescriptor   9
#define kNtRegResourceRequirementsList 10
#define kNtRegQword                    11



/*!BEGIN libc/nt/enum/replacefile.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_REPLACEFILE_H_

#define kNtReplacefileWriteThrough      1
#define kNtReplacefileIgnoreMergeErrors 2
#define kNtReplacefileIgnoreAclErrors   4



/*!BEGIN libc/nt/enum/sc.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SC_H_

#define kNtScSize         0xF000
#define kNtScMove         0xF010
#define kNtScMinimize     0xF020
#define kNtScMaximize     0xF030
#define kNtScNextwindow   0xF040
#define kNtScPrevwindow   0xF050
#define kNtScClose        0xF060
#define kNtScVscroll      0xF070
#define kNtScHscroll      0xF080
#define kNtScMousemenu    0xF090
#define kNtScKeymenu      0xF100
#define kNtScArrange      0xF110
#define kNtScRestore      0xF120
#define kNtScTasklist     0xF130
#define kNtScScreensave   0xF140
#define kNtScHotkey       0xF150
#define kNtScDefault      0xF160
#define kNtScMonitorpower 0xF170
#define kNtScContexthelp  0xF180
#define kNtScSeparator    0xF00F



/*!BEGIN libc/nt/enum/sectioninformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECTIONINFORMATIONCLASS_H_

#define kNtSectionBasicInformation 0
#define kNtSectionImageInformation 1



/*!BEGIN libc/nt/enum/sectioninherit.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECTIONINHERIT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

enum NtSectionInherit { kNtViewShare = 1, kNtViewUnmap = 2 };

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/sectionmapflags.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECTIONMAPFLAGS_H_

#define kNtSectionQuery              0x0001
#define kNtSectionMapWrite           0x0002
#define kNtSectionMapRead            0x0004
#define kNtSectionMapExecute         0x0008
#define kNtSectionExtendSize         0x0010
#define kNtSectionMapExecuteExplicit 0x0020



/*!BEGIN libc/nt/enum/securityimpersonationlevel.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECURITYIMPERSONATIONLEVEL_H_

#define kNtSecurityAnonymous      0
#define kNtSecurityIdentification 1
#define kNtSecurityImpersonation  2
#define kNtSecurityDelegation     3



/*!BEGIN libc/nt/enum/securityinformation.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SECURITYINFORMATION_H_

#define kNtOwnerSecurityInformation 0x00000001
#define kNtGroupSecurityInformation 0x00000002
#define kNtDaclSecurityInformation 0x00000004
#define kNtSaclSecurityInformation 0x00000008
#define kNtLabelSecurityInformation 0x00000010
#define kNtAttributeSecurityInformation 0x00000020
#define kNtScopeSecurityInformation 0x00000040
#define kNtProcessTrustLabelSecurityInformation 0x00000080
#define kNtAccessFilterSecurityInformation 0x00000100
#define kNtBackupSecurityInformation 0x00010000
#define kNtProtectedDaclSecurityInformation 0x80000000
#define kNtProtectedSaclSecurityInformation 0x40000000
#define kNtUnprotectedDaclSecurityInformation 0x20000000
#define kNtUnprotectedSaclSecurityInformation 0x10000000



/*!BEGIN libc/nt/enum/signal.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SIGNAL_H_

#define kNtSignalBreakpoint          0x80000003u
#define kNtSignalIllegalInstruction  0xC000001Du
#define kNtSignalPrivInstruction     0xC0000096u
#define kNtSignalGuardPage           0x80000001u
#define kNtSignalAccessViolation     0xC0000005u
#define kNtSignalInPageError         0xC0000006u
#define kNtSignalInvalidHandle       0xC0000008u
#define kNtSignalInvalidParameter    0xC000000du
#define kNtSignalFltDenormalOperand  0xC000008Du
#define kNtSignalFltDivideByZero     0xC000008Eu
#define kNtSignalFltInexactResult    0xC000008Fu
#define kNtSignalFltInvalidOperation 0xC0000090u
#define kNtSignalFltOverflow         0xC0000091u
#define kNtSignalFltStackCheck       0xC0000092u
#define kNtSignalFltUnderflow        0xC0000093u
#define kNtSignalIntegerDivideByZero 0xC0000094u
#define kNtSignalDllNotFound         0xC0000135u
#define kNtSignalOrdinalNotFound     0xC0000138u
#define kNtSignalEntrypointNotFound  0xC0000139u
#define kNtSignalControlCExit        0xC000013Au
#define kNtSignalDllInitFailed       0xC0000142u
#define kNtSignalFloatMultipleFaults 0xC00002B4u
#define kNtSignalFloatMultipleTraps  0xC00002B5u
#define kNtSignalAssertionFailure    0xC0000420u



/*!BEGIN libc/nt/enum/sio.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SIO_H_

#define kNtSioBspHandlePoll 0x4800001D
#define kNtSioBaseHandle    0x48000022



/*!BEGIN libc/nt/enum/size.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SIZE_H_

#define kNtSizeRestored  0
#define kNtSizeMinimized 1
#define kNtSizeMaximized 2
#define kNtSizeMaxshow   3
#define kNtSizeMaxhide   4



/*!BEGIN libc/nt/enum/startf.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_STARTF_H_

#define kNtStartfUseshowwindow 0x00000001 /* otherwise wShowWindow ignored */
#define kNtStartfUsesize 0x00000002       /* otherwise dwX / dwY ignored */
#define kNtStartfUseposition 0x00000004   /* otherwise dwX/YSize ignored */
#define kNtStartfUsecountchars 0x00000008 /* otherwise dwX/YCountChars ign. */
#define kNtStartfUsefillattribute 0x00000010 /* etc. */
#define kNtStartfRunfullscreen 0x00000020
#define kNtStartfForceonfeedback 0x00000040
#define kNtStartfForceofffeedback 0x00000080
#define kNtStartfUsestdhandles 0x00000100 /* otherwise hStd... ignored */
#define kNtStartfUsehotkey 0x00000200
#define kNtStartfTitleislinkname 0x00000800
#define kNtStartfTitleisappid 0x00001000
#define kNtStartfPreventpinning 0x00002000
#define kNtStartfUntrustedsource 0x00008000



/*!BEGIN libc/nt/enum/status.h */

#define COSMOPOLITAN_LIBC_NT_STATUS_H_

/* high two bits = {success,informational,warning,error} */
#define kNtStatusSuccess                  0x00000000 /* success statuses */
#define kNtStatusWait0                    0x00000000
#define kNtStatusAbandonedWait0           0x00000080
#define kNtStatusUserApc                  0x000000C0
#define kNtStatusTimeout                  0x00000102
#define kNtStatusPending                  0x00000103
#define kNtStatusGuardPageViolation       0x80000001 /* warning statuses */
#define kNtStatusDatatypeMisalignment     0x80000002
#define kNtStatusBreakpoint               0x80000003
#define kNtStatusSingleStep               0x80000004
#define kNtStatusLongjump                 0x80000026
#define kNtStatusUnwindConsolidate        0x80000029
#define kNtStatusAccessViolation          0xC0000005 /* error statuses */
#define kNtStatusInPageError              0xC0000006
#define kNtStatusInvalidHandle            0xC0000008
#define kNtStatusInvalidParameter         0xC000000D
#define kNtStatusNoMemory                 0xC0000017
#define kNtStatusIllegalInstruction       0xC000001D
#define kNtStatusNoncontinuableException  0xC0000025
#define kNtStatusInvalidDisposition       0xC0000026
#define kNtStatusArrayBoundsExceeded      0xC000008C
#define kNtStatusFloatDenormalOperand     0xC000008D
#define kNtStatusFloatDivideByZero        0xC000008E
#define kNtStatusFloatInexactResult       0xC000008F
#define kNtStatusFloatInvalidOperation    0xC0000090
#define kNtStatusFloatOverflow            0xC0000091
#define kNtStatusFloatStackCheck          0xC0000092
#define kNtStatusFloatUnderflow           0xC0000093
#define kNtStatusIntegerDivideBYZero      0xC0000094
#define kNtStatusIntegerOverflow          0xC0000095
#define kNtStatusPrivilegedInstruction    0xC0000096
#define kNtStatusStackOverflow            0xC00000FD
#define kNtStatusDllNotFound              0xC0000135
#define kNtStatusOrdinalNotFound          0xC0000138
#define kNtStatusEntrypointNotFound       0xC0000139
#define kNtStatusControlCExit             0xC000013A
#define kNtStatusDllInitFailed            0xC0000142
#define kNtStatusFloatMultipleFaults      0xC00002B4
#define kNtStatusFloatMultipleTraps       0xC00002B5
#define kNtStatusRegNatConsumption        0xC00002C9
#define kNtStatusHeapCorruption           0xC0000374
#define kNtStatusStackBufferOverrun       0xC0000409
#define kNtStatusInvalidCruntimeParameter 0xC0000417
#define kNtStatusAssertionFailure         0xC0000420
#define kNtStatusEnclaveViolation         0xC00004A2
#define kNtStatusSegmentNotification      0x40000005
#define kNtStatusFatalAppExit             0x40000015
#define kNtStatusNotFound                 0xC0000225
#define kNtStatusCancelled                0xC0000120

#define kNtDbgExceptionHandled    0x00010001
#define kNtDbgContinue            0x00010002
#define kNtDbgReplyLater          0x40010001
#define kNtDbgTerminateThread     0x40010003
#define kNtDbgTerminateProcess    0x40010004
#define kNtDbgControlC            0x40010005
#define kNtDbgPrintexceptionC     0x40010006
#define kNtDbgRipexception        0x40010007
#define kNtDbgControlBreak        0x40010008
#define kNtDbgCommandException    0x40010009
#define kNtDbgPrintexceptionWideC 0x4001000A
#define kNtDbgExceptionNotHandled 0x80010001
#define kNtStillActive            kNtStatusPending

#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef uint32_t NtStatus;

#define NtSuccess(s)      ((NtStatus)(s) >= 0)
#define NtInformation(s)  (NtSeverity(s) == 1)
#define NtWarning(s)      (NtSeverity(s) == 2)
#define NtError(s)        (NtSeverity(s) == 3)
#define NtCode(s)         ((NtStatus)(s)&0xffff)
#define NtSeverity(s)     ((NtStatus)(s) >> 30)
#define NtFacility(s)     (((NtStatus)(s) >> 16) & 0xfff)
#define NtFacilityCode(s) ((NtStatus)(s)&0x0FFFFFFF)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/sw.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SW_H_

#define kNtSwHide            0
#define kNtSwShownormal      1
#define kNtSwNormal          1
#define kNtSwShowminimized   2
#define kNtSwShowmaximized   3
#define kNtSwMaximize        3
#define kNtSwShownoactivate  4
#define kNtSwShow            5
#define kNtSwMinimize        6
#define kNtSwShowminnoactive 7
#define kNtSwShowna          8
#define kNtSwRestore         9
#define kNtSwShowdefault     10
#define kNtSwForceminimize   11



/*!BEGIN libc/nt/enum/systeminformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SYSTEMINFORMATIONCLASS_H_

#define kNtSystemBasicInformation 0
#define kNtSystemProcessorInformation 1
#define kNtSystemPerformanceInformation 2
#define kNtSystemTimeOfDayInformation 3
#define kNtSystemProcessInformation 5
#define kNtSystemProcessorTimes 8
#define kNtSystemGlobalFlag 9
#define kNtSystemModuleInformation 11
#define kNtSystemLockInformation 12
#define kNtSystemHandleInformation 16
#define kNtSystemObjectInformation 17
#define kNtSystemInterruptInformation 23
#define kNtSystemExceptionInformation 33
#define kNtSystemRegistryQuotaInformation 37
#define kNtSystemLookasideInformation 45



/*!BEGIN libc/nt/enum/threadaccess.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_THREADACCESS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#define kNtThreadTerminate 0x0001
#define kNtThreadSuspendResume 0x0002
#define kNtThreadGetContext 0x0008
#define kNtThreadSetContext 0x0010
#define kNtThreadQueryInformation 0x0040
#define kNtThreadSetInformation 0x0020
#define kNtThreadSetThreadToken 0x0080
#define kNtThreadImpersonate 0x0100
#define kNtThreadDirectImpersonation 0x0200
#define kNtThreadSetLimitedInformation 0x0400
#define kNtThreadQueryLimitedInformation 0x0800
#define kNtThreadResume 0x1000
#define kNtThreadAllAccess (kNtStandardRightsRequired | kNtSynchronize | 0xFFFF)

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/threadinfoclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_THREADINFOCLASS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

enum NtThreadInfoClass {
  kNtThreadBasicInformation,
  kNtThreadTimes,
  kNtThreadPriority,
  kNtThreadBasePriority,
  kNtThreadAffinityMask,
  kNtThreadImpersonationToken,
  kNtThreadDescriptorTableEntry,
  kNtThreadEnableAlignmentFaultFixup,
  kNtThreadEventPair_Reusable,
  kNtThreadQuerySetWin32StartAddress,
  kNtThreadZeroTlsCell,
  kNtThreadPerformanceCount,
  kNtThreadAmILastThread,
  kNtThreadIdealProcessor,
  kNtThreadPriorityBoost,
  kNtThreadSetTlsArrayAddress,
  kNtThreadIsIoPending,
  kNtThreadHideFromDebugger,
  kNtThreadInfoClass_MAX
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/threadpriority.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_THREADPRIORITY_H_

#define kNtThreadBasePriorityIdle  (-15)
#define kNtThreadBasePriorityMin   (-2)
#define kNtThreadBasePriorityMax   2
#define kNtThreadBasePriorityLowrt 15

#define kNtThreadPriorityIdle         kNtThreadBasePriorityIdle
#define kNtThreadPriorityLowest       kNtThreadBasePriorityMin
#define kNtThreadPriorityBelowNormal  (kNtThreadPriorityLowest + 1)
#define kNtThreadPriorityNormal       0
#define kNtThreadPriorityAboveNormal  (kNtThreadPriorityHighest - 1)
#define kNtThreadPriorityHighest      kNtThreadBasePriorityMax
#define kNtThreadPriorityTimeCritical kNtThreadBasePriorityLowrt



/*!BEGIN libc/nt/enum/threadstate.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_THREADSTATE_H_

#define kNtStateInitialized 0
#define kNtStateReady       1
#define kNtStateRunning     2
#define kNtStateStandby     3
#define kNtStateTerminated  4
#define kNtStateWait        5
#define kNtStateTransition  6
#define kNtStateUnknown     7



/*!BEGIN libc/nt/enum/tokeninformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_TOKENINFORMATIONCLASS_H_

#define kNtTokenUser 1
#define kNtTokenGroups 2
#define kNtTokenPrivileges 3
#define kNtTokenOwner 4
#define kNtTokenPrimaryGroup 5
#define kNtTokenDefaultDacl 6
#define kNtTokenSource 7
#define kNtTokenType 8
#define kNtTokenImpersonationLevel 9
#define kNtTokenStatistics 10
#define kNtTokenRestrictedSids 11
#define kNtTokenSessionId 12
#define kNtTokenGroupsAndPrivileges 13
#define kNtTokenSessionReference 14
#define kNtTokenSandBoxInert 15
#define kNtTokenAuditPolicy 16
#define kNtTokenOrigin 17
#define kNtTokenInfoClass_MAX 18



/*!BEGIN libc/nt/enum/tokentype.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_TOKENTYPE_H_

#define kNtTokenPrimary       1
#define kNtTokenImpersonation 2



/*!BEGIN libc/nt/enum/tpm.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_TPM_H_

#define kNtTpmLeftbutton      0x00000
#define kNtTpmRightbutton     0x00002
#define kNtTpmLeftalign       0x00000
#define kNtTpmCenteralign     0x00004
#define kNtTpmRightalign      0x00008
#define kNtTpmTopalign        0x00000
#define kNtTpmVcenteralign    0x00010
#define kNtTpmBottomalign     0x00020
#define kNtTpmHorizontal      0x00000
#define kNtTpmVertical        0x00040
#define kNtTpmNonotify        0x00080
#define kNtTpmReturncmd       0x00100
#define kNtTpmRecurse         0x00001
#define kNtTpmHorposanimation 0x00400
#define kNtTpmHorneganimation 0x00800
#define kNtTpmVerposanimation 0x01000
#define kNtTpmVerneganimation 0x02000
#define kNtTpmNoanimation     0x04000
#define kNtTpmLayoutrtl       0x08000
#define kNtTpmWorkarea        0x10000



/*!BEGIN libc/nt/enum/valueinformationclass.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_VALUEINFORMATIONCLASS_H_

#define kNtKeyValueBasicInformation          0
#define kNtKeyValueFullInformation           1
#define kNtKeyValuePartialInformation        2
#define kNtKeyValueFullInformationAlign64    3
#define kNtKeyValuePartialInformationAlign64 4



/*!BEGIN libc/nt/enum/version.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_VERSION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Known versions of the New Technology executive.
 * @see NtGetVersion()
 */
#define kNtVersionWindows10 0x0a00
#define kNtVersionWindows81 0x0603
#define kNtVersionWindows8 0x0602
#define kNtVersionWindows7 0x0601
#define kNtVersionWindowsVista 0x0600 /* intended baseline */
#define kNtVersionWindowsXp64 0x0502  /* end of the road */
#define kNtVersionWindowsXp 0x0501    /* snowball's chance */
#define kNtVersionWindows2000 0x0500  /* the golden age */
#define kNtVersionFuture 0x0b00

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/enum/vk.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_VK_H_

#define kNtVkLbutton                      0x01
#define kNtVkRbutton                      0x02
#define kNtVkCancel                       0x03
#define kNtVkMbutton                      0x04
#define kNtVkXbutton1                     0x05
#define kNtVkXbutton2                     0x06
#define kNtVkBack                         0x08
#define kNtVkTab                          0x09
#define kNtVkClear                        0x0C
#define kNtVkReturn                       0x0D
#define kNtVkShift                        0x10
#define kNtVkControl                      0x11
#define kNtVkMenu                         0x12 /* alt? */
#define kNtVkPause                        0x13
#define kNtVkCapital                      0x14
#define kNtVkKana                         0x15
#define kNtVkHangul                       0x15
#define kNtVkJunja                        0x17
#define kNtVkFinal                        0x18
#define kNtVkHanja                        0x19
#define kNtVkKanji                        0x19
#define kNtVkEscape                       0x1B
#define kNtVkConvert                      0x1C
#define kNtVkNonconvert                   0x1D
#define kNtVkAccept                       0x1E
#define kNtVkModechange                   0x1F
#define kNtVkSpace                        0x20
#define kNtVkPrior                        0x21
#define kNtVkNext                         0x22
#define kNtVkEnd                          0x23
#define kNtVkHome                         0x24
#define kNtVkLeft                         0x25
#define kNtVkUp                           0x26
#define kNtVkRight                        0x27
#define kNtVkDown                         0x28
#define kNtVkSelect                       0x29
#define kNtVkPrint                        0x2A
#define kNtVkExecute                      0x2B
#define kNtVkSnapshot                     0x2C
#define kNtVkInsert                       0x2D
#define kNtVkDelete                       0x2E
#define kNtVkHelp                         0x2F
#define kNtVkLwin                         0x5B
#define kNtVkRwin                         0x5C
#define kNtVkApps                         0x5D
#define kNtVkSleep                        0x5F
#define kNtVkNumpad0                      0x60
#define kNtVkNumpad1                      0x61
#define kNtVkNumpad2                      0x62
#define kNtVkNumpad3                      0x63
#define kNtVkNumpad4                      0x64
#define kNtVkNumpad5                      0x65
#define kNtVkNumpad6                      0x66
#define kNtVkNumpad7                      0x67
#define kNtVkNumpad8                      0x68
#define kNtVkNumpad9                      0x69
#define kNtVkMultiply                     0x6A
#define kNtVkAdd                          0x6B
#define kNtVkSeparator                    0x6C
#define kNtVkSubtract                     0x6D
#define kNtVkDecimal                      0x6E
#define kNtVkDivide                       0x6F
#define kNtVkF1                           0x70
#define kNtVkF2                           0x71
#define kNtVkF3                           0x72
#define kNtVkF4                           0x73
#define kNtVkF5                           0x74
#define kNtVkF6                           0x75
#define kNtVkF7                           0x76
#define kNtVkF8                           0x77
#define kNtVkF9                           0x78
#define kNtVkF10                          0x79
#define kNtVkF11                          0x7A
#define kNtVkF12                          0x7B
#define kNtVkF13                          0x7C
#define kNtVkF14                          0x7D
#define kNtVkF15                          0x7E
#define kNtVkF16                          0x7F
#define kNtVkF17                          0x80
#define kNtVkF18                          0x81
#define kNtVkF19                          0x82
#define kNtVkF20                          0x83
#define kNtVkF21                          0x84
#define kNtVkF22                          0x85
#define kNtVkF23                          0x86
#define kNtVkF24                          0x87
#define kNtVkNumlock                      0x90
#define kNtVkScroll                       0x91
#define kNtVkLshift                       0xA0
#define kNtVkRshift                       0xA1
#define kNtVkLcontrol                     0xA2
#define kNtVkRcontrol                     0xA3
#define kNtVkLmenu                        0xA4
#define kNtVkRmenu                        0xA5
#define kNtVkBrowserBack                  0xA6
#define kNtVkBrowserForward               0xA7
#define kNtVkBrowserRefresh               0xA8
#define kNtVkBrowserStop                  0xA9
#define kNtVkBrowserSearch                0xAA
#define kNtVkBrowserFavorites             0xAB
#define kNtVkBrowserHome                  0xAC
#define kNtVkVolumeMute                   0xAD
#define kNtVkVolumeDown                   0xAE
#define kNtVkVolumeUp                     0xAF
#define kNtVkMediaNextTrack               0xB0
#define kNtVkMediaPrevTrack               0xB1
#define kNtVkMediaStop                    0xB2
#define kNtVkMediaPlayPause               0xB3
#define kNtVkLaunchMail                   0xB4
#define kNtVkLaunchMediaSelect            0xB5
#define kNtVkLaunchApp1                   0xB6
#define kNtVkLaunchApp2                   0xB7
#define kNtVkOem_1                        0xBA
#define kNtVkOemPlus                      0xBB
#define kNtVkOemComma                     0xBC
#define kNtVkOemMinus                     0xBD
#define kNtVkOemPeriod                    0xBE
#define kNtVkOem_2                        0xBF
#define kNtVkOem_3                        0xC0
#define kNtVkGamepadA                     0xC3
#define kNtVkGamepadB                     0xC4
#define kNtVkGamepadX                     0xC5
#define kNtVkGamepadY                     0xC6
#define kNtVkGamepadRightShoulder         0xC7
#define kNtVkGamepadLeftShoulder          0xC8
#define kNtVkGamepadLeftTrigger           0xC9
#define kNtVkGamepadRightTrigger          0xCA
#define kNtVkGamepadDpadUp                0xCB
#define kNtVkGamepadDpadDown              0xCC
#define kNtVkGamepadDpadLeft              0xCD
#define kNtVkGamepadDpadRight             0xCE
#define kNtVkGamepadMenu                  0xCF
#define kNtVkGamepadView                  0xD0
#define kNtVkGamepadLeftThumbstickButton  0xD1
#define kNtVkGamepadRightThumbstickButton 0xD2
#define kNtVkGamepadLeftThumbstickUp      0xD3
#define kNtVkGamepadLeftThumbstickDown    0xD4
#define kNtVkGamepadLeftThumbstickRight   0xD5
#define kNtVkGamepadLeftThumbstickLeft    0xD6
#define kNtVkGamepadRightThumbstickUp     0xD7
#define kNtVkGamepadRightThumbstickDown   0xD8
#define kNtVkGamepadRightThumbstickRight  0xD9
#define kNtVkGamepadRightThumbstickLeft   0xDA
#define kNtVkOem_4                        0xDB
#define kNtVkOem_5                        0xDC
#define kNtVkOem_6                        0xDD
#define kNtVkOem_7                        0xDE
#define kNtVkOem_8                        0xDF
#define kNtVkOemAx                        0xE1
#define kNtVkOem_102                      0xE2
#define kNtVkIcoHelp                      0xE3
#define kNtVkIco_00                       0xE4
#define kNtVkProcesskey                   0xE5
#define kNtVkIcoClear                     0xE6
#define kNtVkPacket                       0xE7
#define kNtVkOemReset                     0xE9
#define kNtVkOemJump                      0xEA
#define kNtVkOemPa1                       0xEB
#define kNtVkOemPa2                       0xEC
#define kNtVkOemPa3                       0xED
#define kNtVkOemWsctrl                    0xEE
#define kNtVkOemCusel                     0xEF
#define kNtVkOemAttn                      0xF0
#define kNtVkOemFinish                    0xF1
#define kNtVkOemCopy                      0xF2
#define kNtVkOemAuto                      0xF3
#define kNtVkOemEnlw                      0xF4
#define kNtVkOemBacktab                   0xF5
#define kNtVkAttn                         0xF6
#define kNtVkCrsel                        0xF7
#define kNtVkExsel                        0xF8
#define kNtVkEreof                        0xF9
#define kNtVkPlay                         0xFA
#define kNtVkZoom                         0xFB
#define kNtVkNoname                       0xFC
#define kNtVkPa1                          0xFD
#define kNtVkOemClear                     0xFE



/*!BEGIN libc/nt/enum/wa.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WA_H_

#define kNtWaInactive    0
#define kNtWaActive      1
#define kNtWaClickactive 2



/*!BEGIN libc/nt/enum/wait.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WAIT_H_

#define kNtWaitFailed  0xffffffffu
#define kNtWaitTimeout 0x00000102u



/*!BEGIN libc/nt/enum/wm.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WM_H_

#define kNtWmNull                   0x0000
#define kNtWmCreate                 0x0001
#define kNtWmDestroy                0x0002
#define kNtWmMove                   0x0003
#define kNtWmSize                   0x0005
#define kNtWmActivate               0x0006
#define kNtWmSetfocus               0x0007
#define kNtWmKillfocus              0x0008
#define kNtWmEnable                 0x000A
#define kNtWmSetredraw              0x000B
#define kNtWmSettext                0x000C
#define kNtWmGettext                0x000D
#define kNtWmGettextlength          0x000E
#define kNtWmPaint                  0x000F
#define kNtWmClose                  0x0010
#define kNtWmQueryendsession        0x0011
#define kNtWmQueryopen              0x0013
#define kNtWmEndsession             0x0016
#define kNtWmQuit                   0x0012
#define kNtWmErasebkgnd             0x0014
#define kNtWmSyscolorchange         0x0015
#define kNtWmShowwindow             0x0018
#define kNtWmWininichange           0x001A
#define kNtWmSettingchange          kNtWmWininichange
#define kNtWmDevmodechange          0x001B
#define kNtWmActivateapp            0x001C
#define kNtWmFontchange             0x001D
#define kNtWmTimechange             0x001E
#define kNtWmCancelmode             0x001F
#define kNtWmSetcursor              0x0020
#define kNtWmMouseactivate          0x0021
#define kNtWmChildactivate          0x0022
#define kNtWmQueuesync              0x0023
#define kNtWmGetminmaxinfo          0x0024
#define kNtWmPainticon              0x0026
#define kNtWmIconerasebkgnd         0x0027
#define kNtWmNextdlgctl             0x0028
#define kNtWmSpoolerstatus          0x002A
#define kNtWmDrawitem               0x002B
#define kNtWmMeasureitem            0x002C
#define kNtWmDeleteitem             0x002D
#define kNtWmVkeytoitem             0x002E
#define kNtWmChartoitem             0x002F
#define kNtWmSetfont                0x0030
#define kNtWmGetfont                0x0031
#define kNtWmSethotkey              0x0032
#define kNtWmGethotkey              0x0033
#define kNtWmQuerydragicon          0x0037
#define kNtWmCompareitem            0x0039
#define kNtWmGetobject              0x003D
#define kNtWmCompacting             0x0041
#define kNtWmWindowposchanging      0x0046
#define kNtWmWindowposchanged       0x0047
#define kNtWmPower                  0x0048
#define kNtWmCopydata               0x004A
#define kNtWmCanceljournal          0x004B
#define kNtWmNotify                 0x004E
#define kNtWmInputlangchangerequest 0x0050
#define kNtWmInputlangchange        0x0051
#define kNtWmTcard                  0x0052
#define kNtWmHelp                   0x0053
#define kNtWmUserchanged            0x0054
#define kNtWmNotifyformat           0x0055
#define kNtWmContextmenu            0x007B
#define kNtWmStylechanging          0x007C
#define kNtWmStylechanged           0x007D
#define kNtWmDisplaychange          0x007E
#define kNtWmGeticon                0x007F
#define kNtWmSeticon                0x0080
#define kNtWmNccreate               0x0081
#define kNtWmNcdestroy              0x0082
#define kNtWmNccalcsize             0x0083
#define kNtWmNchittest              0x0084
#define kNtWmNcpaint                0x0085
#define kNtWmNcactivate             0x0086
#define kNtWmGetdlgcode             0x0087
#define kNtWmNcmousemove            0x00A0
#define kNtWmNclbuttondown          0x00A1
#define kNtWmNclbuttonup            0x00A2
#define kNtWmNclbuttondblclk        0x00A3
#define kNtWmNcrbuttondown          0x00A4
#define kNtWmNcrbuttonup            0x00A5
#define kNtWmNcrbuttondblclk        0x00A6
#define kNtWmNcmbuttondown          0x00A7
#define kNtWmNcmbuttonup            0x00A8
#define kNtWmNcmbuttondblclk        0x00A9
#define kNtWmNcxbuttondown          0x00AB
#define kNtWmNcxbuttonup            0x00AC
#define kNtWmNcxbuttondblclk        0x00AD
#define kNtWmKeyfirst               0x0100
#define kNtWmKeydown                0x0100
#define kNtWmKeyup                  0x0101
#define kNtWmChar                   0x0102
#define kNtWmDeadchar               0x0103
#define kNtWmSyskeydown             0x0104
#define kNtWmSyskeyup               0x0105
#define kNtWmSyschar                0x0106
#define kNtWmSysdeadchar            0x0107
#define kNtWmUnichar                0x0109
#define kNtWmKeylast                0x0109
#define kNtWmInitdialog             0x0110
#define kNtWmCommand                0x0111
#define kNtWmSyscommand             0x0112
#define kNtWmTimer                  0x0113
#define kNtWmHscroll                0x0114
#define kNtWmVscroll                0x0115
#define kNtWmInitmenu               0x0116
#define kNtWmInitmenupopup          0x0117
#define kNtWmGesture                0x0119
#define kNtWmGesturenotify          0x011A
#define kNtWmMenuselect             0x011F
#define kNtWmMenuchar               0x0120
#define kNtWmEnteridle              0x0121
#define kNtWmMenurbuttonup          0x0122
#define kNtWmMenudrag               0x0123
#define kNtWmMenugetobject          0x0124
#define kNtWmUninitmenupopup        0x0125
#define kNtWmMenucommand            0x0126
#define kNtWmChangeuistate          0x0127
#define kNtWmUpdateuistate          0x0128
#define kNtWmQueryuistate           0x0129
#define kNtWmMousefirst             0x0200
#define kNtWmMousemove              0x0200
#define kNtWmLbuttondown            0x0201
#define kNtWmLbuttonup              0x0202
#define kNtWmLbuttondblclk          0x0203
#define kNtWmRbuttondown            0x0204
#define kNtWmRbuttonup              0x0205
#define kNtWmRbuttondblclk          0x0206
#define kNtWmMbuttondown            0x0207
#define kNtWmMbuttonup              0x0208
#define kNtWmMbuttondblclk          0x0209
#define kNtWmMousewheel             0x020A
#define kNtWmXbuttondown            0x020B
#define kNtWmXbuttonup              0x020C
#define kNtWmXbuttondblclk          0x020D
#define kNtWmMousehwheel            0x020E
#define kNtWmMouselast              0x020E
#define kNtWmParentnotify           0x0210
#define kNtWmEntermenuloop          0x0211
#define kNtWmExitmenuloop           0x0212
#define kNtWmNextmenu               0x0213
#define kNtWmSizing                 0x0214
#define kNtWmCapturechanged         0x0215
#define kNtWmMoving                 0x0216
#define kNtWmPowerbroadcast         0x0218
#define kNtWmMdicreate              0x0220
#define kNtWmMdidestroy             0x0221
#define kNtWmMdiactivate            0x0222
#define kNtWmMdirestore             0x0223
#define kNtWmMdinext                0x0224
#define kNtWmMdimaximize            0x0225
#define kNtWmMditile                0x0226
#define kNtWmMdicascade             0x0227
#define kNtWmMdiiconarrange         0x0228
#define kNtWmMdigetactive           0x0229
#define kNtWmMdisetmenu             0x0230
#define kNtWmEntersizemove          0x0231
#define kNtWmExitsizemove           0x0232
#define kNtWmDropfiles              0x0233
#define kNtWmMdirefreshmenu         0x0234
#define kNtWmCut                    0x0300
#define kNtWmCopy                   0x0301
#define kNtWmPaste                  0x0302
#define kNtWmClear                  0x0303
#define kNtWmUndo                   0x0304
#define kNtWmRenderformat           0x0305
#define kNtWmRenderallformats       0x0306
#define kNtWmDestroyclipboard       0x0307
#define kNtWmDrawclipboard          0x0308
#define kNtWmPaintclipboard         0x0309
#define kNtWmVscrollclipboard       0x030A
#define kNtWmSizeclipboard          0x030B
#define kNtWmAskcbformatname        0x030C
#define kNtWmChangecbchain          0x030D
#define kNtWmHscrollclipboard       0x030E
#define kNtWmQuerynewpalette        0x030F
#define kNtWmPaletteischanging      0x0310
#define kNtWmPalettechanged         0x0311
#define kNtWmHotkey                 0x0312



/*!BEGIN libc/nt/enum/ws.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WS_H_

#define kNtWsOverlapped   0x00000000
#define kNtWsPopup        0x80000000
#define kNtWsChild        0x40000000
#define kNtWsMinimize     0x20000000
#define kNtWsVisible      0x10000000
#define kNtWsDisabled     0x08000000
#define kNtWsClipsiblings 0x04000000
#define kNtWsClipchildren 0x02000000
#define kNtWsMaximize     0x01000000
#define kNtWsCaption      0x00C00000
#define kNtWsBorder       0x00800000
#define kNtWsDlgframe     0x00400000
#define kNtWsVscroll      0x00200000
#define kNtWsHscroll      0x00100000
#define kNtWsSysmenu      0x00080000
#define kNtWsThickframe   0x00040000
#define kNtWsGroup        0x00020000
#define kNtWsTabstop      0x00010000
#define kNtWsMinimizebox  0x00020000
#define kNtWsMaximizebox  0x00010000
#define kNtWsTiled        kNtWsOverlapped
#define kNtWsIconic       kNtWsMinimize
#define kNtWsSizebox      kNtWsThickframe
#define kNtWsTiledwindow  kNtWsOverlappedwindow
#define kNtWsOverlappedwindow                                        \
  (kNtWsOverlapped | kNtWsCaption | kNtWsSysmenu | kNtWsThickframe | \
   kNtWsMinimizebox | kNtWsMaximizebox)
#define kNtWsPopupwindow (kNtWsPopup | kNtWsBorder | kNtWsSysmenu)

#define kNtWsExDlgmodalframe       0x00000001
#define kNtWsExNoparentnotify      0x00000004
#define kNtWsExTopmost             0x00000008
#define kNtWsExAcceptfiles         0x00000010
#define kNtWsExTransparent         0x00000020
#define kNtWsExMdichild            0x00000040
#define kNtWsExToolwindow          0x00000080
#define kNtWsExWindowedge          0x00000100
#define kNtWsExClientedge          0x00000200
#define kNtWsExContexthelp         0x00000400
#define kNtWsExRight               0x00001000
#define kNtWsExLeft                0x00000000
#define kNtWsExRtlreading          0x00002000
#define kNtWsExLtrreading          0x00000000
#define kNtWsExLeftscrollbar       0x00004000
#define kNtWsExRightscrollbar      0x00000000
#define kNtWsExControlparent       0x00010000
#define kNtWsExStaticedge          0x00020000
#define kNtWsExAppwindow           0x00040000
#define kNtWsExNoinheritlayout     0x00100000
#define kNtWsExNoredirectionbitmap 0x00200000
#define kNtWsExLayoutrtl           0x00400000
#define kNtWsExComposited          0x02000000
#define kNtWsExNoactivate          0x08000000

#define kNtWsExOverlappedwindow (kNtWsExWindowedge | kNtWsExClientedge)
#define kNtWsExPalettewindow \
  (kNtWsExWindowedge | kNtWsExToolwindow | kNtWsExTopmost)



/*!BEGIN libc/nt/enum/wt.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_WT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define kNtWtExecuteonlyonce 8

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/afd.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_AFD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtAfdPollHandleInfo {
  int64_t Handle;
  uint32_t Events;
  NtStatus Status;
};

struct NtAfdPollInfo {
  int64_t Timeout;
  uint32_t NumberOfHandles;
  uint32_t Exclusive;
  struct NtAfdPollHandleInfo Handles[1];
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ansistring.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_ANSISTRING_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtAnsiString {
  unsigned short Length;
  unsigned short MaximumLength;
  char *Buffer;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/byhandlefileinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_BYHANDLEFILEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtByHandleFileInformation {
  uint32_t dwFileAttributes; /* ←NtFileFlagAndAttributes */
  struct NtFileTime ftCreationFileTime;
  struct NtFileTime ftLastAccessFileTime;
  struct NtFileTime ftLastWriteFileTime;
  uint32_t dwVolumeSerialNumber;
  uint32_t nFileSizeHigh;
  uint32_t nFileSizeLow;
  uint32_t nNumberOfLinks;
  uint32_t nFileIndexHigh;
  uint32_t nFileIndexLow;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/charinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CHARINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtCharInfo {
  union {
    char16_t UnicodeChar;
    char AsciiChar;
  } Char;
  uint16_t Attributes;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/clientid.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CLIENTID_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtClientId {
  void *UniqueProcess;
  void *UniqueThread;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/consolecursorinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONSOLECURSORINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtConsoleCursorInfo {
  uint32_t dwSize;
  bool32 bVisible;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/consolescreenbufferinfoex.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONSOLESCREENBUFFERINFOEX_H_


/*!BEGIN libc/nt/struct/coord.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_COORD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtCoord {
  int16_t X;
  int16_t Y;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/smallrect.h */

#define COSMOPOLITAN_LIBC_NT_ENUM_SMALLRECT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSmallRect {
  int16_t Left;
  int16_t Top;
  int16_t Right;
  int16_t Bottom;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtConsoleScreenBufferInfoEx {
  uint32_t cbSize; /* sizeof(struct NtConsoleScreenBufferInfoEx) */
  struct NtCoord dwSize;
  struct NtCoord dwCursorPosition;
  uint16_t wAttributes; /* kNt{Foreground,Background}... */
  struct NtSmallRect srWindow;
  struct NtCoord dwMaximumWindowSize;
  uint16_t wPopupAttributes;
  bool32 bFullscreenSupported;
  uint32_t ColorTable[16]; /* 0x00BBGGRR */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/consolescreenbufferinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONSOLESCREENBUFFERINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtConsoleScreenBufferInfo {
  struct NtCoord dwSize;
  struct NtCoord dwCursorPosition;
  uint16_t wAttributes;
  struct NtSmallRect srWindow;
  struct NtCoord dwMaximumWindowSize;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/consoleselectioninfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONSOLESELECTIONINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtConsoleSelectionInfo {
  uint32_t dwFlags;
  struct NtCoord dwSelectionAnchor;
  struct NtSmallRect srSelection;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/context.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CONTEXT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtM128A {
  uint64_t Low;
  int64_t High;
};

struct NtXmmSaveArea32 { /* basically same as struct FpuState */
  uint16_t ControlWord;
  uint16_t StatusWord;
  uint8_t TagWord;
  uint8_t Reserved1;
  uint16_t ErrorOpcode;
  uint32_t ErrorOffset;
  uint16_t ErrorSelector;
  uint16_t Reserved2;
  uint32_t DataOffset;
  uint16_t DataSelector;
  uint16_t Reserved3;
  uint32_t MxCsr;
  uint32_t MxCsr_Mask;
  struct NtM128A FloatRegisters[8];
  struct NtM128A XmmRegisters[16];
  uint8_t Reserved4[96];
};

struct NtContext {
  uint64_t P1Home, P2Home, P3Home, P4Home, P5Home, P6Home;
  uint32_t ContextFlags;
  uint32_t MxCsr;
  uint16_t SegCs, SegDs, SegEs, SegFs, SegGs, SegSs;
  uint32_t EFlags;
  uint64_t Dr0, Dr1, Dr2, Dr3, Dr6, Dr7;
  uint64_t Rax, Rcx, Rdx, Rbx, Rsp, Rbp, Rsi, Rdi;
  uint64_t R8, R9, R10, R11, R12, R13, R14, R15;
  uint64_t Rip;
  union {
    struct NtXmmSaveArea32 FltSave;
    struct NtXmmSaveArea32 FloatSave;
    struct {
      struct NtM128A Header[2];
      struct NtM128A Legacy[8];
      struct NtM128A Xmm0, Xmm1, Xmm2, Xmm3, Xmm4, Xmm5, Xmm6, Xmm7;
      struct NtM128A Xmm8, Xmm9, Xmm10, Xmm11, Xmm12, Xmm13, Xmm14, Xmm15;
    };
  };
  struct NtM128A VectorRegister[26];
  uint64_t VectorControl;
  uint64_t DebugControl;
  uint64_t LastBranchToRip;
  uint64_t LastBranchFromRip;
  uint64_t LastExceptionToRip;
  uint64_t LastExceptionFromRip;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/criticalsectiondebug.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CRITICALSECTIONDEBUG_H_


/*!BEGIN libc/nt/struct/criticalsection.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_CRITICALSECTION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtCriticalSection {
  struct NtCriticalSectionDebug *DebugInfo;
  int32_t LockCount;
  int32_t RecursionCount;
  void *OwningThread;
  void *LockSemaphore;
  uintptr_t SpinCount;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/linkedlist.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LINKEDLIST_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Dynamic linked list overlay.
 */
struct NtLinkedList {
  struct NtLinkedList *Next;
  struct NtLinkedList *Prev;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtCriticalSectionDebug {
  uint16_t Type;
  uint16_t CreatorBackTraceIndex;
  struct NtCriticalSection *CriticalSection;
  struct NtLinkedList ProcessLocksList;
  uint32_t EntryCount;
  uint32_t ContentionCount;
  uint32_t Spare[2];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/drawtextparams.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_DRAWTEXTPARAMS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtDrawTextParams {
  uint32_t cbSize;
  int32_t iTabLength;
  int32_t iLeftMargin;
  int32_t iRightMargin;
  uint32_t uiLengthDrawn;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/editmenu.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_EDITMENU_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtEditMenu {
  int64_t hmenu;
  uint16_t idEdit;
  uint16_t idCut;
  uint16_t idCopy;
  uint16_t idPaste;
  uint16_t idClear;
  uint16_t idUndo;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/exceptionframe.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_EXCEPTIONFRAME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtExceptionFrame {
  struct NtExceptionFrame *Prev;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileaccessinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEACCESSINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAccessInformation {
  uint32_t AccessFlags;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filealignmentinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEALIGNMENTINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAlignmentInformation {
  uint32_t AlignmentRequirement;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileallinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEALLINFORMATION_H_


/*!BEGIN libc/nt/struct/filebasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileBasicInformation {
  int64_t CreationTime;    /* in 100ns units */
  int64_t LastAccessTime;  /* in 100ns units */
  int64_t LastWriteTime;   /* in 100ns units */
  int64_t ChangeTime;      /* in 100ns units */
  uint32_t FileAttributes; /* kNtFileAttributeXXX */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileeainformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEEAINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileEaInformation {
  uint32_t EaSize;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileinternalinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEINTERNALINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileInternalInformation {
  int64_t IndexNumber;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filemodeinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEMODEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileModeInformation {
  uint32_t Mode;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filenameinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILENAMEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileNameInformation {
  uint32_t FileNameLength;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filepositioninformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEPOSITIONINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFilePositionInformation {
  int64_t CurrentByteOffset;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filestandardinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILESTANDARDINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileStandardInformation {
  int64_t AllocationSize;
  int64_t EndOfFile;
  uint32_t NumberOfLinks;
  bool32 DeletePending;
  bool32 Directory;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAllInformation {
  struct NtFileBasicInformation BasicInformation;
  struct NtFileStandardInformation StandardInformation;
  struct NtFileInternalInformation InternalInformation;
  struct NtFileEaInformation EaInformation;
  struct NtFileAccessInformation AccessInformation;
  struct NtFilePositionInformation PositionInformation;
  struct NtFileModeInformation ModeInformation;
  struct NtFileAlignmentInformation AlignmentInformation;
  struct NtFileNameInformation NameInformation;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileallocationinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEALLOCATIONINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAllocationInformation {
  int64_t AllocationSize;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileattributetaginformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEATTRIBUTETAGINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileAttributeTagInformation {
  uint32_t FileAttributes;
  uint32_t ReparseTag;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filebasicinfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEBASICINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileBasicInfo {
  int64_t CreationTime;    /* in 100ns units */
  int64_t LastAccessTime;  /* in 100ns units */
  int64_t LastWriteTime;   /* in 100ns units */
  int64_t ChangeTime;      /* in 100ns units */
  uint32_t FileAttributes; /* kNtFileAttributeXXX */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filebothdirectoryinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEBOTHDIRECTORYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtFileBothDirectoryInformation {
  uint32_t NextEntryOffset;
  uint32_t FileIndex;
  int64_t CreationTime;
  int64_t LastAccessTime;
  int64_t LastWriteTime;
  int64_t ChangeTime;
  int64_t EndOfFile;
  int64_t AllocationSize;
  uint32_t FileAttributes;
  uint32_t FileNameLength;
  uint32_t EaSize;
  unsigned char ShortNameLength;
  char16_t ShortName[12];
  char16_t FileName[1];
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filecompressioninfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILECOMPRESSIONINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileCompressionInfo {
  int64_t CompressedFileSize;
  uint16_t CompressionFormat;
  uint8_t CompressionUnitShift;
  uint8_t ChunkShift;
  uint8_t ClusterShift;
  uint8_t Reserved[3];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filedirectoryinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEDIRECTORYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileDirectoryInformation {
  uint32_t NextEntryOffset;
  uint32_t FileIndex;
  int64_t CreationTime;
  int64_t LastAccessTime;
  int64_t LastWriteTime;
  int64_t ChangeTime;
  int64_t EndOfFile;
  int64_t AllocationSize;
  uint32_t FileAttributes;
  uint32_t FileNameLength;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filedispositioninformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEDISPOSITIONINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileDispositionInformation {
  bool32 DoDeleteFile;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fileendoffileinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEENDOFFILEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct FileEndOfFileInformation {
  int64_t EndOfFile;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filefulldirectoryinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEFULLDIRECTORYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileFullDirectoryInformation {
  uint32_t NextEntryOffset;
  uint32_t FileIndex;
  int64_t CreationTime;
  int64_t LastAccessTime;
  int64_t LastWriteTime;
  int64_t ChangeTime;
  int64_t EndOfFile;
  int64_t AllocationSize;
  uint32_t FileAttributes;
  uint32_t FileNameLength;
  uint32_t EaSize;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filefulleainformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEFULLEAINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileFullEaInformation {
  uint32_t NextEntryOffset;
  uint8_t Flags;
  uint8_t EaNameLength;
  uint16_t EaValueLength;
  char EaName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filemailslotqueryinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEMAILSLOTQUERYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileMailslotQueryInformation {
  uint32_t MaximumMessageSize;
  uint32_t MailslotQuota;
  uint32_t NextMessageSize;
  uint32_t MessagesAvailable;
  int64_t ReadTimeout;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filemailslotsetinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEMAILSLOTSETINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileMailslotSetInformation {
  int64_t ReadTimeout;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filenamesinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILENAMESINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileNamesInformation {
  uint32_t NextEntryOffset;
  uint32_t FileIndex;
  uint32_t FileNameLength;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filenetworkopeninformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILENETWORKOPENINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileNetworkOpenInformation {
  int64_t CreationTime;
  int64_t LastAccessTime;
  int64_t LastWriteTime;
  int64_t ChangeTime;
  int64_t AllocationSize;
  int64_t EndOfFile;
  uint32_t FileAttributes;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filepipelocalinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEPIPELOCALINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFilePipeLocalInformation {
  uint32_t NamedPipeType;
  uint32_t NamedPipeConfiguration;
  uint32_t MaximumInstances;
  uint32_t CurrentInstances;
  uint32_t InboundQuota;
  uint32_t ReadDataAvailable;
  uint32_t OutboundQuota;
  uint32_t WriteQuotaAvailable;
  uint32_t NamedPipeState;
  uint32_t NamedPipeEnd;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filerenameinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILERENAMEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileRenameInformation {
  bool32 Replace;
  void *RootDir;
  uint32_t FileNameLength;
  char16_t FileName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filesegmentelement.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILESEGMENTELEMENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

union NtFileSegmentElement {
  void *Buffer;
  uint64_t Alignment;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filestreaminformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILESTREAMINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileStreamInformation {
  uint32_t NextEntryOffset;
  uint32_t StreamNameLength;
  int64_t StreamSize;
  int64_t StreamAllocationSize;
  char16_t StreamName[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/filezerodatainformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FILEZERODATAINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFileZeroDataInformation {
  uint64_t FileOffset;
  uint64_t BeyondFinalZero;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/fpodata.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_FPODATA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtFpoData {
  /* TODO(jart): No bitfields. */
  uint32_t ulOffStart;
  uint32_t cbProcSize;
  uint32_t cdwLocals;
  uint16_t cdwParams;
  uint16_t cbProlog : 8;
  uint16_t cbRegs : 3;
  uint16_t fHasSEH : 1;
  uint16_t fUseBP : 1;
  uint16_t reserved : 1;
  uint16_t cbFrame : 2;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/genericmapping.h */

#define COSMOPOLITAN_LIBC_NT_GENERICMAPPING_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtGenericMapping {
  unsigned int GenericRead;
  unsigned int GenericWrite;
  unsigned int GenericExecute;
  unsigned int GenericAll;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/guid.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_GUID_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtGuid {
  uint32_t Data1;
  uint16_t Data2;
  uint16_t Data3;
  uint8_t Data4[8];
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/inputrecord.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_INPUTRECORD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtKeyEventRecord {
  bool32 bKeyDown;
  uint16_t wRepeatCount;
  uint16_t wVirtualKeyCode;
  uint16_t wVirtualScanCode;
  union {
    int16_t UnicodeChar;
    char AsciiChar;
  } uChar;
  unsigned int dwControlKeyState;
};

struct NtMouseEventRecord {
  struct NtCoord dwMousePosition;
  uint32_t dwButtonState;
  uint32_t dwControlKeyState;
  uint32_t dwEventFlags;
};

struct NtWindowBufferSizeRecord {
  struct NtCoord dwSize;
};

struct NtMenuEventRecord {
  uint32_t dwCommandId;
};

struct NtFocusEventRecord {
  bool32 bSetFocus;
};

struct NtInputRecord {
  uint16_t EventType;
  union {
    struct NtKeyEventRecord KeyEvent;
    struct NtMouseEventRecord MouseEvent;
    struct NtWindowBufferSizeRecord WindowBufferSizeEvent;
    struct NtMenuEventRecord MenuEvent;
    struct NtFocusEventRecord FocusEvent;
  } Event;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/iocounters.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_IOCOUNTERS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtIoCounters {
  uint64_t ReadOperationCount;
  uint64_t WriteOperationCount;
  uint64_t OtherOperationCount;
  uint64_t ReadTransferCount;
  uint64_t WriteTransferCount;
  uint64_t OtherTransferCount;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/iostatusblock.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_IOSTATUSBLOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtIoStatusBlock {
  union {
    NtStatus Status;
    void *Pointer; /* reserved for internal use */
  };
  uint32_t *Information; /* request dependent */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/kernelusertimes.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_KERNELUSERTIMES_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtKernelUserTimes {
  uint64_t CreateFileTime;
  uint64_t ExitFileTime;
  int64_t KernelTime;
  int64_t UserTime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ldrdatatableentry.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LDRDATATABLEENTRY_H_


/*!BEGIN libc/nt/struct/unicodestring.h */

#define COSMOPOLITAN_LIBC_NT_UNICODE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtUnicodeString {
  uint16_t Length;
  uint16_t MaxLength;
  char16_t *Data;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtLdrDataTableEntry {
  struct NtLinkedList InLoadOrderLinks; /* msdn:reserved */
  struct NtLinkedList InMemoryOrderLinks;
  struct NtLinkedList InInitOrderLinks; /* msdn:reserved */
  void *DllBase;
  void *EntryPoint;
  union {
    uint32_t SizeOfImage;
    unsigned char SizeOfImagePadding[__SIZEOF_POINTER__];
  };
  struct NtUnicodeString FullDllName;
  struct NtUnicodeString BaseDllName;
  uint32_t Flags;
  uint16_t Load_Count;
  uint16_t TlsIndex;
  union {
    struct NtLinkedList HashLinks;
    struct {
      void *SectionPointer;
      uint32_t CheckSum;
    };
  };
  union {
    void *LoadedImports;
    uint32_t TimeDateStamp;
  };
  void *EntryPointActivationContext;
  void *PatchInformation;
  struct NtLinkedList ForwarderLinks;
  struct NtLinkedList ServiceTagLinks;
  struct NtLinkedList StaticLinks;
  void *ContextInformation;
  uintptr_t OriginalBase;
  int64_t LoadTime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ldr.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtLdr {
  uint32_t SizeOfThis;                       /* msdn:reserved */
  uint32_t IsInitialized;                    /* msdn:reserved */
  void *SsHandle;                            /* msdn:reserved */
  struct NtLinkedList InLoadOrderModuleList; /* msdn:reserved */
  struct NtLinkedList /*∩NtLdrDataTableEntry*/ InMemoryOrderModuleList;
  struct NtLinkedList InInitOrderModuleList; /* msdn:reserved */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/luidandattributes.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LUIDANDATTRIBUTES_H_


/*!BEGIN libc/nt/struct/luid.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_LUID_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtLuid {
  uint32_t LowPart;
  int32_t HighPart;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtLuidAndAttributes {
  struct NtLuid Luid;
  uint32_t Attributes;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/memorybasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_MEMORYBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtMemoryBasicInformation {
  void *BaseAddress;
  void *AllocationBase;
  uint32_t AllocationProtect;
  uint64_t RegionSize;
  uint32_t State;
  uint32_t Protect;
  uint32_t Type;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/memoryrangeentry.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_MEMORYRANGEENTRY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtMemoryRangeEntry {
  void *VirtualAddress;
  size_t NumberOfBytes;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/memorystatusex.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_MEMORYSTATUSEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtMemoryStatusEx {
  uint32_t dwLength;
  uint32_t dwMemoryLoad;
  uint64_t ullTotalPhys;
  uint64_t ullAvailPhys;
  uint64_t ullTotalPageFile;
  uint64_t ullAvailPageFile;
  uint64_t ullTotalVirtual;
  uint64_t ullAvailVirtual;
  uint64_t ullAvailExtendedVirtual;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/msg.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_MSG_H_


/*!BEGIN libc/nt/struct/point.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_POINT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtPoint {
  int32_t x;
  int32_t y;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtMsg {
  int64_t hwnd;
  uint32_t message;
  uint64_t wParam;
  int64_t lParam;
  uint32_t time;
  struct NtPoint pt;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/nonpageddebuginfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_NONPAGEDDEBUGINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtNonPagedDebugInfo {
  uint16_t Signature;
  uint16_t Flags;
  uint32_t Size;
  uint16_t Machine;
  uint16_t Characteristics;
  uint32_t TimeDateStamp;
  uint32_t CheckSum;
  uint32_t SizeOfImage;
  uint64_t ImageBase;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/ntexceptionpointers.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_NTEXCEPTIONPOINTERS_H_


/*!BEGIN libc/nt/struct/ntexceptionrecord.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_NTEXCEPTIONRECORD_H_

#define kNtExceptionMaximumParameters 15
#define kNtExceptionNoncontinuable 1

#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtExceptionRecord {
  uint32_t ExceptionCode;                    /* kNtException... */
  uint32_t ExceptionFlags;                   /* kNtExceptionNoncontinuable */
  struct NtExceptionRecord *ExceptionRecord; /* nested exceptions */
  void *ExceptionAddress;                    /* %rip */
  uint32_t NumberParameters;                 /* #ExceptionInformation */
  uint32_t *ExceptionInformation[kNtExceptionMaximumParameters];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtExceptionPointers {
  struct NtExceptionRecord *ExceptionRecord;
  struct NtContext *ContextRecord;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/objectallinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OBJECTALLINFORMATION_H_


/*!BEGIN libc/nt/struct/objecttypeinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OBJECTTYPEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectTypeInformation {
  struct NtUnicodeString TypeName;
  uint32_t TotalNumberOfObjects;
  uint32_t TotalNumberOfHandles;
  uint32_t TotalPagedPoolUsage;
  uint32_t TotalNonPagedPoolUsage;
  uint32_t TotalNamePoolUsage;
  uint32_t TotalHandleTableUsage;
  uint32_t HighWaterNumberOfObjects;
  uint32_t HighWaterNumberOfHandles;
  uint32_t HighWaterPagedPoolUsage;
  uint32_t HighWaterNonPagedPoolUsage;
  uint32_t HighWaterNamePoolUsage;
  uint32_t HighWaterHandleTableUsage;
  uint32_t InvalidAttributes;
  struct NtGenericMapping GenericMapping;
  uint32_t ValidAccessMask;
  bool32 SecurityRequired;
  bool32 MaintainHandleCount;
  uint32_t PoolType;
  uint32_t DefaultPagedPoolCharge;
  uint32_t DefaultNonPagedPoolCharge;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectAllInformation {
  uint32_t NumberOfObjects;
  struct NtObjectTypeInformation ObjectTypeInformation[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/objectattributes.h */

#define COSMOPOLITAN_LIBC_NT_I_OBJECTATTRIBUTES_H_


/*!BEGIN libc/nt/struct/rtluserprocessparameters.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_RTLUSERPROCESSPARAMETERS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtRtlUserProcessParameters {
  uint32_t MaximumLength;
  uint32_t Length;
  uint32_t Flags;
  uint32_t DebugFlags;
  int64_t ConsoleHandle;
  uint32_t ConsoleFlags;
  int64_t StdInputHandle;
  int64_t StdOutputHandle;
  int64_t StdErrorHandle;
  struct NtUnicodeString *CurrentDirectoryPath;
  int64_t CurrentDirectoryHandle;
  struct NtUnicodeString *DllPath;
  struct NtUnicodeString *ImagePathName;
  struct NtUnicodeString *CommandLine;
  void *Environment;
  uint32_t StartingPositionLeft;
  uint32_t StartingPositionTop;
  uint32_t Width;
  uint32_t Height;
  uint32_t CharWidth;
  uint32_t CharHeight;
  uint32_t ConsoleTextAttributes;
  uint32_t WindowFlags;
  uint32_t ShowWindowFlags;
  struct NtUnicodeString *WindowTitle;
  struct NtUnicodeString *DesktopName;
  struct NtUnicodeString *ShellInfo;
  struct NtUnicodeString *RuntimeData;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectAttributes {
  uint32_t Length;
  int64_t RootDirectory;
  struct NtUnicodeString *ObjectName;
  uint32_t Attributes; /* OBJ_INHERIT, etc. */
  struct NtSecurityDescriptor *SecurityDescriptor;
  void *SecurityQualityOfService;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/objectbasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OBJECTBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectBasicInformation {
  uint32_t Attributes;
  uint32_t GrantedAccess;
  uint32_t HandleCount;
  uint32_t PointerCount;
  uint32_t PagedPoolUsage;
  uint32_t NonPagedPoolUsage;
  uint32_t Reserved[3];
  uint32_t NameInformationLength;
  uint32_t TypeInformationLength;
  uint32_t SecurityDescriptorLength;
  int64_t CreateTime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/objectnameinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OBJECTNAMEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtObjectNameInformation {
  struct NtUnicodeString Name;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/openfilename.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OPENFILENAME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtOpenFilename {
  uint32_t lStructSize;
  int64_t hwndOwner;
  int64_t hInstance;
  const char16_t *lpstrFilter;
  char16_t *lpstrCustomFilter;
  uint32_t nMaxCustFilter;
  uint32_t nFilterIndex;
  char16_t *lpstrFile;
  uint32_t nMaxFile;
  char16_t *lpstrFileTitle;
  uint32_t nMaxFileTitle;
  const char16_t *lpstrInitialDir;
  const char16_t *lpstrTitle;
  uint32_t Flags;
  uint16_t nFileOffset;
  uint16_t nFileExtension;
  const char16_t *lpstrDefExt;
  intptr_t lCustData;
  uint64_t (*lpfnHook)(int64_t, uint32_t, uint64_t, int64_t);
  const char16_t *lpTemplateName;
  void *pvReserved;
  uint32_t dwReserved;
  uint32_t FlagsEx;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/overlappedentry.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OVERLAPPEDENTRY_H_


/*!BEGIN libc/nt/struct/overlapped.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_OVERLAPPED_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtOverlapped {
  uintptr_t Internal;
  uintptr_t InternalHigh;
  union {
    struct {
      uint32_t Offset;
      uint32_t OffsetHigh;
    };
    void *Pointer;
  };
  int64_t hEvent;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtOverlappedEntry {
  uint32_t *lpCompletionKey;
  struct NtOverlapped *lpOverlapped;
  uint32_t *Internal;
  uint32_t dwNumberOfBytesTransferred;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/paintstruct.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PAINTSTRUCT_H_


/*!BEGIN libc/nt/struct/rect.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_RECT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtRect {
  int32_t left;
  int32_t top;
  int32_t right;
  int32_t bottom;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtPaintStruct {
  int64_t hdc;
  bool32 fErase;
  struct NtRect rcPaint;
  bool32 fRestore;
  bool32 fIncUpdate;
  uint8_t rgbReserved[32];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/peb.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PEB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtPeb {
  union {
    struct {
      unsigned char InheritedAddressSpace;
      unsigned char ReadImageFileExecOptions;
      unsigned char BeingDebugged;
      unsigned char __wut1;
    };
    uint64_t __wut2;
  };
  uint64_t Mutant;
  uint64_t ImageBaseAddress;
  struct NtLdr *Ldr;
  uint64_t ProcessParameters;
  uint64_t SubSystemData;
  uint64_t ProcessHeap;
  uint64_t FastPebLock;
  uint64_t __wut3;
  uint64_t __wut4;
  uint64_t __wut5;
  union {
    uint64_t KernelCallbackTable;
    uint64_t UserSharedInfoPtr;
  };
  uint32_t SystemReserved;
  uint32_t __wut6;
  uint64_t __wut7;
  uint64_t TlsExpansionCounter;
  uint64_t TlsBitmap;
  uint32_t TlsBitmapBits[2];
  uint64_t ReadOnlySharedMemoryBase;
  uint64_t __wut8;
  uint64_t ReadOnlyStaticServerData;
  uint64_t AnsiCodePageData;
  uint64_t OemCodePageData;
  uint64_t UnicodeCaseTableData;
  uint32_t NumberOfProcessors;
#ifdef __x86_64__
  uint32_t NtGlobalFlag;
#else
  uint64_t NtGlobalFlag;
#endif
  int64_t CriticalSectionTimeout;
  uint64_t HeapSegmentReserve;
  uint64_t HeapSegmentCommit;
  uint64_t HeapDeCommitTotalFreeThreshold;
  uint64_t HeapDeCommitFreeBlockThreshold;
  uint32_t NumberOfHeaps;
  uint32_t MaximumNumberOfHeaps;
  uint64_t ProcessHeaps;
  uint64_t GdiSharedHandleTable;
  uint64_t ProcessStarterHelper;
  uint64_t GdiDCAttributeList;
  uint64_t LoaderLock;
  union {
    struct {
      uint32_t OSMajorVersion;
      uint32_t OSMinorVersion;
    };
    uint64_t OSVersion;
  };
  uint16_t OSBuildNumber;
  uint16_t OSCSDVersion;
  uint32_t OSPlatformId;
  uint32_t ImageSubsystem;
  uint32_t ImageSubsystemMajorVersion;
  uint64_t ImageSubsystemMinorVersion;
  union {
    uint64_t ImageProcessAffinityMask;
    uint64_t ActiveProcessAffinityMask;
  };
  uint64_t GdiHandleBuffer[38 - __SIZEOF_POINTER__];
  uint64_t PostProcessInitRoutine;
  uint64_t TlsExpansionBitmap;
  uint32_t TlsExpansionBitmapBits[32];
  uint64_t SessionId;
  uint64_t AppCompatFlags;
  uint64_t AppCompatFlagsUser;
  uint64_t pShimData;
  uint64_t AppCompatInfo;
  struct NtUnicodeString CSDVersion;
  uint64_t ActivationContextData;
  uint64_t ProcessAssemblyStorageMap;
  uint64_t SystemDefaultActivationContextData;
  uint64_t SystemAssemblyStorageMap;
  uint64_t MinimumStackCommit;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/pollfd.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_POLLFD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct sys_pollfd_nt {
  int64_t handle;
  int16_t events;
  int16_t revents;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/privilegeset.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PRIVILEGESET_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtPrivilegeSet {
  uint32_t PrivilegeCount;
  uint32_t Control;
  struct NtLuidAndAttributes Privilege[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/processbasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PROCESSBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtProcessBasicInformation {
  int32_t ExitStatus;
  struct NtPeb *PebBaseAddress;
  uint32_t *AffinityMask;
  int32_t BasePriority;
  int64_t UniqueProcessId;
  int64_t InheritedFromUniqueProcessId;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/procthreadattributelist.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_PROCTHREADATTRIBUTELIST_H_

struct NtProcThreadAttributeList;



/*!BEGIN libc/nt/struct/rtluserprocessinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_RTLUSERPROCESSINFORMATION_H_


/*!BEGIN libc/nt/struct/sectionimageinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SECTIONIMAGEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSectionImageInformation {
  void *EntryPoint;
  uint32_t Unknown1;
  uint32_t StackReserve;
  uint32_t StackCommit;
  uint32_t Subsystem;
  uint16_t MinorSubsystemVersion;
  uint16_t MajorSubsystemVersion;
  uint32_t Unknown2;
  uint32_t Characteristics;
  uint16_t ImageNumber;
  uint32_t IsExecutable;
  uint8_t __wut1;
  uint32_t __wut2[3];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtRtlUserProcessInformation {
  uint32_t SizeOfThis;
  int64_t ProcessHandle;
  int64_t ThreadHandle;
  struct NtClientId ClientId;
  struct NtSectionImageInformation ImageInformation;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/size.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SIZE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtSize {
  int32_t cx;
  int32_t cy;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/startupinfoex.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_STARTUPINFOEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtStartupInfoEx {
  struct NtStartupInfo StartupInfo;
  struct NtProcThreadAttributeList *lpAttributeList;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systembasicinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMBASICINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemBasicInformation {
  unsigned char Reserved1[4];
  uint32_t MaximumIncrement;
  uint32_t PhysicalPageSize;
  uint32_t NumberOfPhysicalPages;
  uint32_t LowestPhysicalPage;
  uint32_t HighestPhysicalPage;
  uint32_t AllocationGranularity;
  uint32_t LowestUserAddress;
  uint32_t HighestUserAddress;
  uint32_t ActiveProcessors;
  char NumberOfProcessors;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemexceptioninformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMEXCEPTIONINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemExceptionInformation {
  unsigned char Reserved1[16];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemhandleentry.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMHANDLEENTRY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemHandleEntry {
  uint32_t OwnerPid;
  unsigned char ObjectType;
  unsigned char HandleFlags;
  unsigned short HandleValue;
  void *ObjectPointer;
  uint32_t AccessMask;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemhandleinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMHANDLEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemHandleInformation {
  uint32_t Count;
  struct NtSystemHandleEntry Handle[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systeminfo.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemInfo {
  union {
    uint32_t dwOemId;
    struct {
      uint16_t wProcessorArchitecture;
      uint16_t wReserved;
    };
  };
  uint32_t dwPageSize;
  void *lpMinimumApplicationAddress;
  void *lpMaximumApplicationAddress;
  uintptr_t dwActiveProcessorMask;
  uint32_t dwNumberOfProcessors;
  uint32_t dwProcessorType;
  uint32_t dwAllocationGranularity;
  uint16_t wProcessorLevel;
  uint16_t wProcessorRevision;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systeminterruptinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMINTERRUPTINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemInterruptInformation {
  unsigned char Reserved1[24];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemlookasideinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMLOOKASIDEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemLookasideInformation {
  unsigned char Reserved1[32];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemperformanceinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMPERFORMANCEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemPerformanceInformation {
  int64_t IdleTime;
  int64_t ReadTransferCount;
  int64_t WriteTransferCount;
  int64_t OtherTransferCount;
  uint32_t ReadOperationCount;
  uint32_t WriteOperationCount;
  uint32_t OtherOperationCount;
  uint32_t AvailablePages;
  uint32_t TotalCommittedPages;
  uint32_t TotalCommitLimit;
  uint32_t PeakCommitment;
  uint32_t PageFaults;
  uint32_t WriteCopyFaults;
  uint32_t TransitionFaults;
  uint32_t CacheTransitionFaults;
  uint32_t DemandZeroFaults;
  uint32_t PagesRead;
  uint32_t PageReadIos;
  uint32_t CacheReads;
  uint32_t CacheIos;
  uint32_t PagefilePagesWritten;
  uint32_t PagefilePageWriteIos;
  uint32_t MappedFilePagesWritten;
  uint32_t MappedFilePageWriteIos;
  uint32_t PagedPoolUsage;
  uint32_t NonPagedPoolUsage;
  uint32_t PagedPoolAllocs;
  uint32_t PagedPoolFrees;
  uint32_t NonPagedPoolAllocs;
  uint32_t NonPagedPoolFrees;
  uint32_t TotalFreeSystemPtes;
  uint32_t SystemCodePage;
  uint32_t TotalSystemDriverPages;
  uint32_t TotalSystemCodePages;
  uint32_t SmallNonPagedLookasideListAllocateHits;
  uint32_t SmallPagedLookasideListAllocateHits;
  uint32_t Reserved3;
  uint32_t MmSystemCachePage;
  uint32_t PagedPoolPage;
  uint32_t SystemDriverPage;
  uint32_t FastReadNoWait;
  uint32_t FastReadWait;
  uint32_t FastReadResourceMiss;
  uint32_t FastReadNotPossible;
  uint32_t FastMdlReadNoWait;
  uint32_t FastMdlReadWait;
  uint32_t FastMdlReadResourceMiss;
  uint32_t FastMdlReadNotPossible;
  uint32_t MapDataNoWait;
  uint32_t MapDataWait;
  uint32_t MapDataNoWaitMiss;
  uint32_t MapDataWaitMiss;
  uint32_t PinMappedDataCount;
  uint32_t PinReadNoWait;
  uint32_t PinReadWait;
  uint32_t PinReadNoWaitMiss;
  uint32_t PinReadWaitMiss;
  uint32_t CopyReadNoWait;
  uint32_t CopyReadWait;
  uint32_t CopyReadNoWaitMiss;
  uint32_t CopyReadWaitMiss;
  uint32_t MdlReadNoWait;
  uint32_t MdlReadWait;
  uint32_t MdlReadNoWaitMiss;
  uint32_t MdlReadWaitMiss;
  uint32_t ReadAheadIos;
  uint32_t LazyWriteIos;
  uint32_t LazyWritePages;
  uint32_t DataFlushes;
  uint32_t DataPages;
  uint32_t ContextSwitches;
  uint32_t FirstLevelTbFills;
  uint32_t SecondLevelTbFills;
  uint32_t SystemCalls;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemprocessinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMPROCESSINFORMATION_H_


/*!BEGIN libc/nt/struct/vmcounters.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_VMCOUNTERS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtVmCounters {
  size_t PeakVirtualSize;
  size_t VirtualSize;
  uint32_t PageFaultCount;
  size_t PeakWorkingSetSize;
  size_t WorkingSetSize;
  size_t QuotaPeakPagedPoolUsage;
  size_t QuotaPagedPoolUsage;
  size_t QuotaPeakNonPagedPoolUsage;
  size_t QuotaNonPagedPoolUsage;
  size_t PagefileUsage;
  size_t PeakPagefileUsage;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemProcessInformation {
  uint32_t NextEntryOffset;
  uint32_t NumberOfThreads;
  int64_t Reserved[3];
  int64_t CreateTime;
  int64_t UserTime;
  int64_t KernelTime;
  struct NtUnicodeString ImageName;
  int32_t BasePriority;
  int64_t UniqueProcessId;
  int64_t InheritedFromUniqueProcessId;
  uint32_t HandleCount;
  uint32_t SessionId;
  uint32_t PageDirectoryBase;
  struct NtVmCounters VirtualMemoryCounters;
  size_t PrivatePageCount;
  struct NtIoCounters IoCounters;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemprocessorinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMPROCESSORINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemProcessorInformation {
  unsigned short ProcessorArchitecture;
  unsigned short ProcessorLevel;
  unsigned short ProcessorRevision;
  unsigned short Unknown;
  uint32_t FeatureBits;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemprocessorperformanceinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMPROCESSORPERFORMANCEINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemProcessorPerformanceInformation {
  int64_t IdleTime;
  int64_t KernelTime;
  int64_t UserTime;
  int64_t Reserved1[2];
  uint32_t Reserved2;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemregistryquotainformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMREGISTRYQUOTAINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemRegistryQuotaInformation {
  uint32_t RegistryQuotaAllowed;
  uint32_t RegistryQuotaUsed;
  void *Reserved1;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemthreads.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMTHREADS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemThreads {
  int64_t KernelTime;
  int64_t UserTime;
  int64_t CreateTime;
  uint32_t WaitTime;
  void *StartAddress;
  struct NtClientId ClientId;
  int32_t Priority;
  int32_t BasePriority;
  uint32_t ContextSwitchCount;
  int State;
  uint32_t WaitReason;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemtime.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMTIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemTime {
  uint16_t wYear;
  uint16_t wMonth;
  uint16_t wDayOfWeek;
  uint16_t wDay;
  uint16_t wHour;
  uint16_t wMinute;
  uint16_t wSecond;
  uint16_t wMilliseconds;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/systemtimeofdayinformation.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_SYSTEMTIMEOFDAYINFORMATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtSystemTimeofdayInformation {
  int64_t BootTime;
  int64_t CurrentTime;
  int64_t TimeZoneBias;
  uint32_t CurrentTimeZoneId;
  unsigned char Reserved1[20];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/teb.h */

#define COSMOPOLITAN_LIBC_NT_TEB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
#if defined(__GNUC__) && !defined(__STRICT_ANSI__)

/*
 * These macros address directly into NT's TEB a.k.a. TIB
 * Any function that does this needs the `noasan` keyword
 */
#define NtGetPeb()           gs((struct NtPeb **)(0x60ULL))
#define NtGetTeb()           gs((void **)(0x30))    /* %gs:0 linear address */
#define NtGetPid()           gs((uint32_t *)(0x40)) /* GetCurrentProcessId() */
#define NtGetTid()           gs((uint32_t *)(0x48)) /* GetCurrentThreadId() */
#define NtGetErr()           gs((int *)(0x68))
#define _NtGetSeh()          gs((void **)(0x00))
#define _NtGetStackHigh()    gs((void **)(0x08))
#define _NtGetStackLow()     gs((void **)(0x10))
#define _NtGetSubsystemTib() gs((void **)(0x18))
#define _NtGetFib()          gs((void **)(0x20))
#define _NtGetEnv()          gs((char16_t **)(0x38))
#define _NtGetRpc()          gs((void **)(0x50))
#define _NtGetTls()          gs((void **)(0x58))

#endif /* __GNUC__ && !__STRICT_ANSI__ */
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/tokenprivileges.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_TOKENPRIVILEGES_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtTokenPrivileges {
  uint32_t PrivilegeCount;
  struct NtLuidAndAttributes Privileges[1];
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/userstack.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_NTUSERSTACK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtUserStack {
  void *FixedStackBase;
  void *FixedStackLimit;
  void *ExpandableStackBase;
  void *ExpandableStackLimit;
  void *ExpandableStackBottom;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/valent.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_VALENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtValent {
  char16_t *ve_valuename;
  uint32_t ve_valuelen;
  uintptr_t ve_valueptr;
  uint32_t ve_type;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/win32fileattributedata.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WIN32FILEATTRIBUTEDATA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtWin32FileAttributeData {
  uint32_t dwFileAttributes; /* ←NtFileFlagAndAttributes */
  struct NtFileTime ftCreationTime;
  struct NtFileTime ftLastAccessTime;
  struct NtFileTime ftLastWriteTime;
  uint32_t nFileSizeHigh;
  uint32_t nFileSizeLow;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/win32finddata.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WIN32FINDDATA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtWin32FindData {
  uint32_t dwFileAttributes;
  struct NtFileTime ftCreationTime;
  struct NtFileTime ftLastAccessTime;
  struct NtFileTime ftLastWriteTime;
  uint32_t nFileSizeHigh;
  uint32_t nFileSizeLow;
  uint32_t dwReserved0;
  uint32_t dwReserved1;
  char16_t cFileName[260];
  char16_t cAlternateFileName[14];
  uint32_t dwFileType;
  uint32_t dwCreatorType;
  uint16_t wFinderFlags;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/windowplacement.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WINDOWPLACEMENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct NtWindowPlacement {
  uint32_t length;
  uint32_t flags;
  uint32_t showCmd;
  struct NtPoint ptMinPosition;
  struct NtPoint ptMaxPosition;
  struct NtRect rcNormalPosition;
  struct NtRect rcDevice;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/wndclassex.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WNDCLASSEX_H_


/*!BEGIN libc/nt/typedef/wndproc.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_WNDPROC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef int64_t (*NtWndProc)(int64_t, uint32_t, uint64_t, int64_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtWndClassEx {
  uint32_t cbSize;
  uint32_t style;
  NtWndProc lpfnWndProc;
  int32_t cbClsExtra;
  int32_t cbWndExtra;
  int64_t hInstance;
  int64_t hIcon;
  int64_t hCursor;
  int64_t hbrBackground;
  const char16_t *lpszMenuName;
  const char16_t *lpszClassName;
  int64_t hIconSm;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/struct/wndclass.h */

#define COSMOPOLITAN_LIBC_NT_STRUCT_WNDCLASS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtWndClass {
  uint32_t style;
  NtWndProc lpfnWndProc;
  int32_t cbClsExtra;
  int32_t cbWndExtra;
  int64_t hInstance;
  int64_t hIcon;
  int64_t hCursor;
  int64_t hbrBackground;
  const char16_t *lpszMenuName;
  const char16_t *lpszClassName;
};

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/exceptionhandler.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_EXCEPTIONHANDLER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef unsigned (*NtExceptionHandler)(struct NtExceptionRecord *,
                                       struct NtExceptionFrame *,
                                       struct NtContext *, void *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/handlerroutine.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_HANDLERROUTINE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef bool32 (*NtHandlerRoutine)(uint32_t);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/hookproc.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_HOOKPROC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef intptr_t (*NtHookProc)(int code, uintptr_t wParam, intptr_t lParam);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/imagetlscallback.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_IMAGETLSCALLBACK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*NtImageTlsCallback)(void *DllHandle, uint32_t Reason,
                                   void *Reserved);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/ioapcroutine.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_IOAPCROUTINE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*NtIoApcRoutine)(void *ApcContext,
                               struct NtIoStatusBlock *IoStatusBlock,
                               uint32_t Reserved);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/pknormalroutine.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_PKNORMALROUTINE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*NtPkNormalRoutine)(void *NormalContext, void *SystemArgument1,
                                  void *SystemArgument2);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/timerproc.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_TIMERPROC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef void (*NtTimerProc)(int64_t, uint32_t, uintptr_t, uint32_t);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/wambda.h */

#define COSMOPOLITAN_LIBC_NT_WAMBDA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef intptr_t (*wambda)();

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/typedef/wndenumproc.h */

#define COSMOPOLITAN_LIBC_NT_TYPEDEF_WNDENUMPROC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef int (*NtWndEnumProc)(int64_t foo, intptr_t bar);

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/thunk/msabi.h */

#define COSMOPOLITAN_LIBC_NT_THUNK_MSABI_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

#if !defined(__STRICT_ANSI__) &&               \
    (__GNUC__ * 100 + __GNUC_MINOR__ >= 408 || \
     (__has_attribute(__ms_abi__) || defined(__llvm__)))
/**
 * Defines function as using Microsoft x64 calling convention.
 *
 * This can be used to define prototypes that allow modern compilers to
 * generate code that calls MS ABI functions directly, without needing
 * to jump through the assembly thunks.
 */
#define __msabi __attribute__((__ms_abi__))
#endif

/*
 * Returns true if header should provide MS-ABI overrides.
 */
#ifndef ShouldUseMsabiAttribute
#if defined(__msabi) && defined(NDEBUG) && !defined(__PG__)
#define ShouldUseMsabiAttribute() 1
#else
#define ShouldUseMsabiAttribute() 0
#endif
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/debug.h */

#define COSMOPOLITAN_LIBC_NT_NT_DEBUG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » debugging              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus NtContinue(struct NtContext *Context, int32_t TestAlert);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/file.h */

#define COSMOPOLITAN_LIBC_NT_NT_FILE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » files                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtIoStatusBlock;
struct NtObjectAttributes;

NtStatus NtClose(int64_t handle);

NtStatus NtCreateFile(int64_t *out_FileHandle, uint32_t DesiredAccess,
                      struct NtObjectAttributes *ObjectAttributes,
                      struct NtIoStatusBlock *out_IoStatusBlock,
                      int64_t *opt_AllocationSize, uint32_t FileAttributes,
                      uint32_t ShareAccess, uint32_t CreateDisposition,
                      uint32_t CreateOptions, void *opt_EaBuffer,
                      uint32_t EaLength);

NtStatus NtReadFile(int64_t FileHandle, void *opt_Event,
                    NtIoApcRoutine opt_ApcRoutine, void *opt_ApcContext,
                    struct NtIoStatusBlock *out_IoStatusBlock, void *out_Buffer,
                    uint32_t Length, int64_t *opt_ByteOffset,
                    uint32_t *opt_Key);

NtStatus NtWriteFile(int64_t FileHandle, void *opt_Event,
                     NtIoApcRoutine opt_ApcRoutine, void *opt_ApcContext,
                     struct NtIoStatusBlock *out_IoStatusBlock,
                     const void *Buffer, uint32_t Length,
                     int64_t *opt_ByteOffset, uint32_t *opt_Key);

NtStatus NtDuplicateObject(int64_t SourceProcessHandle, void *SourceHandle,
                           void *TargetProcessHandle,
                           void **opt_out_TargetHandle, uint32_t DesiredAcess,
                           uint32_t Atrributes, uint32_t options_t);

NtStatus NtQueryInformationFile(int64_t FileHandle,
                                struct NtIoStatusBlock *out_IoStatusBlock,
                                void *out_FileInformation,
                                uint32_t FileInformationLength,
                                uint32_t FileInformationClass);

NtStatus NtSetInformationFile(int64_t FileHandle,
                              struct NtIoStatusBlock *out_IoStatusBlock,
                              void *FileInformation,
                              uint32_t FileInformationLength,
                              uint32_t FileInformationClass);

NtStatus NtDeviceIoControlFile(
    int64_t FileHandle, int64_t opt_Event, NtIoApcRoutine opt_ApcRoutine,
    void *opt_ApcContext, struct NtIoStatusBlock *out_IoStatusBlock,
    uint32_t IoControlCode, void *opt_InputBuffer, uint32_t InputBufferLength,
    void *opt_out_OutputBuffer, uint32_t OutputBufferLength);

NtStatus NtCancelIoFileEx(int64_t FileHandle,
                          struct NtIoStatusBlock *IoRequestToCancel,
                          struct NtIoStatusBlock *IoStatusBlock);

NtStatus RtlNtStatusToDosError(NtStatus Status);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/ntfile.inc */

#define NtQueryInformationFile(...) __imp_NtQueryInformationFile(__VA_ARGS__)

extern typeof(NtQueryInformationFile) *const
    __imp_NtQueryInformationFile __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/ipc.h */

#define COSMOPOLITAN_LIBC_NT_NT_IPC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » ipc                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtIoStatusBlock;
struct NtObjectAttributes;

NtStatus NtCreateNamedPipeFile(int64_t *out_FileHandle, uint32_t DesiredAccess,
                               struct NtObjectAttributes *ObjectAttributes,
                               struct NtIoStatusBlock *out_IoStatusBlock,
                               uint32_t ShareAccess, uint32_t CreateDisposition,
                               uint32_t CreateOptions, int32_t TypeMessage,
                               int32_t ReadmodeMessage, int32_t Nonblocking,
                               uint32_t MaxInstances, uint32_t InBufferSize,
                               uint32_t OutBufferSize,
                               int64_t *opt_DefaultTimeout);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/key.h */

#define COSMOPOLITAN_LIBC_NT_NT_EVENT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » files                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus NtCreateKeyedEvent(int64_t *KeyedEventHandle, uint32_t DesiredAccess,
                            struct NtObjectAttributes *ObjectAttributes,
                            uint32_t Flags);

NtStatus NtReleaseKeyedEvent(int64_t KeyedEventHandle, void *KeyValue,
                             bool32 Alertable, int64_t *Timeout);

NtStatus NtWaitForKeyedEvent(int64_t KeyedEventHandle, void *KeyValue,
                             bool32 Alertable, int64_t *Timeout);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/loader.h */

#define COSMOPOLITAN_LIBC_NT_NT_LOADER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » loader                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtAnsiString;
struct NtLdrDataTableEntry;
struct NtUnicodeString;

NtStatus LdrLoadDll(const char16_t *opt_PathToFile, uint32_t *opt_Flags,
                    struct NtUnicodeString *ModuleFileName,
                    void **out_ModuleHandle);
NtStatus LdrUnloadDll(void *ModuleHandle);
NtStatus LdrGetProcedureAddress(void *ModuleHandle,
                                struct NtAnsiString *opt_ProcedureName,
                                uint32_t opt_Ordinal,
                                wambda *out_ProcedureAddress);
NtStatus LdrGetDllHandle(const char16_t *opt_PathToFile, uint32_t opt_Unused,
                         struct NtUnicodeString *ModuleFileName,
                         void **out_ModuleHandle);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/memory.h */

#define COSMOPOLITAN_LIBC_NT_NT_MEMORY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » memory                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus NtAllocateVirtualMemory(int64_t ProcessHandle,
                                 void **inout_BaseAddress, uint32_t dwZeroBits,
                                 uint32_t *inout_AllocationSize,
                                 uint32_t dwMemAllocationType,
                                 uint32_t dwPageProtect);
NtStatus NtFreeVirtualMemory(int64_t ProcessHandle, void **inout_BaseAddress,
                             size_t *inout_FreeSize, uint32_t FreeType);
NtStatus NtQueryVirtualMemory(int64_t ProcessHandle, const void *BaseAddress,
                              int MemoryInformationClass,
                              void *out_MemoryInformation,
                              size_t MemoryInformationLength,
                              size_t *opt_out_ReturnLength);
NtStatus NtProtectVirtualMemory(int64_t ProcessHandle, void **inout_BaseAddress,
                                uint32_t *inout_ProtectSize,
                                uint32_t NewProtect, uint32_t *out_OldProtect);
NtStatus NtWriteVirtualMemory(int64_t ProcessHandle, void *BaseAddress,
                              const void *Buffer, size_t BufferLength,
                              size_t *opt_out_ReturnLength);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/process.h */

#define COSMOPOLITAN_LIBC_NT_NT_PROCESS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » processes              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtClientId;
struct NtObjectAttributes;
struct NtRtlUserProcessInformation;
struct NtRtlUserProcessParameters;
struct NtSecurityDescriptor;
struct NtUnicodeString;

NtStatus NtCreateProcess(int64_t *out_ProcessHandle, uint32_t dwDesiredAccess,
                         struct NtObjectAttributes *opt_ObjectAttributes,
                         void *InheritFromProcessHandle, int32_t InheritHandles,
                         void *opt_SectionHandle, void *opt_DebugPort,
                         void *opt_ExceptionPort);
NtStatus NtTerminateProcess(int64_t opt_ProcessHandle, int32_t ExitStatus);

NtStatus NtQueryInformationProcess(int64_t ProcessHandle,
                                   int ProcessInformationClass,
                                   void *out_ProcessInformation,
                                   uint32_t ProcessInformationLength,
                                   uint32_t *opt_out_ReturnLength);
NtStatus NtOpenProcessToken(int64_t ProcessToken, uint32_t DesiredAccess,
                            int64_t *out_TokenHandle);
NtStatus NtOpenProcess(int64_t *out_ProcessHandle, uint32_t DesiredAccess,
                       struct NtObjectAttributes *ObjectAttributes,
                       struct NtClientId *ClientId);

NtStatus RtlCreateProcessParameters(
    struct NtRtlUserProcessParameters **out_ProcessParameters,
    struct NtUnicodeString *ImageFile, struct NtUnicodeString *opt_DllPath,
    struct NtUnicodeString *opt_CurrentDirectory,
    struct NtUnicodeString *opt_CommandLine, uint32_t CreationFlags,
    struct NtUnicodeString *opt_WindowTitle,
    struct NtUnicodeString *opt_Desktop, struct NtUnicodeString *opt_Reserved,
    struct NtUnicodeString *opt_Reserved2);

NtStatus RtlDestroyProcessParameters(
    struct NtRtlUserProcessParameters *ProcessParameters);

NtStatus RtlCloneUserProcess(
    uint32_t ProcessFlags,
    struct NtSecurityDescriptor *opt_ProcessSecurityDescriptor,
    struct NtSecurityDescriptor *opt_ThreadSecurityDescriptor,
    void *opt_DebugPort,
    struct NtRtlUserProcessInformation *ProcessInformation);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/nt/thunk/process.inc */

#define NtQueryInformationProcess(...) \
  __imp_NtQueryInformationProcess(__VA_ARGS__)

extern typeof(NtQueryInformationProcess) *const
    __imp_NtQueryInformationProcess __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/sections.h */

#define COSMOPOLITAN_LIBC_NT_NT_SECTIONS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

NtStatus NtCreateSection(int64_t *out_SectionHandle, uint32_t DesiredAccess,
                         struct NtObjectAttributes *ObjectAttributes,
                         int64_t *opt_SectionSize, uint32_t Protect,
                         uint32_t Attributes, int64_t FileHandle);
NtStatus NtOpenSection(int64_t *out_SectionHandle, uint32_t DesiredAccess,
                       struct NtObjectAttributes *ObjectAttributes);
NtStatus NtMapViewOfSection(int64_t SectionHandle, int64_t ProcessHandle,
                            void **inout_BaseAddress, uint32_t *ZeroBits,
                            size_t CommitSize, int64_t *opt_inout_SectionOffset,
                            size_t *inout_ViewSize, int InheritDisposition,
                            uint32_t AllocationType, uint32_t Protect);
NtStatus NtUnmapViewOfSection(int64_t ProcessHandle, void *BaseAddress);
NtStatus NtQuerySection(int64_t SectionHandle, int SectionInformationClass,
                        void *out_SectionInformation,
                        uint32_t SectionInformationLength,
                        uint32_t *opt_out_ResultLength);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/signing.h */

#define COSMOPOLITAN_LIBC_NT_NT_SIGNING_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » code signing           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus CsrClientCallServer(void *inout_Message, void *unknown,
                             uint32_t Opcode, uint32_t Size);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/thread.h */

#define COSMOPOLITAN_LIBC_NT_NT_THREAD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » threads                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

struct NtClientId;
struct NtContext;
struct NtObjectAttributes;
struct NtUserStack;

NtStatus NtCreateThread(int64_t *out_ThreadHandle, uint32_t DesiredAccess,
                        struct NtObjectAttributes *ObjectAttributes,
                        int64_t ProcessHandle, struct NtClientId *out_ClientId,
                        struct NtContext *ThreadContext,
                        struct NtUserStack *UserStack, int32_t CreateSuspended);

NtStatus NtTerminateThread(void *opt_ThreadHandle, int32_t ExitStatus);

NtStatus NtOpenThread(int64_t *out_ThreadHandle, uint32_t DesiredAccess,
                      struct NtObjectAttributes *ObjectAttributes,
                      struct NtClientId *ClientId);

NtStatus NtQueryInformationThread(int64_t ThreadHandle,
                                  enum NtThreadInfoClass ThreadInformationClass,
                                  void *out_ThreadInformation,
                                  uint32_t ThreadInformationLength,
                                  uint32_t *opt_out_ReturnLength);

NtStatus NtGetContextThread(int64_t ThreadHandle,
                            struct NtContext *out_Context);
NtStatus NtSetContextThread(int64_t ThreadHandle, struct NtContext *Context);
NtStatus NtSuspendThread(int64_t ThreadHandle,
                         uint32_t *opt_out_PreviousSuspendCount);
NtStatus NtResumeThread(int64_t ThreadHandle,
                        uint32_t *opt_out_PreviousSuspendCount);

NtStatus NtOpenThreadToken(int64_t ThreadHandle, uint32_t DesiredAccess,
                           int32_t OpenAsSelf, int64_t *out_TokenHandle);

NtStatus NtSetInformationThread(int64_t ThreadHandle,
                                enum NtThreadInfoClass ThreadInformationClass,
                                void *ThreadInformation,
                                uint32_t ThreadInformationLength);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/nt/time.h */

#define COSMOPOLITAN_LIBC_NT_NT_THREAD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale » time                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

NtStatus NtDelayExecution(bool32 alertable, int64_t *AbsCobolOrNegRelHectoNano);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/nt/thunk/time.inc */

#define NtDelayExecution(...) __imp_NtDelayExecution(__VA_ARGS__)

extern typeof(NtDelayExecution) *const __imp_NtDelayExecution __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/accounting.h */

#define COSMOPOLITAN_LIBC_NT_ACCOUNTING_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » accounting                               ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int GetUserName(char16_t (*buf)[257], uint32_t *in_out_size);
bool32 GlobalMemoryStatusEx(struct NtMemoryStatusEx *lpBuffer);
int32_t GetExitCodeProcess(int64_t hProcess, uint32_t *lpExitCode);
int32_t GetProcessHandleCount(int64_t hProcess, uint32_t *pdwHandleCount);
bool32 GetProcessTimes(int64_t hProcess,
                       struct NtFileTime *out_lpCreationFileTime,
                       struct NtFileTime *out_lpExitFileTime,
                       struct NtFileTime *out_lpKernelFileTime,
                       struct NtFileTime *out_lpUserFileTime);
bool32 GetThreadTimes(int64_t hThread,
                      struct NtFileTime *out_lpCreationFileTime,
                      struct NtFileTime *out_lpExitFileTime,
                      struct NtFileTime *out_lpKernelFileTime,
                      struct NtFileTime *out_lpUserFileTime);
int32_t GetProcessIoCounters(int64_t hProcess,
                             struct NtIoCounters *lpIoCounters);
int32_t GetProcessWorkingSetSize(int64_t hProcess,
                                 uint64_t *lpMinimumWorkingSetSize,
                                 uint64_t *lpMaximumWorkingSetSize);
int32_t GetProcessWorkingSetSizeEx(int64_t hProcess,
                                   uint64_t *lpMinimumWorkingSetSize,
                                   uint64_t *lpMaximumWorkingSetSize,
                                   uint32_t *Flags);
int32_t SetProcessWorkingSetSize(int64_t hProcess,
                                 uint64_t dwMinimumWorkingSetSize,
                                 uint64_t dwMaximumWorkingSetSize);
int32_t SetProcessWorkingSetSizeEx(int64_t hProcess,
                                   uint64_t dwMinimumWorkingSetSize,
                                   uint64_t dwMaximumWorkingSetSize,
                                   uint32_t Flags);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/accounting.inc */

#define GetProcessTimes(...) __imp_GetProcessTimes(__VA_ARGS__)
extern typeof(GetProcessTimes) *const __imp_GetProcessTimes __msabi;

#define GetThreadTimes(...) __imp_GetThreadTimes(__VA_ARGS__)
extern typeof(GetThreadTimes) *const __imp_GetThreadTimes __msabi;

#define GetUserName(...) __imp_GetUserNameW(__VA_ARGS__)
extern typeof(GetUserName) *const __imp_GetUserNameW __msabi;

#define GetExitCodeProcess(...) __imp_GetExitCodeProcess(__VA_ARGS__)
extern typeof(GetExitCodeProcess) *const __imp_GetExitCodeProcess __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/automation.h */

#define COSMOPOLITAN_LIBC_NT_AUTOMATION_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » aol hacking                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int64_t GetShellWindow(void);
int64_t GetDesktopWindow(void);
int64_t GetParent(int64_t hWnd);
int64_t SetParent(int64_t hWndChild, int64_t hWndNewParent);
int32_t EnumChildWindows(int64_t hWndParent, NtWndEnumProc lpEnumFunc,
                         intptr_t lParam);
int64_t FindWindow(const char16_t *lpClassName, const char16_t *lpWindowName);
int64_t FindWindowEx(int64_t hWndParent, int64_t hWndChildAfter,
                     const char16_t *lpszClass, const char16_t *lpszWindow);
int64_t GetWindow(int64_t hWnd, uint32_t uCmd);
int64_t SetWindowsHook(int nFilterType, NtHookProc pfnFilterProc);
int32_t UnhookWindowsHook(int nCode, NtHookProc pfnFilterProc);
int64_t SetWindowsHookEx(int idHook, NtHookProc lpfn, int64_t hmod,
                         uint32_t dwThreadId);
int32_t UnhookWindowsHookEx(int64_t hhk);
intptr_t CallNextHookEx(int64_t hhk, int nCode, uintptr_t wParam,
                        intptr_t lParam);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/codegen.h */

#define COSMOPOLITAN_LIBC_NT_CODEGEN_H_


/*!BEGIN libc/nt/comdlg.h */

#define COSMOPOLITAN_LIBC_NT_COMDLG_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » common dialogs                           ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 GetOpenFileName(struct NtOpenFilename *arg);
bool32 GetSaveFileName(struct NtOpenFilename *arg);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/console.h */

#define COSMOPOLITAN_LIBC_NT_CONSOLE_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » console                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtAttachParentProcess -1u

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 WriteConsoleOutput(int64_t hConsoleOutput,
                          const struct NtCharInfo *lpBuffer,
                          struct NtCoord dwBufferSize,
                          struct NtCoord dwBufferCoord,
                          struct NtSmallRect *lpWriteRegion);
bool32 ReadConsoleInput(int64_t hConsoleInput, struct NtInputRecord *lpBuffer,
                        uint32_t nLength, uint32_t *lpNumberOfEventsRead);
bool32 PeekConsoleInput(int64_t hConsoleInput, struct NtInputRecord *lpBuffer,
                        uint32_t nLength, uint32_t *lpNumberOfEventsRead);
bool32 GetNumberOfConsoleInputEvent(int64_t hConsoleInput,
                                    uint32_t *lpNumberOfEvents);
bool32 ReadConsoleOutput(int64_t hConsoleOutput, struct NtCharInfo *lpBuffer,
                         struct NtCoord dwBufferSize,
                         struct NtCoord dwBufferCoord,
                         struct NtSmallRect *lpReadRegion);
bool32 WriteConsoleInput(int64_t hConsoleInput,
                         const struct NtInputRecord *lpBuffer, uint32_t nLength,
                         uint32_t *lpNumberOfEventsWritten);
bool32 FlushConsoleInputBuffer(int64_t hConsoleInput);

int64_t GetConsoleWindow(void);
bool32 GetConsoleMode(int64_t hConsoleHandle, uint32_t *lpMode);
bool32 SetConsoleMode(int64_t hConsoleHandle, uint32_t dwMode);
int32_t AllocConsole(void);
int32_t FreeConsole(void);
int32_t AttachConsole(uint32_t dwProcessId);
uint32_t GetConsoleTitle(char16_t *lpConsoleTitle, uint32_t nSize);
int32_t SetConsoleTitle(const char16_t *lpConsoleTitle);
bool32 GetConsoleScreenBufferInfo(
    int64_t hConsoleOutput,
    struct NtConsoleScreenBufferInfo *out_lpConsoleScreenBufferInfo);
bool32 GetConsoleScreenBufferInfoEx(
    int64_t hConsoleOutput,
    struct NtConsoleScreenBufferInfoEx *in_out_lpConsoleScreenBufferInfo);
bool32 SetConsoleScreenBufferInfoEx(
    int64_t hConsoleOutput,
    const struct NtConsoleScreenBufferInfoEx *lpConsoleScreenBufferInfo);
bool32 SetConsoleScreenBufferSize(int64_t lpConsoleOutput,
                                  struct NtCoord dwSize);
struct NtCoord GetLargestConsoleWindowSize(int64_t hConsoleHandle);
int32_t ReadConsole(int64_t hConsoleInput, void *lpBuffer,
                    uint32_t nNumberOfCharsToRead,
                    uint32_t *lpNumberOfCharsRead, void *lpReserved);
int32_t WriteConsole(int64_t hConsoleOutput, const void *lpBuffer,
                     uint32_t nNumberOfCharsToWrite,
                     uint32_t *lpNumberOfCharsWritten, void *lpReserved)
    paramsnonnull((2, 4));
bool32 GetNumberOfConsoleMouseButtons(uint32_t *out_lpNumberOfMouseButtons)
    paramsnonnull();
bool32 GetConsoleSelectionInfo(
    struct NtConsoleSelectionInfo *out_lpConsoleSelectionInfo);
uint32_t WaitForInputIdle(int64_t hProcess, uint32_t dwMilliseconds);
uint32_t GetConsoleCP(void);
bool32 SetConsoleCP(uint32_t wCodePageID);
bool32 SetConsoleOutputCP(uint32_t wCodePageID);
uint32_t GetConsoleOutputCP(void);
bool32 SetConsoleCtrlHandler(NtHandlerRoutine opt_HandlerRoutine, bool32 Add);
bool32 GenerateConsoleCtrlEvent(uint32_t dwCtrlEvent,
                                uint32_t dwProcessGroupId);

bool32 GetConsoleCursorInfo(
    int64_t hConsoleOutput,
    struct NtConsoleCursorInfo *out_lpConsoleCursorInfo);
bool32 SetConsoleCursorInfo(
    int64_t hConsoleOutput,
    const struct NtConsoleCursorInfo *lpConsoleCursorInfo);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/console.inc */

#define GetConsoleMode(...) __imp_GetConsoleMode(__VA_ARGS__)
extern typeof(GetConsoleMode) *const __imp_GetConsoleMode __msabi;

#define SetConsoleCP(...) __imp_SetConsoleCP(__VA_ARGS__)
extern typeof(SetConsoleCP) *const __imp_SetConsoleCP __msabi;

#define GetConsoleCP(...) __imp_GetConsoleCP(__VA_ARGS__)
extern typeof(GetConsoleCP) *const __imp_GetConsoleCP __msabi;

#define SetConsoleCtrlHandler(...) __imp_SetConsoleCtrlHandler(__VA_ARGS__)
extern typeof(SetConsoleCtrlHandler) *const __imp_SetConsoleCtrlHandler __msabi;

#define SetConsoleMode(...) __imp_SetConsoleMode(__VA_ARGS__)
extern typeof(SetConsoleMode) *const __imp_SetConsoleMode __msabi;

#define SetConsoleOutputCP(...) __imp_SetConsoleOutputCP(__VA_ARGS__)
extern typeof(SetConsoleOutputCP) *const __imp_SetConsoleOutputCP __msabi;

#define GetConsoleOutputCP(...) __imp_GetConsoleOutputCP(__VA_ARGS__)
extern typeof(GetConsoleOutputCP) *const __imp_GetConsoleOutputCP __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/createfile.h */

#define COSMOPOLITAN_LIBC_NT_CREATEFILE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int64_t CreateFile(
    const char16_t *lpFileName, uint32_t dwDesiredAccess, uint32_t dwShareMode,
    struct NtSecurityAttributes *opt_lpSecurityAttributes,
    int dwCreationDisposition,
    uint32_t dwFlagsAndAttributes, /* libc/nt/enum/fileflagandattributes.h */
    int64_t opt_hTemplateFile) paramsnonnull((1));

int64_t CreateFileA(
    const char *lpFileName, uint32_t dwDesiredAccess, uint32_t dwShareMode,
    struct NtSecurityAttributes *opt_lpSecurityAttributes,
    int dwCreationDisposition,
    uint32_t dwFlagsAndAttributes, /* libc/nt/enum/fileflagandattributes.h */
    int64_t opt_hTemplateFile) paramsnonnull((1));

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/debug.h */

#define COSMOPOLITAN_LIBC_NT_DEBUG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » debugging                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

/* Some of these APIs were moved to system.h and libc.h */
int32_t DebugBreakProcess(void *Process);
int32_t DebugActiveProcess(uint32_t dwProcessId);
int32_t DebugActiveProcessStop(uint32_t dwProcessId);
int32_t CheckRemoteDebuggerPresent(int64_t hProcess, int *pbDebuggerPresent);
int32_t ContinueDebugEvent(uint32_t dwProcessId, uint32_t dwThreadId,
                           uint32_t dwContinueStatus);
void FatalExit(int uExitCode);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/dll.h */

#define COSMOPOLITAN_LIBC_NT_DLL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » dynamic link libraries                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int64_t LoadLibrary(const char16_t *lpLibFileName);
int64_t LoadLibraryEx(const char16_t *lpLibFileName, int64_t hFile,
                      uint32_t dwFlags);
uint32_t GetModuleFileName(int64_t hModule, char16_t *lpFilename,
                           uint32_t nSize);
uint32_t GetModuleFileNameA(int64_t hModule, char *lpFilename, uint32_t nSize);
intptr_t GetModuleHandle(const char *opt_lpModuleName);
intptr_t GetModuleHandleW(const char16_t *opt_lpModuleName);
void *GetProcAddress(int64_t hModule, const char *lpProcName);
int32_t FreeResource(int64_t hResData);
intptr_t LockResource(int64_t hResData);
int32_t FreeLibrary(int64_t hLibModule);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/errors.h */

#define COSMOPOLITAN_NT_ERRORS_H_

#define kNtErrorInsufficientBuffer 122

#define kNtErrorSuccess 0
#define kNtErrorInvalidFunction 1  /* ENOSYS */
#define kNtErrorFileNotFound 2     /* ENOENT */
#define kNtErrorPathNotFound 3     /* ENOTDIR */
#define kNtErrorTooManyOpenFiles 4 /* EMFILE */
#define kNtErrorAccessDenied 5     /* EACCES */
#define kNtErrorInvalidHandle 6    /* EBADF */
#define kNtErrorArenaTrashed 7
#define kNtErrorNotEnoughMemory 8
#define kNtErrorInvalidBlock 9
#define kNtErrorBadEnvironment 10
#define kNtErrorBadFormat 11
#define kNtErrorInvalidAccess 12 /* EPERM */
#define kNtErrorInvalidData 13
#define kNtErrorOutofmemory 14 /* ENOMEM */
#define kNtErrorInvalidDrive 15
#define kNtErrorCurrentDirectory 16
#define kNtErrorNotSameDevice 17
#define kNtErrorNoMoreFiles 18
#define kNtErrorWriteProtect 19
#define kNtErrorBadUnit 20
#define kNtErrorNotReady 21
#define kNtErrorBadCommand 22
#define kNtErrorCrc 23
#define kNtErrorBadLength 24
#define kNtErrorSeek 25       /* ESPIPE */
#define kNtErrorNotDosDisk 26 /* ENOTBLK */
#define kNtErrorSectorNotFound 27
#define kNtErrorOutOfPaper 28
#define kNtErrorWriteFault 29
#define kNtErrorReadFault 30
#define kNtErrorGenFailure 31
#define kNtErrorSharingViolation 32
#define kNtErrorLockViolation 33
#define kNtErrorWrongDisk 34
#define kNtErrorSharingBufferExceeded 36
#define kNtErrorHandleEof 38 /* w/ GetOverlappedResult() */
#define kNtErrorHandleDiskFull 39
#define kNtErrorNotSupported 50
#define kNtErrorRemNotList 51
#define kNtErrorDupName 52
#define kNtErrorBadNetpath 53
#define kNtErrorNetworkBusy 54
#define kNtErrorDevNotExist 55
#define kNtErrorTooManyCmds 56
#define kNtErrorAdapHdwErr 57
#define kNtErrorBadNetResp 58
#define kNtErrorUnexpNetErr 59
#define kNtErrorBadRemAdap 60
#define kNtErrorPrintqFull 61
#define kNtErrorNoSpoolSpace 62
#define kNtErrorPrintCancelled 63
#define kNtErrorNetnameDeleted 64
#define kNtErrorNetworkAccessDenied 65
#define kNtErrorBadDevType 66
#define kNtErrorBadNetName 67
#define kNtErrorTooManyNames 68
#define kNtErrorTooManySess 69
#define kNtErrorSharingPaused 70
#define kNtErrorReqNotAccep 71
#define kNtErrorRedirPaused 72
#define kNtErrorFileExists 80 /* EEXIST */
#define kNtErrorCannotMake 82
#define kNtErrorFailI24 83
#define kNtErrorOutOfStructures 84
#define kNtErrorAlreadyAssigned 85
#define kNtErrorInvalidPassword 86
#define kNtErrorInvalidParameter 87 /* EINVAL */
#define kNtErrorNetWriteFault 88
#define kNtErrorNoProcSlots 89
#define kNtErrorTooManySemaphores 100
#define kNtErrorExclSemAlreadyOwned 101
#define kNtErrorSemIsSet 102
#define kNtErrorTooManySemRequests 103
#define kNtErrorInvalidAtInterruptTime 104
#define kNtErrorSemOwnerDied 105
#define kNtErrorSemUserLimit 106
#define kNtErrorDiskChange 107
#define kNtErrorDriveLocked 108
#define kNtErrorBrokenPipe 109 /* EPIPE; happens on ReadFile() too */
#define kNtErrorOpenFailed 110
#define kNtErrorBufferOverflow 111
#define kNtErrorDiskFull 112 /* ENOSPC */
#define kNtErrorNoMoreSearchHandles 113
#define kNtErrorInvalidTargetHandle 114
#define kNtErrorInvalidCategory 117
#define kNtErrorInvalidVerifySwitch 118
#define kNtErrorBadDriverLevel 119
#define kNtErrorCallNotImplemented 120
#define kNtErrorSemTimeout 121
#define kNtErrorInsufficientBuffer 122
#define kNtErrorInvalidName 123
#define kNtErrorInvalidLevel 124
#define kNtErrorNoVolumeLabel 125
#define kNtErrorModNotFound 126
#define kNtErrorProcNotFound 127
#define kNtErrorWaitNoChildren 128 /* ECHILD */
#define kNtErrorChildNotComplete 129
#define kNtErrorDirectAccessHandle 130
#define kNtErrorNegativeSeek 131
#define kNtErrorSeekOnDevice 132
#define kNtErrorIsJoinTarget 133
#define kNtErrorIsJoined 134
#define kNtErrorIsSubsted 135
#define kNtErrorNotJoined 136
#define kNtErrorNotSubsted 137
#define kNtErrorJoinToJoin 138
#define kNtErrorSubstToSubst 139
#define kNtErrorJoinToSubst 140
#define kNtErrorSubstToJoin 141
#define kNtErrorBusyDrive 142
#define kNtErrorSameDrive 143
#define kNtErrorDirNotRoot 144
#define kNtErrorDirNotEmpty 145
#define kNtErrorIsSubstPath 146
#define kNtErrorIsJoinPath 147
#define kNtErrorPathBusy 148 /* ETXTBSY */
#define kNtErrorIsSubstTarget 149
#define kNtErrorSystemTrace 150
#define kNtErrorInvalidEventCount 151
#define kNtErrorTooManyMuxwaiters 152
#define kNtErrorInvalidListFormat 153
#define kNtErrorLabelTooLong 154
#define kNtErrorTooManyTcbs 155
#define kNtErrorSignalRefused 156
#define kNtErrorDiscarded 157
#define kNtErrorNotLocked 158
#define kNtErrorBadThreadidAddr 159
#define kNtErrorBadArguments 160
#define kNtErrorBadPathname 161
#define kNtErrorSignalPending 162
#define kNtErrorMaxThrdsReached 164
#define kNtErrorLockFailed 167
#define kNtErrorBusy 170 /* EBUSY */
#define kNtErrorDeviceSupportInProgress 171
#define kNtErrorCancelViolation 173
#define kNtErrorAtomicLocksNotSupported 174
#define kNtErrorInvalidSegmentNumber 180
#define kNtErrorInvalidOrdinal 182
#define kNtErrorAlreadyExists 183 /* EEXIST */
#define kNtErrorInvalidFlagNumber 186
#define kNtErrorSemNotFound 187
#define kNtErrorInvalidStartingCodeseg 188
#define kNtErrorInvalidStackseg 189
#define kNtErrorInvalidModuletype 190
#define kNtErrorInvalidExeSignature 191
#define kNtErrorExeMarkedInvalid 192
#define kNtErrorBadExeFormat 193 /* ENOEXEC */
#define kNtErrorIteratedDataExceeds_64k 194
#define kNtErrorInvalidMinallocsize 195
#define kNtErrorDynlinkFromInvalidRing 196
#define kNtErrorIoplNotEnabled 197
#define kNtErrorInvalidSegdpl 198
#define kNtErrorAutodatasegExceeds_64k 199
#define kNtErrorRing2segMustBeMovable 200
#define kNtErrorRelocChainXeedsSeglim 201
#define kNtErrorInfloopInRelocChain 202
#define kNtErrorEnvvarNotFound 203
#define kNtErrorNoSignalSent 205
#define kNtErrorFilenameExcedRange 206
#define kNtErrorRing2StackInUse 207
#define kNtErrorMetaExpansionTooLong 208
#define kNtErrorInvalidSignalNumber 209
#define kNtErrorThread_1Inactive 210
#define kNtErrorLocked 212
#define kNtErrorTooManyModules 214
#define kNtErrorNestingNotAllowed 215
#define kNtErrorExeMachineTypeMismatch 216
#define kNtErrorExeCannotModifySignedBinary 217
#define kNtErrorExeCannotModifyStrongSignedBinary 218
#define kNtErrorFileCheckedOut 220
#define kNtErrorCheckoutRequired 221
#define kNtErrorBadFileType 222
#define kNtErrorFileTooLarge 223 /* EFBIG */
#define kNtErrorFormsAuthRequired 224
#define kNtErrorVirusInfected 225
#define kNtErrorVirusDeleted 226
#define kNtErrorPipeLocal 229
#define kNtErrorBadPipe 230
#define kNtErrorPipeBusy 231
#define kNtErrorNoData 232
#define kNtErrorPipeNotConnected 233
#define kNtErrorMoreData 234
#define kNtErrorNoWorkDone 235
#define kNtErrorVcDisconnected 240
#define kNtErrorInvalidEaName 254
#define kNtErrorEaListInconsistent 255
#define kNtErrorNoMoreItems 259
#define kNtErrorCannotCopy 266
#define kNtErrorDirectory 267
#define kNtErrorEasDidntFit 275
#define kNtErrorEaFileCorrupt 276
#define kNtErrorEaTableFull 277
#define kNtErrorInvalidEaHandle 278
#define kNtErrorEasNotSupported 282
#define kNtErrorNotOwner 288
#define kNtErrorTooManyPosts 298
#define kNtErrorPartialCopy 299
#define kNtErrorOplockNotGranted 300
#define kNtErrorInvalidOplockProtocol 301
#define kNtErrorDiskTooFragmented 302
#define kNtErrorDeletePending 303
#define kNtErrorIncompatibleWithGlobalShortNameRegistrySetting 304
#define kNtErrorShortNamesNotEnabledOnVolume 305
#define kNtErrorSecurityStreamIsInconsistent 306
#define kNtErrorInvalidLockRange 307
#define kNtErrorImageSubsystemNotPresent 308
#define kNtErrorNotificationGuidAlreadyDefined 309
#define kNtErrorInvalidExceptionHandler 310
#define kNtErrorDuplicatePrivileges 311
#define kNtErrorNoRangesProcessed 312
#define kNtErrorNotAllowedOnSystemFile 313
#define kNtErrorDiskResourcesExhausted 314
#define kNtErrorInvalidToken 315
#define kNtErrorDeviceFeatureNotSupported 316
#define kNtErrorMrMidNotFound 317
#define kNtErrorScopeNotFound 318
#define kNtErrorUndefinedScope 319
#define kNtErrorInvalidCap 320
#define kNtErrorDeviceUnreachable 321
#define kNtErrorDeviceNoResources 322
#define kNtErrorDataChecksumError 323
#define kNtErrorIntermixedKernelEaOperation 324
#define kNtErrorFileLevelTrimNotSupported 326
#define kNtErrorOffsetAlignmentViolation 327
#define kNtErrorInvalidFieldInParameterList 328
#define kNtErrorOperationInProgress 329
#define kNtErrorBadDevicePath 330
#define kNtErrorTooManyDescriptors 331 /* ENFILE */
#define kNtErrorScrubDataDisabled 332
#define kNtErrorNotRedundantStorage 333
#define kNtErrorResidentFileNotSupported 334
#define kNtErrorCompressedFileNotSupported 335
#define kNtErrorDirectoryNotSupported 336 /* EISDIR */
#define kNtErrorNotReadFromCopy 337
#define kNtErrorFtWriteFailure 338
#define kNtErrorFtDiScanRequired 339
#define kNtErrorInvalidKernelInfoVersion 340
#define kNtErrorInvalidPepInfoVersion 341
#define kNtErrorObjectNotExternallyBacked 342
#define kNtErrorExternalBackingProviderUnknown 343
#define kNtErrorCompressionNotBeneficial 344
#define kNtErrorStorageTopologyIdMismatch 345
#define kNtErrorBlockedByParentalControls 346
#define kNtErrorBlockTooManyReferences 347
#define kNtErrorMarkedToDisallowWrites 348
#define kNtErrorEnclaveFailure 349
#define kNtErrorFailNoactionReboot 350
#define kNtErrorFailShutdown 351
#define kNtErrorFailRestart 352
#define kNtErrorMaxSessionsReached 353
#define kNtErrorNetworkAccessDeniedEdp 354
#define kNtErrorDeviceHintNameBufferTooSmall 355
#define kNtErrorEdpPolicyDeniesOperation 356
#define kNtErrorEdpDplPolicyCantBeSatisfied 357
#define kNtErrorCloudFileSyncRootMetadataCorrupt 358
#define kNtErrorDeviceInMaintenance 359
#define kNtErrorNotSupportedOnDax 360
#define kNtErrorDaxMappingExists 361
#define kNtErrorCloudFileProviderNotRunning 362
#define kNtErrorCloudFileMetadataCorrupt 363
#define kNtErrorCloudFileMetadataTooLarge 364
#define kNtErrorCloudFilePropertyBlobTooLarge 365
#define kNtErrorCloudFilePropertyBlobChecksumMismatch 366
#define kNtErrorChildProcessBlocked 367
#define kNtErrorStorageLostDataPersistence 368
#define kNtErrorFileSystemVirtualizationUnavailable 369
#define kNtErrorFileSystemVirtualizationMetadataCorrupt 370
#define kNtErrorFileSystemVirtualizationBusy 371
#define kNtErrorFileSystemVirtualizationProviderUnknown 372
#define kNtErrorGdiHandleLeak 373
#define kNtErrorCloudFileTooManyPropertyBlobs 374
#define kNtErrorCloudFilePropertyVersionNotSupported 375
#define kNtErrorNotACloudFile 376
#define kNtErrorCloudFileNotInSync 377
#define kNtErrorCloudFileAlreadyConnected 378
#define kNtErrorCloudFileNotSupported 379
#define kNtErrorCloudFileInvalidRequest 380
#define kNtErrorCloudFileReadOnlyVolume 381
#define kNtErrorCloudFileConnectedProviderOnly 382
#define kNtErrorCloudFileValidationFailed 383
#define kNtErrorSmb1NotAvailable 384
#define kNtErrorFileSystemVirtualizationInvalidOperation 385
#define kNtErrorCloudFileAuthenticationFailed 386
#define kNtErrorCloudFileInsufficientResources 387
#define kNtErrorCloudFileNetworkUnavailable 388
#define kNtErrorCloudFileUnsuccessful 389
#define kNtErrorCloudFileNotUnderSyncRoot 390
#define kNtErrorCloudFileInUse 391
#define kNtErrorCloudFilePinned 392
#define kNtErrorCloudFileRequestAborted 393
#define kNtErrorCloudFilePropertyCorrupt 394
#define kNtErrorCloudFileAccessDenied 395
#define kNtErrorCloudFileIncompatibleHardlinks 396
#define kNtErrorCloudFilePropertyLockConflict 397
#define kNtErrorCloudFileRequestCanceled 398
#define kNtErrorExternalSyskeyNotSupported 399
#define kNtErrorThreadModeAlreadyBackground 400
#define kNtErrorThreadModeNotBackground 401
#define kNtErrorProcessModeAlreadyBackground 402
#define kNtErrorProcessModeNotBackground 403
#define kNtErrorCloudFileProviderTerminated 404
#define kNtErrorNotACloudSyncRoot 405
#define kNtErrorFileProtectedUnderDpl 406
#define kNtErrorVolumeNotClusterAligned 407
#define kNtErrorNoPhysicallyAlignedFreeSpaceFound 408
#define kNtErrorAppxFileNotEncrypted 409
#define kNtErrorRwrawEncryptedFileNotEncrypted 410
#define kNtErrorRwrawEncryptedInvalidEdatainfoFileoffset 411
#define kNtErrorRwrawEncryptedInvalidEdatainfoFilerange 412
#define kNtErrorRwrawEncryptedInvalidEdatainfoParameter 413
#define kNtErrorLinuxSubsystemNotPresent 414
#define kNtErrorCapauthzNotDevunlocked 450
#define kNtErrorCapauthzChangeType 451
#define kNtErrorCapauthzNotProvisioned 452
#define kNtErrorCapauthzNotAuthorized 453
#define kNtErrorCapauthzNoPolicy 454
#define kNtErrorCapauthzDbCorrupted 455
#define kNtErrorCapauthzSccdInvalidCatalog 456
#define kNtErrorCapauthzSccdNoAuthEntity 457
#define kNtErrorCapauthzSccdParseError 458
#define kNtErrorCapauthzSccdDevModeRequired 459
#define kNtErrorCapauthzSccdNoCapabilityMatch 460
#define kNtErrorPnpQueryRemoveDeviceTimeout 480
#define kNtErrorPnpQueryRemoveRelatedDeviceTimeout 481
#define kNtErrorPnpQueryRemoveUnrelatedDeviceTimeout 482
#define kNtErrorDeviceHardwareError 483
#define kNtErrorInvalidAddress 487 /* EFAULT */
#define kNtErrorVrfCfgEnabled 1183
#define kNtErrorPartitionTerminating 1184
#define kNtErrorUserProfileLoad 500
#define kNtErrorArithmeticOverflow 534
#define kNtErrorPipeConnected 535
#define kNtErrorPipeListening 536
#define kNtErrorVerifierStop 537
#define kNtErrorAbiosError 538
#define kNtErrorWx86Warning 539
#define kNtErrorWx86Error 540
#define kNtErrorTimerNotCanceled 541
#define kNtErrorUnwind 542
#define kNtErrorBadStack 543
#define kNtErrorInvalidUnwindTarget 544
#define kNtErrorInvalidPortAttributes 545
#define kNtErrorPortMessageTooLong 546
#define kNtErrorInvalidQuotaLower 547
#define kNtErrorDeviceAlreadyAttached 548
#define kNtErrorInstructionMisalignment 549
#define kNtErrorProfilingNotStarted 550
#define kNtErrorProfilingNotStopped 551
#define kNtErrorCouldNotInterpret 552
#define kNtErrorProfilingAtLimit 553
#define kNtErrorCantWait 554
#define kNtErrorCantTerminateSelf 555
#define kNtErrorUnexpectedMmCreateErr 556
#define kNtErrorUnexpectedMmMapError 557
#define kNtErrorUnexpectedMmExtendErr 558
#define kNtErrorBadFunctionTable 559
#define kNtErrorNoGuidTranslation 560
#define kNtErrorInvalidLdtSize 561
#define kNtErrorInvalidLdtOffset 563
#define kNtErrorInvalidLdtDescriptor 564
#define kNtErrorTooManyThreads 565
#define kNtErrorThreadNotInProcess 566 /* ESRCH */
#define kNtErrorPagefileQuotaExceeded 567
#define kNtErrorLogonServerConflict 568
#define kNtErrorSynchronizationRequired 569
#define kNtErrorNetOpenFailed 570
#define kNtErrorIoPrivilegeFailed 571
#define kNtErrorControlCExit 572
#define kNtErrorMissingSystemfile 573
#define kNtErrorUnhandledException 574
#define kNtErrorAppInitFailure 575
#define kNtErrorPagefileCreateFailed 576
#define kNtErrorInvalidImageHash 577
#define kNtErrorNoPagefile 578
#define kNtErrorIllegalFloatContext 579
#define kNtErrorNoEventPair 580
#define kNtErrorDomainCtrlrConfigError 581
#define kNtErrorIllegalCharacter 582
#define kNtErrorUndefinedCharacter 583
#define kNtErrorFloppyVolume 584
#define kNtErrorBiosFailedToConnectInterrupt 585
#define kNtErrorBackupController 586
#define kNtErrorMutantLimitExceeded 587
#define kNtErrorFsDriverRequired 588
#define kNtErrorCannotLoadRegistryFile 589
#define kNtErrorDebugAttachFailed 590
#define kNtErrorSystemProcessTerminated 591
#define kNtErrorDataNotAccepted 592
#define kNtErrorVdmHardError 593
#define kNtErrorDriverCancelTimeout 594
#define kNtErrorReplyMessageMismatch 595
#define kNtErrorLostWritebehindData 596
#define kNtErrorClientServerParametersInvalid 597
#define kNtErrorNotTinyStream 598
#define kNtErrorStackOverflowRead 599
#define kNtErrorConvertToLarge 600
#define kNtErrorFoundOutOfScope 601
#define kNtErrorAllocateBucket 602
#define kNtErrorMarshallOverflow 603
#define kNtErrorInvalidVariant 604
#define kNtErrorBadCompressionBuffer 605
#define kNtErrorAuditFailed 606
#define kNtErrorTimerResolutionNotSet 607
#define kNtErrorInsufficientLogonInfo 608
#define kNtErrorBadDllEntrypoint 609
#define kNtErrorBadServiceEntrypoint 610
#define kNtErrorIpAddressConflict1 611
#define kNtErrorIpAddressConflict2 612
#define kNtErrorRegistryQuotaLimit 613
#define kNtErrorNoCallbackActive 614
#define kNtErrorPwdTooShort 615
#define kNtErrorPwdTooRecent 616
#define kNtErrorPwdHistoryConflict 617
#define kNtErrorUnsupportedCompression 618
#define kNtErrorInvalidHwProfile 619
#define kNtErrorInvalidPlugplayDevicePath 620
#define kNtErrorQuotaListInconsistent 621
#define kNtErrorEvaluationExpiration 622
#define kNtErrorIllegalDllRelocation 623
#define kNtErrorDllInitFailedLogoff 624
#define kNtErrorValidateContinue 625
#define kNtErrorNoMoreMatches 626
#define kNtErrorRangeListConflict 627
#define kNtErrorServerSidMismatch 628
#define kNtErrorCantEnableDenyOnly 629
#define kNtErrorFloatMultipleFaults 630
#define kNtErrorFloatMultipleTraps 631
#define kNtErrorNointerface 632
#define kNtErrorDriverFailedSleep 633
#define kNtErrorCorruptSystemFile 634
#define kNtErrorCommitmentMinimum 635
#define kNtErrorPnpRestartEnumeration 636
#define kNtErrorSystemImageBadSignature 637
#define kNtErrorPnpRebootRequired 638
#define kNtErrorInsufficientPower 639
#define kNtErrorMultipleFaultViolation 640
#define kNtErrorSystemShutdown 641
#define kNtErrorPortNotSet 642
#define kNtErrorDsVersionCheckFailure 643
#define kNtErrorRangeNotFound 644
#define kNtErrorNotSafeModeDriver 646
#define kNtErrorFailedDriverEntry 647
#define kNtErrorDeviceEnumerationError 648
#define kNtErrorMountPointNotResolved 649
#define kNtErrorInvalidDeviceObjectParameter 650
#define kNtErrorMcaOccured 651
#define kNtErrorDriverDatabaseError 652
#define kNtErrorSystemHiveTooLarge 653
#define kNtErrorDriverFailedPriorUnload 654
#define kNtErrorVolsnapPrepareHibernate 655
#define kNtErrorHibernationFailure 656
#define kNtErrorPwdTooLong 657
#define kNtErrorFileSystemLimitation 665
#define kNtErrorAssertionFailure 668
#define kNtErrorAcpiError 669
#define kNtErrorWowAssertion 670
#define kNtErrorPnpBadMpsTable 671
#define kNtErrorPnpTranslationFailed 672
#define kNtErrorPnpIrqTranslationFailed 673
#define kNtErrorPnpInvalidId 674
#define kNtErrorWakeSystemDebugger 675
#define kNtErrorHandlesClosed 676
#define kNtErrorExtraneousInformation 677
#define kNtErrorRxactCommitNecessary 678
#define kNtErrorMediaCheck 679
#define kNtErrorGuidSubstitutionMade 680
#define kNtErrorStoppedOnSymlink 681
#define kNtErrorLongjump 682
#define kNtErrorPlugplayQueryVetoed 683
#define kNtErrorUnwindConsolidate 684
#define kNtErrorRegistryHiveRecovered 685
#define kNtErrorDllMightBeInsecure 686
#define kNtErrorDllMightBeIncompatible 687
#define kNtErrorDbgExceptionNotHandled 688
#define kNtErrorDbgReplyLater 689
#define kNtErrorDbgUnableToProvideHandle 690
#define kNtErrorDbgTerminateThread 691
#define kNtErrorDbgTerminateProcess 692
#define kNtErrorDbgControlC 693
#define kNtErrorDbgPrintexceptionC 694
#define kNtErrorDbgRipexception 695
#define kNtErrorDbgControlBreak 696
#define kNtErrorDbgCommandException 697
#define kNtErrorObjectNameExists 698
#define kNtErrorThreadWasSuspended 699
#define kNtErrorImageNotAtBase 700
#define kNtErrorRxactStateCreated 701
#define kNtErrorSegmentNotification 702
#define kNtErrorBadCurrentDirectory 703
#define kNtErrorFtReadRecoveryFromBackup 704
#define kNtErrorFtWriteRecovery 705
#define kNtErrorImageMachineTypeMismatch 706
#define kNtErrorReceivePartial 707
#define kNtErrorReceiveExpedited 708
#define kNtErrorReceivePartialExpedited 709
#define kNtErrorEventDone 710
#define kNtErrorEventPending 711
#define kNtErrorCheckingFileSystem 712
#define kNtErrorFatalAppExit 713
#define kNtErrorPredefinedHandle 714
#define kNtErrorWasUnlocked 715
#define kNtErrorServiceNotification 716
#define kNtErrorWasLocked 717
#define kNtErrorLogHardError 718
#define kNtErrorAlreadyWin32 719
#define kNtErrorImageMachineTypeMismatchExe 720
#define kNtErrorNoYieldPerformed 721
#define kNtErrorTimerResumeIgnored 722
#define kNtErrorArbitrationUnhandled 723
#define kNtErrorCardbusNotSupported 724
#define kNtErrorMpProcessorMismatch 725
#define kNtErrorHibernated 726
#define kNtErrorResumeHibernation 727
#define kNtErrorFirmwareUpdated 728
#define kNtErrorDriversLeakingLockedPages 729
#define kNtErrorWakeSystem 730
#define kNtErrorWait_1 731
#define kNtErrorWait_2 732
#define kNtErrorWait_3 733
#define kNtErrorWait_63 734
#define kNtErrorAbandonedWait_0 735
#define kNtErrorAbandonedWait_63 736
#define kNtErrorUserApc 737
#define kNtErrorKernelApc 738
#define kNtErrorAlerted 739
#define kNtErrorElevationRequired 740
#define kNtErrorReparse 741
#define kNtErrorOplockBreakInProgress 742
#define kNtErrorVolumeMounted 743
#define kNtErrorRxactCommitted 744
#define kNtErrorNotifyCleanup 745
#define kNtErrorPrimaryTransportConnectFailed 746
#define kNtErrorPageFaultTransition 747
#define kNtErrorPageFaultDemandZero 748
#define kNtErrorPageFaultCopyOnWrite 749
#define kNtErrorPageFaultGuardPage 750
#define kNtErrorPageFaultPagingFile 751
#define kNtErrorCachePageLocked 752
#define kNtErrorCrashDump 753
#define kNtErrorBufferAllZeros 754
#define kNtErrorReparseObject 755
#define kNtErrorResourceRequirementsChanged 756
#define kNtErrorTranslationComplete 757
#define kNtErrorNothingToTerminate 758
#define kNtErrorProcessNotInJob 759
#define kNtErrorProcessInJob 760
#define kNtErrorVolsnapHibernateReady 761
#define kNtErrorFsfilterOpCompletedSuccessfully 762
#define kNtErrorInterruptVectorAlreadyConnected 763
#define kNtErrorInterruptStillConnected 764
#define kNtErrorWaitForOplock 765
#define kNtErrorDbgExceptionHandled 766
#define kNtErrorDbgContinue 767
#define kNtErrorCallbackPopStack 768
#define kNtErrorCompressionDisabled 769
#define kNtErrorCantfetchbackwards 770
#define kNtErrorCantscrollbackwards 771
#define kNtErrorRowsnotreleased 772
#define kNtErrorBadAccessorFlags 773
#define kNtErrorErrorsEncountered 774
#define kNtErrorNotCapable 775
#define kNtErrorRequestOutOfSequence 776
#define kNtErrorVersionParseError 777
#define kNtErrorBadstartposition 778
#define kNtErrorMemoryHardware 779
#define kNtErrorDiskRepairDisabled 780
#define kNtErrorInsufficientResourceForSpecifiedSharedSectionSize 781
#define kNtErrorSystemPowerstateTransition 782
#define kNtErrorSystemPowerstateComplexTransition 783
#define kNtErrorMcaException 784
#define kNtErrorAccessAuditByPolicy 785
#define kNtErrorAccessDisabledNoSaferUiByPolicy 786
#define kNtErrorAbandonHiberfile 787
#define kNtErrorLostWritebehindDataNetworkDisconnected 788
#define kNtErrorLostWritebehindDataNetworkServerError 789
#define kNtErrorLostWritebehindDataLocalDiskError 790
#define kNtErrorBadMcfgTable 791
#define kNtErrorDiskRepairRedirected 792
#define kNtErrorDiskRepairUnsuccessful 793
#define kNtErrorCorruptLogOverfull 794
#define kNtErrorCorruptLogCorrupted 795
#define kNtErrorCorruptLogUnavailable 796
#define kNtErrorCorruptLogDeletedFull 797
#define kNtErrorCorruptLogCleared 798
#define kNtErrorOrphanNameExhausted 799
#define kNtErrorOplockSwitchedToNewHandle 800
#define kNtErrorCannotGrantRequestedOplock 801
#define kNtErrorCannotBreakOplock 802
#define kNtErrorOplockHandleClosed 803
#define kNtErrorNoAceCondition 804
#define kNtErrorInvalidAceCondition 805
#define kNtErrorFileHandleRevoked 806
#define kNtErrorImageAtDifferentBase 807
#define kNtErrorEncryptedIoNotPossible 808
#define kNtErrorFileMetadataOptimizationInProgress 809
#define kNtErrorQuotaActivity 810
#define kNtErrorHandleRevoked 811
#define kNtErrorCallbackInvokeInline 812
#define kNtErrorCpuSetInvalid 813
#define kNtErrorEnclaveNotTerminated 814
#define kNtErrorEnclaveViolation 815
#define kNtErrorEaAccessDenied 994
#define kNtErrorOperationAborted 995
#define kNtErrorIoIncomplete 996
#define kNtErrorIoPending 997
#define kNtErrorNoaccess 998
#define kNtErrorSwaperror 999
#define kNtErrorStackOverflow 1001
#define kNtErrorInvalidMessage 1002
#define kNtErrorCanNotComplete 1003
#define kNtErrorInvalidFlags 1004
#define kNtErrorUnrecognizedVolume 1005
#define kNtErrorFileInvalid 1006
#define kNtErrorFullscreenMode 1007
#define kNtErrorNoToken 1008
#define kNtErrorBaddb 1009
#define kNtErrorBadkey 1010
#define kNtErrorCantopen 1011
#define kNtErrorCantread 1012
#define kNtErrorCantwrite 1013
#define kNtErrorRegistryRecovered 1014
#define kNtErrorRegistryCorrupt 1015
#define kNtErrorRegistryIoFailed 1016
#define kNtErrorNotRegistryFile 1017
#define kNtErrorKeyDeleted 1018
#define kNtErrorNoLogSpace 1019
#define kNtErrorKeyHasChildren 1020
#define kNtErrorChildMustBeVolatile 1021
#define kNtErrorNotifyEnumDir 1022
#define kNtErrorDependentServicesRunning 1051
#define kNtErrorInvalidServiceControl 1052
#define kNtErrorServiceRequestTimeout 1053
#define kNtErrorServiceNoThread 1054
#define kNtErrorServiceDatabaseLocked 1055
#define kNtErrorServiceAlreadyRunning 1056
#define kNtErrorInvalidServiceAccount 1057
#define kNtErrorServiceDisabled 1058
#define kNtErrorCircularDependency 1059
#define kNtErrorServiceDoesNotExist 1060
#define kNtErrorServiceCannotAcceptCtrl 1061
#define kNtErrorServiceNotActive 1062
#define kNtErrorFailedServiceControllerConnect 1063
#define kNtErrorExceptionInService 1064
#define kNtErrorDatabaseDoesNotExist 1065
#define kNtErrorServiceSpecificError 1066
#define kNtErrorProcessAborted 1067
#define kNtErrorServiceDependencyFail 1068
#define kNtErrorServiceLogonFailed 1069
#define kNtErrorServiceStartHang 1070
#define kNtErrorInvalidServiceLock 1071
#define kNtErrorServiceMarkedForDelete 1072
#define kNtErrorServiceExists 1073
#define kNtErrorAlreadyRunningLkg 1074
#define kNtErrorServiceDependencyDeleted 1075
#define kNtErrorBootAlreadyAccepted 1076
#define kNtErrorServiceNeverStarted 1077
#define kNtErrorDuplicateServiceName 1078
#define kNtErrorDifferentServiceAccount 1079
#define kNtErrorCannotDetectDriverFailure 1080
#define kNtErrorCannotDetectProcessAbort 1081
#define kNtErrorNoRecoveryProgram 1082
#define kNtErrorServiceNotInExe 1083
#define kNtErrorNotSafebootService 1084
#define kNtErrorEndOfMedia 1100
#define kNtErrorFilemarkDetected 1101
#define kNtErrorBeginningOfMedia 1102
#define kNtErrorSetmarkDetected 1103
#define kNtErrorNoDataDetected 1104
#define kNtErrorPartitionFailure 1105
#define kNtErrorInvalidBlockLength 1106
#define kNtErrorDeviceNotPartitioned 1107
#define kNtErrorUnableToLockMedia 1108
#define kNtErrorUnableToUnloadMedia 1109
#define kNtErrorMediaChanged 1110
#define kNtErrorBusReset 1111
#define kNtErrorNoMediaInDrive 1112 /* ENXIO */
#define kNtErrorNoUnicodeTranslation 1113
#define kNtErrorDllInitFailed 1114
#define kNtErrorShutdownInProgress 1115
#define kNtErrorNoShutdownInProgress 1116
#define kNtErrorIoDevice 1117       /* EIO */
#define kNtErrorSerialNoDevice 1118 /* ENOTTY */
#define kNtErrorIrqBusy 1119
#define kNtErrorMoreWrites 1120
#define kNtErrorCounterTimeout 1121
#define kNtErrorFloppyIdMarkNotFound 1122
#define kNtErrorFloppyWrongCylinder 1123
#define kNtErrorFloppyUnknownError 1124
#define kNtErrorFloppyBadRegisters 1125
#define kNtErrorDiskRecalibrateFailed 1126
#define kNtErrorDiskOperationFailed 1127
#define kNtErrorDiskResetFailed 1128
#define kNtErrorEomOverflow 1129
#define kNtErrorNotEnoughServerMemory 1130
#define kNtErrorPossibleDeadlock 1131 /* EDEADLK */
#define kNtErrorMappedAlignment 1132
#define kNtErrorSetPowerStateVetoed 1140
#define kNtErrorSetPowerStateFailed 1141
#define kNtErrorTooManyLinks 1142
#define kNtErrorOldWinVersion 1150
#define kNtErrorAppWrongOs 1151
#define kNtErrorSingleInstanceApp 1152
#define kNtErrorRmodeApp 1153
#define kNtErrorInvalidDll 1154
#define kNtErrorNoAssociation 1155
#define kNtErrorDdeFail 1156
#define kNtErrorDllNotFound 1157
#define kNtErrorNoMoreUserHandles 1158
#define kNtErrorMessageSyncOnly 1159
#define kNtErrorSourceElementEmpty 1160
#define kNtErrorDestinationElementFull 1161
#define kNtErrorIllegalElementAddress 1162
#define kNtErrorMagazineNotPresent 1163
#define kNtErrorDeviceReinitializationNeeded 1164
#define kNtErrorDeviceRequiresCleaning 1165
#define kNtErrorDeviceDoorOpen 1166
#define kNtErrorDeviceNotConnected 1167
#define kNtErrorNotFound 1168
#define kNtErrorNoMatch 1169
#define kNtErrorSetNotFound 1170
#define kNtErrorPointNotFound 1171
#define kNtErrorNoTrackingService 1172
#define kNtErrorNoVolumeId 1173
#define kNtErrorUnableToRemoveReplaced 1175
#define kNtErrorUnableToMoveReplacement 1176
#define kNtErrorUnableToMoveReplacement_2 1177
#define kNtErrorJournalDeleteInProgress 1178
#define kNtErrorJournalNotActive 1179
#define kNtErrorPotentialFileFound 1180
#define kNtErrorJournalEntryDeleted 1181
#define kNtErrorShutdownIsScheduled 1190
#define kNtErrorShutdownUsersLoggedOn 1191
#define kNtErrorBadDevice 1200 /* ENODEV */
#define kNtErrorConnectionUnavail 1201
#define kNtErrorDeviceAlreadyRemembered 1202
#define kNtErrorNoNetOrBadPath 1203
#define kNtErrorBadProvider 1204
#define kNtErrorCannotOpenProfile 1205
#define kNtErrorBadProfile 1206
#define kNtErrorNotContainer 1207
#define kNtErrorExtendedError 1208
#define kNtErrorInvalidGroupname 1209
#define kNtErrorInvalidComputername 1210
#define kNtErrorInvalidEventname 1211
#define kNtErrorInvalidDomainname 1212
#define kNtErrorInvalidServicename 1213
#define kNtErrorInvalidNetname 1214
#define kNtErrorInvalidSharename 1215
#define kNtErrorInvalidPasswordname 1216
#define kNtErrorInvalidMessagename 1217
#define kNtErrorInvalidMessagedest 1218
#define kNtErrorSessionCredentialConflict 1219
#define kNtErrorRemoteSessionLimitExceeded 1220
#define kNtErrorDupDomainname 1221
#define kNtErrorNoNetwork 1222
#define kNtErrorCancelled 1223
#define kNtErrorUserMappedFile 1224
#define kNtErrorConnectionRefused 1225
#define kNtErrorGracefulDisconnect 1226
#define kNtErrorAddressAlreadyAssociated 1227
#define kNtErrorAddressNotAssociated 1228
#define kNtErrorConnectionInvalid 1229
#define kNtErrorConnectionActive 1230
#define kNtErrorNetworkUnreachable 1231
#define kNtErrorHostUnreachable 1232
#define kNtErrorProtocolUnreachable 1233
#define kNtErrorPortUnreachable 1234
#define kNtErrorRequestAborted 1235
#define kNtErrorConnectionAborted 1236
#define kNtErrorRetry 1237
#define kNtErrorConnectionCountLimit 1238
#define kNtErrorLoginTimeRestriction 1239
#define kNtErrorLoginWkstaRestriction 1240
#define kNtErrorIncorrectAddress 1241
#define kNtErrorAlreadyRegistered 1242
#define kNtErrorServiceNotFound 1243
#define kNtErrorNotAuthenticated 1244
#define kNtErrorNotLoggedOn 1245
#define kNtErrorContinue 1246
#define kNtErrorAlreadyInitialized 1247
#define kNtErrorNoMoreDevices 1248
#define kNtErrorNoSuchSite 1249
#define kNtErrorDomainControllerExists 1250
#define kNtErrorOnlyIfConnected 1251
#define kNtErrorOverrideNochanges 1252
#define kNtErrorBadUserProfile 1253
#define kNtErrorNotSupportedOnSbs 1254
#define kNtErrorServerShutdownInProgress 1255
#define kNtErrorHostDown 1256
#define kNtErrorNonAccountSid 1257
#define kNtErrorNonDomainSid 1258
#define kNtErrorApphelpBlock 1259
#define kNtErrorAccessDisabledByPolicy 1260
#define kNtErrorRegNatConsumption 1261
#define kNtErrorCscshareOffline 1262
#define kNtErrorPkinitFailure 1263
#define kNtErrorSmartcardSubsystemFailure 1264
#define kNtErrorDowngradeDetected 1265
#define kNtErrorMachineLocked 1271
#define kNtErrorSmbGuestLogonBlocked 1272
#define kNtErrorCallbackSuppliedInvalidData 1273
#define kNtErrorSyncForegroundRefreshRequired 1274
#define kNtErrorDriverBlocked 1275
#define kNtErrorInvalidImportOfNonDll 1276
#define kNtErrorAccessDisabledWebblade 1277
#define kNtErrorAccessDisabledWebbladeTamper 1278
#define kNtErrorRecoveryFailure 1279
#define kNtErrorAlreadyFiber 1280
#define kNtErrorAlreadyThread 1281
#define kNtErrorStackBufferOverrun 1282
#define kNtErrorParameterQuotaExceeded 1283
#define kNtErrorDebuggerInactive 1284
#define kNtErrorDelayLoadFailed 1285
#define kNtErrorVdmDisallowed 1286
#define kNtErrorUnidentifiedError 1287
#define kNtErrorInvalidCruntimeParameter 1288
#define kNtErrorBeyondVdl 1289
#define kNtErrorIncompatibleServiceSidType 1290
#define kNtErrorDriverProcessTerminated 1291
#define kNtErrorImplementationLimit 1292
#define kNtErrorProcessIsProtected 1293
#define kNtErrorServiceNotifyClientLagging 1294
#define kNtErrorDiskQuotaExceeded 1295
#define kNtErrorContentBlocked 1296
#define kNtErrorIncompatibleServicePrivilege 1297
#define kNtErrorAppHang 1298
#define kNtErrorInvalidLabel 1299
#define kNtErrorNotAllAssigned 1300
#define kNtErrorSomeNotMapped 1301
#define kNtErrorNoQuotasForAccount 1302
#define kNtErrorLocalUserSessionKey 1303
#define kNtErrorNullLmPassword 1304
#define kNtErrorUnknownRevision 1305
#define kNtErrorRevisionMismatch 1306
#define kNtErrorInvalidOwner 1307
#define kNtErrorInvalidPrimaryGroup 1308
#define kNtErrorNoImpersonationToken 1309
#define kNtErrorCantDisableMandatory 1310
#define kNtErrorNoLogonServers 1311
#define kNtErrorNoSuchLogonSession 1312
#define kNtErrorNoSuchPrivilege 1313
#define kNtErrorPrivilegeNotHeld 1314
#define kNtErrorInvalidAccountName 1315
#define kNtErrorUserExists 1316
#define kNtErrorNoSuchUser 1317
#define kNtErrorGroupExists 1318
#define kNtErrorNoSuchGroup 1319
#define kNtErrorMemberInGroup 1320
#define kNtErrorMemberNotInGroup 1321
#define kNtErrorLastAdmin 1322
#define kNtErrorWrongPassword 1323
#define kNtErrorIllFormedPassword 1324
#define kNtErrorPasswordRestriction 1325
#define kNtErrorLogonFailure 1326
#define kNtErrorAccountRestriction 1327
#define kNtErrorInvalidLogonHours 1328
#define kNtErrorInvalidWorkstation 1329
#define kNtErrorPasswordExpired 1330
#define kNtErrorAccountDisabled 1331
#define kNtErrorNoneMapped 1332
#define kNtErrorTooManyLuidsRequested 1333
#define kNtErrorLuidsExhausted 1334
#define kNtErrorInvalidSubAuthority 1335
#define kNtErrorInvalidAcl 1336
#define kNtErrorInvalidSid 1337
#define kNtErrorInvalidSecurityDescr 1338
#define kNtErrorBadInheritanceAcl 1340
#define kNtErrorServerDisabled 1341
#define kNtErrorServerNotDisabled 1342
#define kNtErrorInvalidIdAuthority 1343
#define kNtErrorAllottedSpaceExceeded 1344
#define kNtErrorInvalidGroupAttributes 1345
#define kNtErrorBadImpersonationLevel 1346
#define kNtErrorCantOpenAnonymous 1347
#define kNtErrorBadValidationClass 1348
#define kNtErrorBadTokenType 1349
#define kNtErrorNoSecurityOnObject 1350
#define kNtErrorCantAccessDomainInfo 1351
#define kNtErrorInvalidServerState 1352
#define kNtErrorInvalidDomainState 1353
#define kNtErrorInvalidDomainRole 1354
#define kNtErrorNoSuchDomain 1355
#define kNtErrorDomainExists 1356
#define kNtErrorDomainLimitExceeded 1357
#define kNtErrorInternalDbCorruption 1358
#define kNtErrorInternalError 1359
#define kNtErrorGenericNotMapped 1360
#define kNtErrorBadDescriptorFormat 1361
#define kNtErrorNotLogonProcess 1362
#define kNtErrorLogonSessionExists 1363
#define kNtErrorNoSuchPackage 1364
#define kNtErrorBadLogonSessionState 1365
#define kNtErrorLogonSessionCollision 1366
#define kNtErrorInvalidLogonType 1367
#define kNtErrorCannotImpersonate 1368
#define kNtErrorRxactInvalidState 1369
#define kNtErrorRxactCommitFailure 1370
#define kNtErrorSpecialAccount 1371
#define kNtErrorSpecialGroup 1372
#define kNtErrorSpecialUser 1373
#define kNtErrorMembersPrimaryGroup 1374
#define kNtErrorTokenAlreadyInUse 1375
#define kNtErrorNoSuchAlias 1376
#define kNtErrorMemberNotInAlias 1377
#define kNtErrorMemberInAlias 1378
#define kNtErrorAliasExists 1379
#define kNtErrorLogonNotGranted 1380
#define kNtErrorTooManySecrets 1381
#define kNtErrorSecretTooLong 1382
#define kNtErrorInternalDbError 1383
#define kNtErrorTooManyContextIds 1384
#define kNtErrorLogonTypeNotGranted 1385
#define kNtErrorNtCrossEncryptionRequired 1386
#define kNtErrorNoSuchMember 1387
#define kNtErrorInvalidMember 1388
#define kNtErrorTooManySids 1389
#define kNtErrorLmCrossEncryptionRequired 1390
#define kNtErrorNoInheritance 1391
#define kNtErrorFileCorrupt 1392
#define kNtErrorDiskCorrupt 1393
#define kNtErrorNoUserSessionKey 1394
#define kNtErrorLicenseQuotaExceeded 1395
#define kNtErrorWrongTargetName 1396
#define kNtErrorMutualAuthFailed 1397
#define kNtErrorTimeSkew 1398
#define kNtErrorCurrentDomainNotAllowed 1399
#define kNtErrorInvalidWindowHandle 1400
#define kNtErrorInvalidMenuHandle 1401
#define kNtErrorInvalidCursorHandle 1402
#define kNtErrorInvalidAccelHandle 1403
#define kNtErrorInvalidHookHandle 1404
#define kNtErrorInvalidDwpHandle 1405
#define kNtErrorTlwWithWschild 1406
#define kNtErrorCannotFindWndClass 1407
#define kNtErrorWindowOfOtherThread 1408
#define kNtErrorHotkeyAlreadyRegistered 1409
#define kNtErrorClassAlreadyExists 1410
#define kNtErrorClassDoesNotExist 1411
#define kNtErrorClassHasWindows 1412
#define kNtErrorInvalidIndex 1413
#define kNtErrorInvalidIconHandle 1414
#define kNtErrorPrivateDialogIndex 1415
#define kNtErrorListboxIdNotFound 1416
#define kNtErrorNoWildcardCharacters 1417
#define kNtErrorClipboardNotOpen 1418
#define kNtErrorHotkeyNotRegistered 1419
#define kNtErrorWindowNotDialog 1420
#define kNtErrorControlIdNotFound 1421
#define kNtErrorInvalidComboboxMessage 1422
#define kNtErrorWindowNotCombobox 1423
#define kNtErrorInvalidEditHeight 1424
#define kNtErrorDcNotFound 1425
#define kNtErrorInvalidHookFilter 1426
#define kNtErrorInvalidFilterProc 1427
#define kNtErrorHookNeedsHmod 1428
#define kNtErrorGlobalOnlyHook 1429
#define kNtErrorJournalHookSet 1430
#define kNtErrorHookNotInstalled 1431
#define kNtErrorInvalidLbMessage 1432
#define kNtErrorSetcountOnBadLb 1433
#define kNtErrorLbWithoutTabstops 1434
#define kNtErrorDestroyObjectOfOtherThread 1435
#define kNtErrorChildWindowMenu 1436
#define kNtErrorNoSystemMenu 1437
#define kNtErrorInvalidMsgboxStyle 1438
#define kNtErrorInvalidSpiValue 1439
#define kNtErrorScreenAlreadyLocked 1440
#define kNtErrorHwndsHaveDiffParent 1441
#define kNtErrorNotChildWindow 1442
#define kNtErrorInvalidGwCommand 1443
#define kNtErrorInvalidThreadId 1444
#define kNtErrorNonMdichildWindow 1445
#define kNtErrorPopupAlreadyActive 1446
#define kNtErrorNoScrollbars 1447
#define kNtErrorInvalidScrollbarRange 1448
#define kNtErrorInvalidShowwinCommand 1449
#define kNtErrorNoSystemResources 1450
#define kNtErrorNonpagedSystemResources 1451
#define kNtErrorPagedSystemResources 1452
#define kNtErrorWorkingSetQuota 1453
#define kNtErrorPagefileQuota 1454
#define kNtErrorCommitmentLimit 1455
#define kNtErrorMenuItemNotFound 1456
#define kNtErrorInvalidKeyboardHandle 1457
#define kNtErrorHookTypeNotAllowed 1458
#define kNtErrorRequiresInteractiveWindowstation 1459
#define kNtErrorTimeout 1460
#define kNtErrorInvalidMonitorHandle 1461
#define kNtErrorIncorrectSize 1462
#define kNtErrorSymlinkClassDisabled 1463
#define kNtErrorSymlinkNotSupported 1464
#define kNtErrorXmlParseError 1465
#define kNtErrorXmldsigError 1466
#define kNtErrorRestartApplication 1467
#define kNtErrorWrongCompartment 1468
#define kNtErrorAuthipFailure 1469
#define kNtErrorNoNvramResources 1470
#define kNtErrorNotGuiProcess 1471
#define kNtErrorEventlogFileCorrupt 1500
#define kNtErrorEventlogCantStart 1501
#define kNtErrorLogFileFull 1502
#define kNtErrorEventlogFileChanged 1503
#define kNtErrorContainerAssigned 1504
#define kNtErrorJobNoContainer 1505
#define kNtErrorInvalidTaskName 1550
#define kNtErrorInvalidTaskIndex 1551
#define kNtErrorThreadAlreadyInTask 1552
#define kNtErrorInstallServiceFailure 1601
#define kNtErrorInstallUserexit 1602
#define kNtErrorInstallFailure 1603
#define kNtErrorInstallSuspend 1604
#define kNtErrorUnknownProduct 1605
#define kNtErrorUnknownFeature 1606
#define kNtErrorUnknownComponent 1607
#define kNtErrorUnknownProperty 1608
#define kNtErrorInvalidHandleState 1609
#define kNtErrorBadConfiguration 1610
#define kNtErrorIndexAbsent 1611
#define kNtErrorInstallSourceAbsent 1612
#define kNtErrorInstallPackageVersion 1613
#define kNtErrorProductUninstalled 1614
#define kNtErrorBadQuerySyntax 1615
#define kNtErrorInvalidField 1616
#define kNtErrorDeviceRemoved 1617
#define kNtErrorInstallAlreadyRunning 1618
#define kNtErrorInstallPackageOpenFailed 1619
#define kNtErrorInstallPackageInvalid 1620
#define kNtErrorInstallUiFailure 1621
#define kNtErrorInstallLogFailure 1622
#define kNtErrorInstallLanguageUnsupported 1623
#define kNtErrorInstallTransformFailure 1624
#define kNtErrorInstallPackageRejected 1625
#define kNtErrorFunctionNotCalled 1626
#define kNtErrorFunctionFailed 1627
#define kNtErrorInvalidTable 1628
#define kNtErrorDatatypeMismatch 1629
#define kNtErrorUnsupportedType 1630
#define kNtErrorCreateFailed 1631
#define kNtErrorInstallTempUnwritable 1632
#define kNtErrorInstallPlatformUnsupported 1633
#define kNtErrorInstallNotused 1634
#define kNtErrorPatchPackageOpenFailed 1635
#define kNtErrorPatchPackageInvalid 1636
#define kNtErrorPatchPackageUnsupported 1637
#define kNtErrorProductVersion 1638
#define kNtErrorInvalidCommandLine 1639 /* E2BIG */
#define kNtErrorInstallRemoteDisallowed 1640
#define kNtErrorSuccessRebootInitiated 1641
#define kNtErrorPatchTargetNotFound 1642
#define kNtErrorPatchPackageRejected 1643
#define kNtErrorInstallTransformRejected 1644
#define kNtErrorInstallRemoteProhibited 1645
#define kNtErrorPatchRemovalUnsupported 1646
#define kNtErrorUnknownPatch 1647
#define kNtErrorPatchNoSequence 1648
#define kNtErrorPatchRemovalDisallowed 1649
#define kNtErrorInvalidPatchXml 1650
#define kNtErrorPatchManagedAdvertisedProduct 1651
#define kNtErrorInstallServiceSafeboot 1652
#define kNtErrorFailFastException 1653
#define kNtErrorInstallRejected 1654
#define kNtErrorDynamicCodeBlocked 1655
#define kNtErrorNotSameObject 1656
#define kNtErrorStrictCfgViolation 1657
#define kNtErrorSetContextDenied 1660
#define kNtErrorCrossPartitionViolation 1661
#define kNtErrorInvalidUserBuffer 1784
#define kNtErrorUnrecognizedMedia 1785
#define kNtErrorNoTrustLsaSecret 1786
#define kNtErrorNoTrustSamAccount 1787
#define kNtErrorTrustedDomainFailure 1788
#define kNtErrorTrustedRelationshipFailure 1789
#define kNtErrorTrustFailure 1790
#define kNtErrorNetlogonNotStarted 1792
#define kNtErrorAccountExpired 1793
#define kNtErrorRedirectorHasOpenHandles 1794
#define kNtErrorPrinterDriverAlreadyInstalled 1795
#define kNtErrorUnknownPort 1796
#define kNtErrorUnknownPrinterDriver 1797
#define kNtErrorUnknownPrintprocessor 1798
#define kNtErrorInvalidSeparatorFile 1799
#define kNtErrorInvalidPriority 1800
#define kNtErrorInvalidPrinterName 1801
#define kNtErrorPrinterAlreadyExists 1802
#define kNtErrorInvalidPrinterCommand 1803
#define kNtErrorInvalidDatatype 1804
#define kNtErrorInvalidEnvironment 1805
#define kNtErrorNologonInterdomainTrustAccount 1807
#define kNtErrorNologonWorkstationTrustAccount 1808
#define kNtErrorNologonServerTrustAccount 1809
#define kNtErrorDomainTrustInconsistent 1810
#define kNtErrorServerHasOpenHandles 1811
#define kNtErrorResourceDataNotFound 1812
#define kNtErrorResourceTypeNotFound 1813
#define kNtErrorResourceNameNotFound 1814
#define kNtErrorResourceLangNotFound 1815
#define kNtErrorNotEnoughQuota 1816
#define kNtErrorInvalidTime 1901
#define kNtErrorInvalidFormName 1902
#define kNtErrorInvalidFormSize 1903
#define kNtErrorAlreadyWaiting 1904
#define kNtErrorPrinterDeleted 1905
#define kNtErrorInvalidPrinterState 1906
#define kNtErrorPasswordMustChange 1907
#define kNtErrorDomainControllerNotFound 1908
#define kNtErrorAccountLockedOut 1909
#define kNtErrorNoSitename 1919
#define kNtErrorCantAccessFile 1920
#define kNtErrorCantResolveFilename 1921
#define kNtErrorKmDriverBlocked 1930
#define kNtErrorContextExpired 1931
#define kNtErrorPerUserTrustQuotaExceeded 1932
#define kNtErrorAllUserTrustQuotaExceeded 1933
#define kNtErrorUserDeleteTrustQuotaExceeded 1934
#define kNtErrorAuthenticationFirewallFailed 1935
#define kNtErrorRemotePrintConnectionsBlocked 1936
#define kNtErrorNtlmBlocked 1937
#define kNtErrorPasswordChangeRequired 1938
#define kNtErrorLostModeLogonRestriction 1939
#define kNtErrorInvalidPixelFormat 2000
#define kNtErrorBadDriver 2001
#define kNtErrorInvalidWindowStyle 2002
#define kNtErrorMetafileNotSupported 2003
#define kNtErrorTransformNotSupported 2004
#define kNtErrorClippingNotSupported 2005
#define kNtErrorInvalidCmm 2010
#define kNtErrorInvalidProfile 2011
#define kNtErrorTagNotFound 2012
#define kNtErrorTagNotPresent 2013
#define kNtErrorDuplicateTag 2014
#define kNtErrorProfileNotAssociatedWithDevice 2015
#define kNtErrorProfileNotFound 2016
#define kNtErrorInvalidColorspace 2017
#define kNtErrorIcmNotEnabled 2018
#define kNtErrorDeletingIcmXform 2019
#define kNtErrorInvalidTransform 2020
#define kNtErrorColorspaceMismatch 2021
#define kNtErrorInvalidColorindex 2022
#define kNtErrorProfileDoesNotMatchDevice 2023
#define kNtErrorConnectedOtherPassword 2108
#define kNtErrorConnectedOtherPasswordDefault 2109
#define kNtErrorBadUsername 2202
#define kNtErrorNotConnected 2250
#define kNtErrorOpenFiles 2401
#define kNtErrorActiveConnections 2402
#define kNtErrorDeviceInUse 2404
#define kNtErrorUnknownPrintMonitor 3000
#define kNtErrorPrinterDriverInUse 3001
#define kNtErrorSpoolFileNotFound 3002
#define kNtErrorSplNoStartdoc 3003
#define kNtErrorSplNoAddjob 3004
#define kNtErrorPrintProcessorAlreadyInstalled 3005
#define kNtErrorPrintMonitorAlreadyInstalled 3006
#define kNtErrorInvalidPrintMonitor 3007
#define kNtErrorPrintMonitorInUse 3008
#define kNtErrorPrinterHasJobsQueued 3009
#define kNtErrorSuccessRebootRequired 3010
#define kNtErrorSuccessRestartRequired 3011
#define kNtErrorPrinterNotFound 3012
#define kNtErrorPrinterDriverWarned 3013
#define kNtErrorPrinterDriverBlocked 3014
#define kNtErrorPrinterDriverPackageInUse 3015
#define kNtErrorCoreDriverPackageNotFound 3016
#define kNtErrorFailRebootRequired 3017
#define kNtErrorFailRebootInitiated 3018
#define kNtErrorPrinterDriverDownloadNeeded 3019
#define kNtErrorPrintJobRestartRequired 3020
#define kNtErrorInvalidPrinterDriverManifest 3021
#define kNtErrorPrinterNotShareable 3022
#define kNtErrorRequestPaused 3050
#define kNtErrorAppexecConditionNotSatisfied 3060
#define kNtErrorAppexecHandleInvalidated 3061
#define kNtErrorAppexecInvalidHostGeneration 3062
#define kNtErrorAppexecUnexpectedProcessRegistration 3063
#define kNtErrorAppexecInvalidHostState 3064
#define kNtErrorAppexecNoDonor 3065
#define kNtErrorAppexecHostIdMismatch 3066
#define kNtErrorIoReissueAsCached 3950
#define kNtErrorWinsInternal 4000
#define kNtErrorCanNotDelLocalWins 4001
#define kNtErrorStaticInit 4002
#define kNtErrorIncBackup 4003
#define kNtErrorFullBackup 4004
#define kNtErrorRecNonExistent 4005
#define kNtErrorRplNotAllowed 4006
#define kNtErrorDhcpAddressConflict 4100
#define kNtErrorWmiGuidNotFound 4200
#define kNtErrorWmiInstanceNotFound 4201
#define kNtErrorWmiItemidNotFound 4202
#define kNtErrorWmiTryAgain 4203
#define kNtErrorWmiDpNotFound 4204
#define kNtErrorWmiUnresolvedInstanceRef 4205
#define kNtErrorWmiAlreadyEnabled 4206
#define kNtErrorWmiGuidDisconnected 4207
#define kNtErrorWmiServerUnavailable 4208
#define kNtErrorWmiDpFailed 4209
#define kNtErrorWmiInvalidMof 4210
#define kNtErrorWmiInvalidReginfo 4211
#define kNtErrorWmiAlreadyDisabled 4212
#define kNtErrorWmiReadOnly 4213
#define kNtErrorWmiSetFailure 4214
#define kNtErrorNotAppcontainer 4250
#define kNtErrorAppcontainerRequired 4251
#define kNtErrorNotSupportedInAppcontainer 4252
#define kNtErrorInvalidPackageSidLength 4253
#define kNtErrorInvalidMedia 4300
#define kNtErrorInvalidLibrary 4301
#define kNtErrorInvalidMediaPool 4302
#define kNtErrorDriveMediaMismatch 4303
#define kNtErrorMediaOffline 4304
#define kNtErrorLibraryOffline 4305
#define kNtErrorEmpty 4306
#define kNtErrorNotEmpty 4307
#define kNtErrorMediaUnavailable 4308
#define kNtErrorResourceDisabled 4309
#define kNtErrorInvalidCleaner 4310
#define kNtErrorUnableToClean 4311
#define kNtErrorObjectNotFound 4312
#define kNtErrorDatabaseFailure 4313
#define kNtErrorDatabaseFull 4314
#define kNtErrorMediaIncompatible 4315
#define kNtErrorResourceNotPresent 4316
#define kNtErrorInvalidOperation 4317
#define kNtErrorMediaNotAvailable 4318
#define kNtErrorDeviceNotAvailable 4319
#define kNtErrorRequestRefused 4320
#define kNtErrorInvalidDriveObject 4321
#define kNtErrorLibraryFull 4322
#define kNtErrorMediumNotAccessible 4323
#define kNtErrorUnableToLoadMedium 4324
#define kNtErrorUnableToInventoryDrive 4325
#define kNtErrorUnableToInventorySlot 4326
#define kNtErrorUnableToInventoryTransport 4327
#define kNtErrorTransportFull 4328
#define kNtErrorControllingIeport 4329
#define kNtErrorUnableToEjectMountedMedia 4330
#define kNtErrorCleanerSlotSet 4331
#define kNtErrorCleanerSlotNotSet 4332
#define kNtErrorCleanerCartridgeSpent 4333
#define kNtErrorUnexpectedOmid 4334
#define kNtErrorCantDeleteLastItem 4335
#define kNtErrorMessageExceedsMaxSize 4336
#define kNtErrorVolumeContainsSysFiles 4337
#define kNtErrorIndigenousType 4338
#define kNtErrorNoSupportingDrives 4339
#define kNtErrorCleanerCartridgeInstalled 4340
#define kNtErrorIeportFull 4341
#define kNtErrorFileOffline 4350
#define kNtErrorRemoteStorageNotActive 4351
#define kNtErrorRemoteStorageMediaError 4352
#define kNtErrorNotAReparsePoint 4390
#define kNtErrorReparseAttributeConflict 4391
#define kNtErrorInvalidReparseData 4392
#define kNtErrorReparseTagInvalid 4393
#define kNtErrorReparseTagMismatch 4394
#define kNtErrorReparsePointEncountered 4395
#define kNtErrorAppDataNotFound 4400
#define kNtErrorAppDataExpired 4401
#define kNtErrorAppDataCorrupt 4402
#define kNtErrorAppDataLimitExceeded 4403
#define kNtErrorAppDataRebootRequired 4404
#define kNtErrorSecurebootRollbackDetected 4420
#define kNtErrorSecurebootPolicyViolation 4421
#define kNtErrorSecurebootInvalidPolicy 4422
#define kNtErrorSecurebootPolicyPublisherNotFound 4423
#define kNtErrorSecurebootPolicyNotSigned 4424
#define kNtErrorSecurebootNotEnabled 4425
#define kNtErrorSecurebootFileReplaced 4426
#define kNtErrorSecurebootPolicyNotAuthorized 4427
#define kNtErrorSecurebootPolicyUnknown 4428
#define kNtErrorSecurebootPolicyMissingAntirollbackversion 4429
#define kNtErrorSecurebootPlatformIdMismatch 4430
#define kNtErrorSecurebootPolicyRollbackDetected 4431
#define kNtErrorSecurebootPolicyUpgradeMismatch 4432
#define kNtErrorSecurebootRequiredPolicyFileMissing 4433
#define kNtErrorSecurebootNotBasePolicy 4434
#define kNtErrorSecurebootNotSupplementalPolicy 4435
#define kNtErrorOffloadReadFltNotSupported 4440
#define kNtErrorOffloadWriteFltNotSupported 4441
#define kNtErrorOffloadReadFileNotSupported 4442
#define kNtErrorOffloadWriteFileNotSupported 4443
#define kNtErrorAlreadyHasStreamId 4444
#define kNtErrorSmrGarbageCollectionRequired 4445
#define kNtErrorWofWimHeaderCorrupt 4446
#define kNtErrorWofWimResourceTableCorrupt 4447
#define kNtErrorWofFileResourceTableCorrupt 4448
#define kNtErrorVolumeNotSisEnabled 4500
#define kNtErrorSystemIntegrityRollbackDetected 4550
#define kNtErrorSystemIntegrityPolicyViolation 4551
#define kNtErrorSystemIntegrityInvalidPolicy 4552
#define kNtErrorSystemIntegrityPolicyNotSigned 4553
#define kNtErrorVsmNotInitialized 4560
#define kNtErrorVsmDmaProtectionNotInUse 4561
#define kNtErrorPlatformManifestNotAuthorized 4570
#define kNtErrorPlatformManifestInvalid 4571
#define kNtErrorPlatformManifestFileNotAuthorized 4572
#define kNtErrorPlatformManifestCatalogNotAuthorized 4573
#define kNtErrorPlatformManifestBinaryIdNotFound 4574
#define kNtErrorPlatformManifestNotActive 4575
#define kNtErrorPlatformManifestNotSigned 4576
#define kNtErrorDependentResourceExists 5001
#define kNtErrorDependencyNotFound 5002
#define kNtErrorDependencyAlreadyExists 5003
#define kNtErrorResourceNotOnline 5004
#define kNtErrorHostNodeNotAvailable 5005
#define kNtErrorResourceNotAvailable 5006
#define kNtErrorResourceNotFound 5007
#define kNtErrorShutdownCluster 5008
#define kNtErrorCantEvictActiveNode 5009
#define kNtErrorObjectAlreadyExists 5010
#define kNtErrorObjectInList 5011
#define kNtErrorGroupNotAvailable 5012
#define kNtErrorGroupNotFound 5013
#define kNtErrorGroupNotOnline 5014
#define kNtErrorHostNodeNotResourceOwner 5015
#define kNtErrorHostNodeNotGroupOwner 5016
#define kNtErrorResmonCreateFailed 5017
#define kNtErrorResmonOnlineFailed 5018
#define kNtErrorResourceOnline 5019
#define kNtErrorQuorumResource 5020
#define kNtErrorNotQuorumCapable 5021
#define kNtErrorClusterShuttingDown 5022
#define kNtErrorInvalidState 5023
#define kNtErrorResourcePropertiesStored 5024
#define kNtErrorNotQuorumClass 5025
#define kNtErrorCoreResource 5026
#define kNtErrorQuorumResourceOnlineFailed 5027
#define kNtErrorQuorumlogOpenFailed 5028
#define kNtErrorClusterlogCorrupt 5029
#define kNtErrorClusterlogRecordExceedsMaxsize 5030
#define kNtErrorClusterlogExceedsMaxsize 5031
#define kNtErrorClusterlogChkpointNotFound 5032
#define kNtErrorClusterlogNotEnoughSpace 5033
#define kNtErrorQuorumOwnerAlive 5034
#define kNtErrorNetworkNotAvailable 5035
#define kNtErrorNodeNotAvailable 5036
#define kNtErrorAllNodesNotAvailable 5037
#define kNtErrorResourceFailed 5038
#define kNtErrorClusterInvalidNode 5039
#define kNtErrorClusterNodeExists 5040
#define kNtErrorClusterJoinInProgress 5041
#define kNtErrorClusterNodeNotFound 5042
#define kNtErrorClusterLocalNodeNotFound 5043
#define kNtErrorClusterNetworkExists 5044
#define kNtErrorClusterNetworkNotFound 5045
#define kNtErrorClusterNetinterfaceExists 5046
#define kNtErrorClusterNetinterfaceNotFound 5047
#define kNtErrorClusterInvalidRequest 5048
#define kNtErrorClusterInvalidNetworkProvider 5049
#define kNtErrorClusterNodeDown 5050
#define kNtErrorClusterNodeUnreachable 5051
#define kNtErrorClusterNodeNotMember 5052
#define kNtErrorClusterJoinNotInProgress 5053
#define kNtErrorClusterInvalidNetwork 5054
#define kNtErrorClusterNodeUp 5056
#define kNtErrorClusterIpaddrInUse 5057
#define kNtErrorClusterNodeNotPaused 5058
#define kNtErrorClusterNoSecurityContext 5059
#define kNtErrorClusterNetworkNotInternal 5060
#define kNtErrorClusterNodeAlreadyUp 5061
#define kNtErrorClusterNodeAlreadyDown 5062
#define kNtErrorClusterNetworkAlreadyOnline 5063
#define kNtErrorClusterNetworkAlreadyOffline 5064
#define kNtErrorClusterNodeAlreadyMember 5065
#define kNtErrorClusterLastInternalNetwork 5066
#define kNtErrorClusterNetworkHasDependents 5067
#define kNtErrorInvalidOperationOnQuorum 5068
#define kNtErrorDependencyNotAllowed 5069
#define kNtErrorClusterNodePaused 5070
#define kNtErrorNodeCantHostResource 5071
#define kNtErrorClusterNodeNotReady 5072
#define kNtErrorClusterNodeShuttingDown 5073
#define kNtErrorClusterJoinAborted 5074
#define kNtErrorClusterIncompatibleVersions 5075
#define kNtErrorClusterMaxnumOfResourcesExceeded 5076
#define kNtErrorClusterSystemConfigChanged 5077
#define kNtErrorClusterResourceTypeNotFound 5078
#define kNtErrorClusterRestypeNotSupported 5079
#define kNtErrorClusterResnameNotFound 5080
#define kNtErrorClusterNoRpcPackagesRegistered 5081
#define kNtErrorClusterOwnerNotInPreflist 5082
#define kNtErrorClusterDatabaseSeqmismatch 5083
#define kNtErrorResmonInvalidState 5084
#define kNtErrorClusterGumNotLocker 5085
#define kNtErrorQuorumDiskNotFound 5086
#define kNtErrorDatabaseBackupCorrupt 5087
#define kNtErrorClusterNodeAlreadyHasDfsRoot 5088
#define kNtErrorResourcePropertyUnchangeable 5089
#define kNtErrorNoAdminAccessPoint 5090
#define kNtErrorClusterMembershipInvalidState 5890
#define kNtErrorClusterQuorumlogNotFound 5891
#define kNtErrorClusterMembershipHalt 5892
#define kNtErrorClusterInstanceIdMismatch 5893
#define kNtErrorClusterNetworkNotFoundForIp 5894
#define kNtErrorClusterPropertyDataTypeMismatch 5895
#define kNtErrorClusterEvictWithoutCleanup 5896
#define kNtErrorClusterParameterMismatch 5897
#define kNtErrorNodeCannotBeClustered 5898
#define kNtErrorClusterWrongOsVersion 5899
#define kNtErrorClusterCantCreateDupClusterName 5900
#define kNtErrorCluscfgAlreadyCommitted 5901
#define kNtErrorCluscfgRollbackFailed 5902
#define kNtErrorCluscfgSystemDiskDriveLetterConflict 5903
#define kNtErrorClusterOldVersion 5904
#define kNtErrorClusterMismatchedComputerAcctName 5905
#define kNtErrorClusterNoNetAdapters 5906
#define kNtErrorClusterPoisoned 5907
#define kNtErrorClusterGroupMoving 5908
#define kNtErrorClusterResourceTypeBusy 5909
#define kNtErrorResourceCallTimedOut 5910
#define kNtErrorInvalidClusterIpv6Address 5911
#define kNtErrorClusterInternalInvalidFunction 5912
#define kNtErrorClusterParameterOutOfBounds 5913
#define kNtErrorClusterPartialSend 5914
#define kNtErrorClusterRegistryInvalidFunction 5915
#define kNtErrorClusterInvalidStringTermination 5916
#define kNtErrorClusterInvalidStringFormat 5917
#define kNtErrorClusterDatabaseTransactionInProgress 5918
#define kNtErrorClusterDatabaseTransactionNotInProgress 5919
#define kNtErrorClusterNullData 5920
#define kNtErrorClusterPartialRead 5921
#define kNtErrorClusterPartialWrite 5922
#define kNtErrorClusterCantDeserializeData 5923
#define kNtErrorDependentResourcePropertyConflict 5924
#define kNtErrorClusterNoQuorum 5925
#define kNtErrorClusterInvalidIpv6Network 5926
#define kNtErrorClusterInvalidIpv6TunnelNetwork 5927
#define kNtErrorQuorumNotAllowedInThisGroup 5928
#define kNtErrorDependencyTreeTooComplex 5929
#define kNtErrorExceptionInResourceCall 5930
#define kNtErrorClusterRhsFailedInitialization 5931
#define kNtErrorClusterNotInstalled 5932
#define kNtErrorClusterResourcesMustBeOnlineOnTheSameNode 5933
#define kNtErrorClusterMaxNodesInCluster 5934
#define kNtErrorClusterTooManyNodes 5935
#define kNtErrorClusterObjectAlreadyUsed 5936
#define kNtErrorNoncoreGroupsFound 5937
#define kNtErrorFileShareResourceConflict 5938
#define kNtErrorClusterEvictInvalidRequest 5939
#define kNtErrorClusterSingletonResource 5940
#define kNtErrorClusterGroupSingletonResource 5941
#define kNtErrorClusterResourceProviderFailed 5942
#define kNtErrorClusterResourceConfigurationError 5943
#define kNtErrorClusterGroupBusy 5944
#define kNtErrorClusterNotSharedVolume 5945
#define kNtErrorClusterInvalidSecurityDescriptor 5946
#define kNtErrorClusterSharedVolumesInUse 5947
#define kNtErrorClusterUseSharedVolumesApi 5948
#define kNtErrorClusterBackupInProgress 5949
#define kNtErrorNonCsvPath 5950
#define kNtErrorCsvVolumeNotLocal 5951
#define kNtErrorClusterWatchdogTerminating 5952
#define kNtErrorClusterResourceVetoedMoveIncompatibleNodes 5953
#define kNtErrorClusterInvalidNodeWeight 5954
#define kNtErrorClusterResourceVetoedCall 5955
#define kNtErrorResmonSystemResourcesLacking 5956
#define kNtErrorClusterResourceVetoedMoveNotEnoughResourcesOnSource 5958
#define kNtErrorClusterGroupQueued 5959
#define kNtErrorClusterResourceLockedStatus 5960
#define kNtErrorClusterSharedVolumeFailoverNotAllowed 5961
#define kNtErrorClusterNodeDrainInProgress 5962
#define kNtErrorClusterDiskNotConnected 5963
#define kNtErrorDiskNotCsvCapable 5964
#define kNtErrorResourceNotInAvailableStorage 5965
#define kNtErrorClusterSharedVolumeRedirected 5966
#define kNtErrorClusterSharedVolumeNotRedirected 5967
#define kNtErrorClusterCannotReturnProperties 5968
#define kNtErrorClusterResourceIsInMaintenanceMode 5970
#define kNtErrorClusterAffinityConflict 5971
#define kNtErrorClusterResourceIsReplicaVirtualMachine 5972
#define kNtErrorClusterUpgradeIncompatibleVersions 5973
#define kNtErrorClusterUpgradeFixQuorumNotSupported 5974
#define kNtErrorClusterUpgradeRestartRequired 5975
#define kNtErrorClusterUpgradeInProgress 5976
#define kNtErrorClusterUpgradeIncomplete 5977
#define kNtErrorClusterNodeInGracePeriod 5978
#define kNtErrorClusterCsvIoPauseTimeout 5979
#define kNtErrorNodeNotActiveClusterMember 5980
#define kNtErrorClusterResourceNotMonitored 5981
#define kNtErrorClusterResourceDoesNotSupportUnmonitored 5982
#define kNtErrorClusterResourceIsReplicated 5983
#define kNtErrorClusterNodeIsolated 5984
#define kNtErrorClusterNodeQuarantined 5985
#define kNtErrorClusterDatabaseUpdateConditionFailed 5986
#define kNtErrorClusterSpaceDegraded 5987
#define kNtErrorClusterTokenDelegationNotSupported 5988
#define kNtErrorClusterCsvInvalidHandle 5989
#define kNtErrorClusterCsvSupportedOnlyOnCoordinator 5990
#define kNtErrorGroupsetNotAvailable 5991
#define kNtErrorGroupsetNotFound 5992
#define kNtErrorGroupsetCantProvide 5993
#define kNtErrorClusterFaultDomainParentNotFound 5994
#define kNtErrorClusterFaultDomainInvalidHierarchy 5995
#define kNtErrorClusterFaultDomainFailedS2dValidation 5996
#define kNtErrorClusterFaultDomainS2dConnectivityLoss 5997
#define kNtErrorClusterInvalidInfrastructureFileserverName 5998
#define kNtErrorClustersetManagementClusterUnreachable 5999
#define kNtErrorEncryptionFailed 6000
#define kNtErrorDecryptionFailed 6001
#define kNtErrorFileEncrypted 6002
#define kNtErrorNoRecoveryPolicy 6003
#define kNtErrorNoEfs 6004
#define kNtErrorWrongEfs 6005
#define kNtErrorNoUserKeys 6006
#define kNtErrorFileNotEncrypted 6007
#define kNtErrorNotExportFormat 6008
#define kNtErrorFileReadOnly 6009 /* EROFS */
#define kNtErrorDirEfsDisallowed 6010
#define kNtErrorEfsServerNotTrusted 6011
#define kNtErrorBadRecoveryPolicy 6012
#define kNtErrorEfsAlgBlobTooBig 6013
#define kNtErrorVolumeNotSupportEfs 6014
#define kNtErrorEfsDisabled 6015
#define kNtErrorEfsVersionNotSupport 6016
#define kNtErrorCsEncryptionInvalidServerResponse 6017
#define kNtErrorCsEncryptionUnsupportedServer 6018
#define kNtErrorCsEncryptionExistingEncryptedFile 6019
#define kNtErrorCsEncryptionNewEncryptedFile 6020
#define kNtErrorCsEncryptionFileNotCse 6021
#define kNtErrorEncryptionPolicyDeniesOperation 6022
#define kNtErrorNoBrowserServersFound 6118
#define kNtErrorLogSectorInvalid 6600
#define kNtErrorLogSectorParityInvalid 6601
#define kNtErrorLogSectorRemapped 6602
#define kNtErrorLogBlockIncomplete 6603
#define kNtErrorLogInvalidRange 6604
#define kNtErrorLogBlocksExhausted 6605
#define kNtErrorLogReadContextInvalid 6606
#define kNtErrorLogRestartInvalid 6607
#define kNtErrorLogBlockVersion 6608
#define kNtErrorLogBlockInvalid 6609
#define kNtErrorLogReadModeInvalid 6610
#define kNtErrorLogNoRestart 6611
#define kNtErrorLogMetadataCorrupt 6612
#define kNtErrorLogMetadataInvalid 6613
#define kNtErrorLogMetadataInconsistent 6614
#define kNtErrorLogReservationInvalid 6615
#define kNtErrorLogCantDelete 6616
#define kNtErrorLogContainerLimitExceeded 6617
#define kNtErrorLogStartOfLog 6618
#define kNtErrorLogPolicyAlreadyInstalled 6619
#define kNtErrorLogPolicyNotInstalled 6620
#define kNtErrorLogPolicyInvalid 6621
#define kNtErrorLogPolicyConflict 6622
#define kNtErrorLogPinnedArchiveTail 6623
#define kNtErrorLogRecordNonexistent 6624
#define kNtErrorLogRecordsReservedInvalid 6625
#define kNtErrorLogSpaceReservedInvalid 6626
#define kNtErrorLogTailInvalid 6627
#define kNtErrorLogFull 6628
#define kNtErrorCouldNotResizeLog 6629
#define kNtErrorLogMultiplexed 6630
#define kNtErrorLogDedicated 6631
#define kNtErrorLogArchiveNotInProgress 6632
#define kNtErrorLogArchiveInProgress 6633
#define kNtErrorLogEphemeral 6634
#define kNtErrorLogNotEnoughContainers 6635
#define kNtErrorLogClientAlreadyRegistered 6636
#define kNtErrorLogClientNotRegistered 6637
#define kNtErrorLogFullHandlerInProgress 6638
#define kNtErrorLogContainerReadFailed 6639
#define kNtErrorLogContainerWriteFailed 6640
#define kNtErrorLogContainerOpenFailed 6641
#define kNtErrorLogContainerStateInvalid 6642
#define kNtErrorLogStateInvalid 6643
#define kNtErrorLogPinned 6644
#define kNtErrorLogMetadataFlushFailed 6645
#define kNtErrorLogInconsistentSecurity 6646
#define kNtErrorLogAppendedFlushFailed 6647
#define kNtErrorLogPinnedReservation 6648
#define kNtErrorInvalidTransaction 6700
#define kNtErrorTransactionNotActive 6701
#define kNtErrorTransactionRequestNotValid 6702
#define kNtErrorTransactionNotRequested 6703
#define kNtErrorTransactionAlreadyAborted 6704
#define kNtErrorTransactionAlreadyCommitted 6705
#define kNtErrorTmInitializationFailed 6706
#define kNtErrorResourcemanagerReadOnly 6707
#define kNtErrorTransactionNotJoined 6708
#define kNtErrorTransactionSuperiorExists 6709
#define kNtErrorCrmProtocolAlreadyExists 6710
#define kNtErrorTransactionPropagationFailed 6711
#define kNtErrorCrmProtocolNotFound 6712
#define kNtErrorTransactionInvalidMarshallBuffer 6713
#define kNtErrorCurrentTransactionNotValid 6714
#define kNtErrorTransactionNotFound 6715
#define kNtErrorResourcemanagerNotFound 6716
#define kNtErrorEnlistmentNotFound 6717
#define kNtErrorTransactionmanagerNotFound 6718
#define kNtErrorTransactionmanagerNotOnline 6719
#define kNtErrorTransactionmanagerRecoveryNameCollision 6720
#define kNtErrorTransactionNotRoot 6721
#define kNtErrorTransactionObjectExpired 6722
#define kNtErrorTransactionResponseNotEnlisted 6723
#define kNtErrorTransactionRecordTooLong 6724
#define kNtErrorImplicitTransactionNotSupported 6725
#define kNtErrorTransactionIntegrityViolated 6726
#define kNtErrorTransactionmanagerIdentityMismatch 6727
#define kNtErrorRmCannotBeFrozenForSnapshot 6728
#define kNtErrorTransactionMustWritethrough 6729
#define kNtErrorTransactionNoSuperior 6730
#define kNtErrorHeuristicDamagePossible 6731
#define kNtErrorTransactionalConflict 6800
#define kNtErrorRmNotActive 6801
#define kNtErrorRmMetadataCorrupt 6802
#define kNtErrorDirectoryNotRm 6803
#define kNtErrorTransactionsUnsupportedRemote 6805
#define kNtErrorLogResizeInvalidSize 6806
#define kNtErrorObjectNoLongerExists 6807
#define kNtErrorStreamMiniversionNotFound 6808
#define kNtErrorStreamMiniversionNotValid 6809
#define kNtErrorMiniversionInaccessibleFromSpecifiedTransaction 6810
#define kNtErrorCantOpenMiniversionWithModifyIntent 6811
#define kNtErrorCantCreateMoreStreamMiniversions 6812
#define kNtErrorRemoteFileVersionMismatch 6814
#define kNtErrorHandleNoLongerValid 6815
#define kNtErrorNoTxfMetadata 6816
#define kNtErrorLogCorruptionDetected 6817
#define kNtErrorCantRecoverWithHandleOpen 6818
#define kNtErrorRmDisconnected 6819
#define kNtErrorEnlistmentNotSuperior 6820
#define kNtErrorRecoveryNotNeeded 6821
#define kNtErrorRmAlreadyStarted 6822
#define kNtErrorFileIdentityNotPersistent 6823
#define kNtErrorCantBreakTransactionalDependency 6824
#define kNtErrorCantCrossRmBoundary 6825
#define kNtErrorTxfDirNotEmpty 6826
#define kNtErrorIndoubtTransactionsExist 6827
#define kNtErrorTmVolatile 6828
#define kNtErrorRollbackTimerExpired 6829
#define kNtErrorTxfAttributeCorrupt 6830
#define kNtErrorEfsNotAllowedInTransaction 6831
#define kNtErrorTransactionalOpenNotAllowed 6832
#define kNtErrorLogGrowthFailed 6833
#define kNtErrorTransactedMappingUnsupportedRemote 6834
#define kNtErrorTxfMetadataAlreadyPresent 6835
#define kNtErrorTransactionScopeCallbacksNotSet 6836
#define kNtErrorTransactionRequiredPromotion 6837
#define kNtErrorCannotExecuteFileInTransaction 6838
#define kNtErrorTransactionsNotFrozen 6839
#define kNtErrorTransactionFreezeInProgress 6840
#define kNtErrorNotSnapshotVolume 6841
#define kNtErrorNoSavepointWithOpenFiles 6842
#define kNtErrorDataLostRepair 6843
#define kNtErrorSparseNotAllowedInTransaction 6844
#define kNtErrorTmIdentityMismatch 6845
#define kNtErrorFloatedSection 6846
#define kNtErrorCannotAcceptTransactedWork 6847
#define kNtErrorCannotAbortTransactions 6848
#define kNtErrorBadClusters 6849
#define kNtErrorCompressionNotAllowedInTransaction 6850
#define kNtErrorVolumeDirty 6851
#define kNtErrorNoLinkTrackingInTransaction 6852
#define kNtErrorOperationNotSupportedInTransaction 6853
#define kNtErrorExpiredHandle 6854
#define kNtErrorTransactionNotEnlisted 6855
#define kNtErrorCtxWinstationNameInvalid 7001
#define kNtErrorCtxInvalidPd 7002
#define kNtErrorCtxPdNotFound 7003
#define kNtErrorCtxWdNotFound 7004
#define kNtErrorCtxCannotMakeEventlogEntry 7005
#define kNtErrorCtxServiceNameCollision 7006
#define kNtErrorCtxClosePending 7007
#define kNtErrorCtxNoOutbuf 7008
#define kNtErrorCtxModemInfNotFound 7009
#define kNtErrorCtxInvalidModemname 7010
#define kNtErrorCtxModemResponseError 7011
#define kNtErrorCtxModemResponseTimeout 7012
#define kNtErrorCtxModemResponseNoCarrier 7013
#define kNtErrorCtxModemResponseNoDialtone 7014
#define kNtErrorCtxModemResponseBusy 7015
#define kNtErrorCtxModemResponseVoice 7016
#define kNtErrorCtxTdError 7017
#define kNtErrorCtxWinstationNotFound 7022
#define kNtErrorCtxWinstationAlreadyExists 7023
#define kNtErrorCtxWinstationBusy 7024
#define kNtErrorCtxBadVideoMode 7025
#define kNtErrorCtxGraphicsInvalid 7035
#define kNtErrorCtxLogonDisabled 7037
#define kNtErrorCtxNotConsole 7038
#define kNtErrorCtxClientQueryTimeout 7040
#define kNtErrorCtxConsoleDisconnect 7041
#define kNtErrorCtxConsoleConnect 7042
#define kNtErrorCtxShadowDenied 7044
#define kNtErrorCtxWinstationAccessDenied 7045
#define kNtErrorCtxInvalidWd 7049
#define kNtErrorCtxShadowInvalid 7050
#define kNtErrorCtxShadowDisabled 7051
#define kNtErrorCtxClientLicenseInUse 7052
#define kNtErrorCtxClientLicenseNotSet 7053
#define kNtErrorCtxLicenseNotAvailable 7054
#define kNtErrorCtxLicenseClientInvalid 7055
#define kNtErrorCtxLicenseExpired 7056
#define kNtErrorCtxShadowNotRunning 7057
#define kNtErrorCtxShadowEndedByModeChange 7058
#define kNtErrorActivationCountExceeded 7059
#define kNtErrorCtxWinstationsDisabled 7060
#define kNtErrorCtxEncryptionLevelRequired 7061
#define kNtErrorCtxSessionInUse 7062
#define kNtErrorCtxNoForceLogoff 7063
#define kNtErrorCtxAccountRestriction 7064
#define kNtErrorRdpProtocolError 7065
#define kNtErrorCtxCdmConnect 7066
#define kNtErrorCtxCdmDisconnect 7067
#define kNtErrorCtxSecurityLayerError 7068
#define kNtErrorTsIncompatibleSessions 7069
#define kNtErrorTsVideoSubsystemError 7070
#define kNtErrorDsNotInstalled 8200
#define kNtErrorDsMembershipEvaluatedLocally 8201
#define kNtErrorDsNoAttributeOrValue 8202
#define kNtErrorDsInvalidAttributeSyntax 8203
#define kNtErrorDsAttributeTypeUndefined 8204
#define kNtErrorDsAttributeOrValueExists 8205
#define kNtErrorDsBusy 8206
#define kNtErrorDsUnavailable 8207
#define kNtErrorDsNoRidsAllocated 8208
#define kNtErrorDsNoMoreRids 8209
#define kNtErrorDsIncorrectRoleOwner 8210
#define kNtErrorDsRidmgrInitError 8211
#define kNtErrorDsObjClassViolation 8212
#define kNtErrorDsCantOnNonLeaf 8213
#define kNtErrorDsCantOnRdn 8214
#define kNtErrorDsCantModObjClass 8215
#define kNtErrorDsCrossDomMoveError 8216
#define kNtErrorDsGcNotAvailable 8217
#define kNtErrorSharedPolicy 8218
#define kNtErrorPolicyObjectNotFound 8219
#define kNtErrorPolicyOnlyInDs 8220
#define kNtErrorPromotionActive 8221
#define kNtErrorNoPromotionActive 8222
#define kNtErrorDsOperationsError 8224
#define kNtErrorDsProtocolError 8225
#define kNtErrorDsTimelimitExceeded 8226
#define kNtErrorDsSizelimitExceeded 8227
#define kNtErrorDsAdminLimitExceeded 8228
#define kNtErrorDsCompareFalse 8229
#define kNtErrorDsCompareTrue 8230
#define kNtErrorDsAuthMethodNotSupported 8231
#define kNtErrorDsStrongAuthRequired 8232
#define kNtErrorDsInappropriateAuth 8233
#define kNtErrorDsAuthUnknown 8234
#define kNtErrorDsReferral 8235
#define kNtErrorDsUnavailableCritExtension 8236
#define kNtErrorDsConfidentialityRequired 8237
#define kNtErrorDsInappropriateMatching 8238
#define kNtErrorDsConstraintViolation 8239
#define kNtErrorDsNoSuchObject 8240
#define kNtErrorDsAliasProblem 8241
#define kNtErrorDsInvalidDnSyntax 8242
#define kNtErrorDsIsLeaf 8243
#define kNtErrorDsAliasDerefProblem 8244
#define kNtErrorDsUnwillingToPerform 8245
#define kNtErrorDsLoopDetect 8246
#define kNtErrorDsNamingViolation 8247
#define kNtErrorDsObjectResultsTooLarge 8248
#define kNtErrorDsAffectsMultipleDsas 8249
#define kNtErrorDsServerDown 8250
#define kNtErrorDsLocalError 8251
#define kNtErrorDsEncodingError 8252
#define kNtErrorDsDecodingError 8253
#define kNtErrorDsFilterUnknown 8254
#define kNtErrorDsParamError 8255
#define kNtErrorDsNotSupported 8256
#define kNtErrorDsNoResultsReturned 8257
#define kNtErrorDsControlNotFound 8258
#define kNtErrorDsClientLoop 8259
#define kNtErrorDsReferralLimitExceeded 8260
#define kNtErrorDsSortControlMissing 8261
#define kNtErrorDsOffsetRangeError 8262
#define kNtErrorDsRidmgrDisabled 8263
#define kNtErrorDsRootMustBeNc 8301
#define kNtErrorDsAddReplicaInhibited 8302
#define kNtErrorDsAttNotDefInSchema 8303
#define kNtErrorDsMaxObjSizeExceeded 8304
#define kNtErrorDsObjStringNameExists 8305
#define kNtErrorDsNoRdnDefinedInSchema 8306
#define kNtErrorDsRdnDoesntMatchSchema 8307
#define kNtErrorDsNoRequestedAttsFound 8308
#define kNtErrorDsUserBufferToSmall 8309
#define kNtErrorDsAttIsNotOnObj 8310
#define kNtErrorDsIllegalModOperation 8311
#define kNtErrorDsObjTooLarge 8312
#define kNtErrorDsBadInstanceType 8313
#define kNtErrorDsMasterdsaRequired 8314
#define kNtErrorDsObjectClassRequired 8315
#define kNtErrorDsMissingRequiredAtt 8316
#define kNtErrorDsAttNotDefForClass 8317
#define kNtErrorDsAttAlreadyExists 8318
#define kNtErrorDsCantAddAttValues 8320
#define kNtErrorDsSingleValueConstraint 8321
#define kNtErrorDsRangeConstraint 8322
#define kNtErrorDsAttValAlreadyExists 8323
#define kNtErrorDsCantRemMissingAtt 8324
#define kNtErrorDsCantRemMissingAttVal 8325
#define kNtErrorDsRootCantBeSubref 8326
#define kNtErrorDsNoChaining 8327
#define kNtErrorDsNoChainedEval 8328
#define kNtErrorDsNoParentObject 8329
#define kNtErrorDsParentIsAnAlias 8330
#define kNtErrorDsCantMixMasterAndReps 8331
#define kNtErrorDsChildrenExist 8332
#define kNtErrorDsObjNotFound 8333
#define kNtErrorDsAliasedObjMissing 8334
#define kNtErrorDsBadNameSyntax 8335
#define kNtErrorDsAliasPointsToAlias 8336
#define kNtErrorDsCantDerefAlias 8337
#define kNtErrorDsOutOfScope 8338
#define kNtErrorDsObjectBeingRemoved 8339
#define kNtErrorDsCantDeleteDsaObj 8340
#define kNtErrorDsGenericError 8341
#define kNtErrorDsDsaMustBeIntMaster 8342
#define kNtErrorDsClassNotDsa 8343
#define kNtErrorDsInsuffAccessRights 8344
#define kNtErrorDsIllegalSuperior 8345
#define kNtErrorDsAttributeOwnedBySam 8346
#define kNtErrorDsNameTooManyParts 8347
#define kNtErrorDsNameTooLong 8348
#define kNtErrorDsNameValueTooLong 8349
#define kNtErrorDsNameUnparseable 8350
#define kNtErrorDsNameTypeUnknown 8351
#define kNtErrorDsNotAnObject 8352
#define kNtErrorDsSecDescTooShort 8353
#define kNtErrorDsSecDescInvalid 8354
#define kNtErrorDsNoDeletedName 8355
#define kNtErrorDsSubrefMustHaveParent 8356
#define kNtErrorDsNcnameMustBeNc 8357
#define kNtErrorDsCantAddSystemOnly 8358
#define kNtErrorDsClassMustBeConcrete 8359
#define kNtErrorDsInvalidDmd 8360
#define kNtErrorDsObjGuidExists 8361
#define kNtErrorDsNotOnBacklink 8362
#define kNtErrorDsNoCrossrefForNc 8363
#define kNtErrorDsShuttingDown 8364
#define kNtErrorDsUnknownOperation 8365
#define kNtErrorDsInvalidRoleOwner 8366
#define kNtErrorDsCouldntContactFsmo 8367
#define kNtErrorDsCrossNcDnRename 8368
#define kNtErrorDsCantModSystemOnly 8369
#define kNtErrorDsReplicatorOnly 8370
#define kNtErrorDsObjClassNotDefined 8371
#define kNtErrorDsObjClassNotSubclass 8372
#define kNtErrorDsNameReferenceInvalid 8373
#define kNtErrorDsCrossRefExists 8374
#define kNtErrorDsCantDelMasterCrossref 8375
#define kNtErrorDsSubtreeNotifyNotNcHead 8376
#define kNtErrorDsNotifyFilterTooComplex 8377
#define kNtErrorDsDupRdn 8378
#define kNtErrorDsDupOid 8379
#define kNtErrorDsDupMapiId 8380
#define kNtErrorDsDupSchemaIdGuid 8381
#define kNtErrorDsDupLdapDisplayName 8382
#define kNtErrorDsSemanticAttTest 8383
#define kNtErrorDsSyntaxMismatch 8384
#define kNtErrorDsExistsInMustHave 8385
#define kNtErrorDsExistsInMayHave 8386
#define kNtErrorDsNonexistentMayHave 8387
#define kNtErrorDsNonexistentMustHave 8388
#define kNtErrorDsAuxClsTestFail 8389
#define kNtErrorDsNonexistentPossSup 8390
#define kNtErrorDsSubClsTestFail 8391
#define kNtErrorDsBadRdnAttIdSyntax 8392
#define kNtErrorDsExistsInAuxCls 8393
#define kNtErrorDsExistsInSubCls 8394
#define kNtErrorDsExistsInPossSup 8395
#define kNtErrorDsRecalcschemaFailed 8396
#define kNtErrorDsTreeDeleteNotFinished 8397
#define kNtErrorDsCantDelete 8398
#define kNtErrorDsAttSchemaReqId 8399
#define kNtErrorDsBadAttSchemaSyntax 8400
#define kNtErrorDsCantCacheAtt 8401
#define kNtErrorDsCantCacheClass 8402
#define kNtErrorDsCantRemoveAttCache 8403
#define kNtErrorDsCantRemoveClassCache 8404
#define kNtErrorDsCantRetrieveDn 8405
#define kNtErrorDsMissingSupref 8406
#define kNtErrorDsCantRetrieveInstance 8407
#define kNtErrorDsCodeInconsistency 8408
#define kNtErrorDsDatabaseError 8409
#define kNtErrorDsGovernsidMissing 8410
#define kNtErrorDsMissingExpectedAtt 8411
#define kNtErrorDsNcnameMissingCrRef 8412
#define kNtErrorDsSecurityCheckingError 8413
#define kNtErrorDsSchemaNotLoaded 8414
#define kNtErrorDsSchemaAllocFailed 8415
#define kNtErrorDsAttSchemaReqSyntax 8416
#define kNtErrorDsGcverifyError 8417
#define kNtErrorDsDraSchemaMismatch 8418
#define kNtErrorDsCantFindDsaObj 8419
#define kNtErrorDsCantFindExpectedNc 8420
#define kNtErrorDsCantFindNcInCache 8421
#define kNtErrorDsCantRetrieveChild 8422
#define kNtErrorDsSecurityIllegalModify 8423
#define kNtErrorDsCantReplaceHiddenRec 8424
#define kNtErrorDsBadHierarchyFile 8425
#define kNtErrorDsBuildHierarchyTableFailed 8426
#define kNtErrorDsConfigParamMissing 8427
#define kNtErrorDsCountingAbIndicesFailed 8428
#define kNtErrorDsHierarchyTableMallocFailed 8429
#define kNtErrorDsInternalFailure 8430
#define kNtErrorDsUnknownError 8431
#define kNtErrorDsRootRequiresClassTop 8432
#define kNtErrorDsRefusingFsmoRoles 8433
#define kNtErrorDsMissingFsmoSettings 8434
#define kNtErrorDsUnableToSurrenderRoles 8435
#define kNtErrorDsDraGeneric 8436
#define kNtErrorDsDraInvalidParameter 8437
#define kNtErrorDsDraBusy 8438
#define kNtErrorDsDraBadDn 8439
#define kNtErrorDsDraBadNc 8440
#define kNtErrorDsDraDnExists 8441
#define kNtErrorDsDraInternalError 8442
#define kNtErrorDsDraInconsistentDit 8443
#define kNtErrorDsDraConnectionFailed 8444
#define kNtErrorDsDraBadInstanceType 8445
#define kNtErrorDsDraOutOfMem 8446
#define kNtErrorDsDraMailProblem 8447
#define kNtErrorDsDraRefAlreadyExists 8448
#define kNtErrorDsDraRefNotFound 8449
#define kNtErrorDsDraObjIsRepSource 8450
#define kNtErrorDsDraDbError 8451
#define kNtErrorDsDraNoReplica 8452
#define kNtErrorDsDraAccessDenied 8453
#define kNtErrorDsDraNotSupported 8454
#define kNtErrorDsDraRpcCancelled 8455
#define kNtErrorDsDraSourceDisabled 8456
#define kNtErrorDsDraSinkDisabled 8457
#define kNtErrorDsDraNameCollision 8458
#define kNtErrorDsDraSourceReinstalled 8459
#define kNtErrorDsDraMissingParent 8460
#define kNtErrorDsDraPreempted 8461
#define kNtErrorDsDraAbandonSync 8462
#define kNtErrorDsDraShutdown 8463
#define kNtErrorDsDraIncompatiblePartialSet 8464
#define kNtErrorDsDraSourceIsPartialReplica 8465
#define kNtErrorDsDraExtnConnectionFailed 8466
#define kNtErrorDsInstallSchemaMismatch 8467
#define kNtErrorDsDupLinkId 8468
#define kNtErrorDsNameErrorResolving 8469
#define kNtErrorDsNameErrorNotFound 8470
#define kNtErrorDsNameErrorNotUnique 8471
#define kNtErrorDsNameErrorNoMapping 8472
#define kNtErrorDsNameErrorDomainOnly 8473
#define kNtErrorDsNameErrorNoSyntacticalMapping 8474
#define kNtErrorDsConstructedAttMod 8475
#define kNtErrorDsWrongOmObjClass 8476
#define kNtErrorDsDraReplPending 8477
#define kNtErrorDsDsRequired 8478
#define kNtErrorDsInvalidLdapDisplayName 8479
#define kNtErrorDsNonBaseSearch 8480
#define kNtErrorDsCantRetrieveAtts 8481
#define kNtErrorDsBacklinkWithoutLink 8482
#define kNtErrorDsEpochMismatch 8483
#define kNtErrorDsSrcNameMismatch 8484
#define kNtErrorDsSrcAndDstNcIdentical 8485
#define kNtErrorDsDstNcMismatch 8486
#define kNtErrorDsNotAuthoritiveForDstNc 8487
#define kNtErrorDsSrcGuidMismatch 8488
#define kNtErrorDsCantMoveDeletedObject 8489
#define kNtErrorDsPdcOperationInProgress 8490
#define kNtErrorDsCrossDomainCleanupReqd 8491
#define kNtErrorDsIllegalXdomMoveOperation 8492
#define kNtErrorDsCantWithAcctGroupMembershps 8493
#define kNtErrorDsNcMustHaveNcParent 8494
#define kNtErrorDsCrImpossibleToValidate 8495
#define kNtErrorDsDstDomainNotNative 8496
#define kNtErrorDsMissingInfrastructureContainer 8497
#define kNtErrorDsCantMoveAccountGroup 8498
#define kNtErrorDsCantMoveResourceGroup 8499
#define kNtErrorDsInvalidSearchFlag 8500
#define kNtErrorDsNoTreeDeleteAboveNc 8501
#define kNtErrorDsCouldntLockTreeForDelete 8502
#define kNtErrorDsCouldntIdentifyObjectsForTreeDelete 8503
#define kNtErrorDsSamInitFailure 8504
#define kNtErrorDsSensitiveGroupViolation 8505
#define kNtErrorDsCantModPrimarygroupid 8506
#define kNtErrorDsIllegalBaseSchemaMod 8507
#define kNtErrorDsNonsafeSchemaChange 8508
#define kNtErrorDsSchemaUpdateDisallowed 8509
#define kNtErrorDsCantCreateUnderSchema 8510
#define kNtErrorDsInstallNoSrcSchVersion 8511
#define kNtErrorDsInstallNoSchVersionInInifile 8512
#define kNtErrorDsInvalidGroupType 8513
#define kNtErrorDsNoNestGlobalgroupInMixeddomain 8514
#define kNtErrorDsNoNestLocalgroupInMixeddomain 8515
#define kNtErrorDsGlobalCantHaveLocalMember 8516
#define kNtErrorDsGlobalCantHaveUniversalMember 8517
#define kNtErrorDsUniversalCantHaveLocalMember 8518
#define kNtErrorDsGlobalCantHaveCrossdomainMember 8519
#define kNtErrorDsLocalCantHaveCrossdomainLocalMember 8520
#define kNtErrorDsHavePrimaryMembers 8521
#define kNtErrorDsStringSdConversionFailed 8522
#define kNtErrorDsNamingMasterGc 8523
#define kNtErrorDsDnsLookupFailure 8524
#define kNtErrorDsCouldntUpdateSpns 8525
#define kNtErrorDsCantRetrieveSd 8526
#define kNtErrorDsKeyNotUnique 8527
#define kNtErrorDsWrongLinkedAttSyntax 8528
#define kNtErrorDsSamNeedBootkeyPassword 8529
#define kNtErrorDsSamNeedBootkeyFloppy 8530
#define kNtErrorDsCantStart 8531
#define kNtErrorDsInitFailure 8532
#define kNtErrorDsNoPktPrivacyOnConnection 8533
#define kNtErrorDsSourceDomainInForest 8534
#define kNtErrorDsDestinationDomainNotInForest 8535
#define kNtErrorDsDestinationAuditingNotEnabled 8536
#define kNtErrorDsCantFindDcForSrcDomain 8537
#define kNtErrorDsSrcObjNotGroupOrUser 8538
#define kNtErrorDsSrcSidExistsInForest 8539
#define kNtErrorDsSrcAndDstObjectClassMismatch 8540
#define kNtErrorSamInitFailure 8541
#define kNtErrorDsDraSchemaInfoShip 8542
#define kNtErrorDsDraSchemaConflict 8543
#define kNtErrorDsDraEarlierSchemaConflict 8544
#define kNtErrorDsDraObjNcMismatch 8545
#define kNtErrorDsNcStillHasDsas 8546
#define kNtErrorDsGcRequired 8547
#define kNtErrorDsLocalMemberOfLocalOnly 8548
#define kNtErrorDsNoFpoInUniversalGroups 8549
#define kNtErrorDsCantAddToGc 8550
#define kNtErrorDsNoCheckpointWithPdc 8551
#define kNtErrorDsSourceAuditingNotEnabled 8552
#define kNtErrorDsCantCreateInNondomainNc 8553
#define kNtErrorDsInvalidNameForSpn 8554
#define kNtErrorDsFilterUsesContructedAttrs 8555
#define kNtErrorDsUnicodepwdNotInQuotes 8556
#define kNtErrorDsMachineAccountQuotaExceeded 8557
#define kNtErrorDsMustBeRunOnDstDc 8558
#define kNtErrorDsSrcDcMustBeSp4OrGreater 8559
#define kNtErrorDsCantTreeDeleteCriticalObj 8560
#define kNtErrorDsInitFailureConsole 8561
#define kNtErrorDsSamInitFailureConsole 8562
#define kNtErrorDsForestVersionTooHigh 8563
#define kNtErrorDsDomainVersionTooHigh 8564
#define kNtErrorDsForestVersionTooLow 8565
#define kNtErrorDsDomainVersionTooLow 8566
#define kNtErrorDsIncompatibleVersion 8567
#define kNtErrorDsLowDsaVersion 8568
#define kNtErrorDsNoBehaviorVersionInMixeddomain 8569
#define kNtErrorDsNotSupportedSortOrder 8570
#define kNtErrorDsNameNotUnique 8571
#define kNtErrorDsMachineAccountCreatedPrent4 8572
#define kNtErrorDsOutOfVersionStore 8573
#define kNtErrorDsIncompatibleControlsUsed 8574
#define kNtErrorDsNoRefDomain 8575
#define kNtErrorDsReservedLinkId 8576
#define kNtErrorDsLinkIdNotAvailable 8577
#define kNtErrorDsAgCantHaveUniversalMember 8578
#define kNtErrorDsModifydnDisallowedByInstanceType 8579
#define kNtErrorDsNoObjectMoveInSchemaNc 8580
#define kNtErrorDsModifydnDisallowedByFlag 8581
#define kNtErrorDsModifydnWrongGrandparent 8582
#define kNtErrorDsNameErrorTrustReferral 8583
#define kNtErrorNotSupportedOnStandardServer 8584
#define kNtErrorDsCantAccessRemotePartOfAd 8585
#define kNtErrorDsCrImpossibleToValidateV2 8586
#define kNtErrorDsThreadLimitExceeded 8587
#define kNtErrorDsNotClosest 8588
#define kNtErrorDsCantDeriveSpnWithoutServerRef 8589
#define kNtErrorDsSingleUserModeFailed 8590
#define kNtErrorDsNtdscriptSyntaxError 8591
#define kNtErrorDsNtdscriptProcessError 8592
#define kNtErrorDsDifferentReplEpochs 8593
#define kNtErrorDsDrsExtensionsChanged 8594
#define kNtErrorDsReplicaSetChangeNotAllowedOnDisabledCr 8595
#define kNtErrorDsNoMsdsIntid 8596
#define kNtErrorDsDupMsdsIntid 8597
#define kNtErrorDsExistsInRdnattid 8598
#define kNtErrorDsAuthorizationFailed 8599
#define kNtErrorDsInvalidScript 8600
#define kNtErrorDsRemoteCrossrefOpFailed 8601
#define kNtErrorDsCrossRefBusy 8602
#define kNtErrorDsCantDeriveSpnForDeletedDomain 8603
#define kNtErrorDsCantDemoteWithWriteableNc 8604
#define kNtErrorDsDuplicateIdFound 8605
#define kNtErrorDsInsufficientAttrToCreateObject 8606
#define kNtErrorDsGroupConversionError 8607
#define kNtErrorDsCantMoveAppBasicGroup 8608
#define kNtErrorDsCantMoveAppQueryGroup 8609
#define kNtErrorDsRoleNotVerified 8610
#define kNtErrorDsWkoContainerCannotBeSpecial 8611
#define kNtErrorDsDomainRenameInProgress 8612
#define kNtErrorDsExistingAdChildNc 8613
#define kNtErrorDsReplLifetimeExceeded 8614
#define kNtErrorDsDisallowedInSystemContainer 8615
#define kNtErrorDsLdapSendQueueFull 8616
#define kNtErrorDsDraOutScheduleWindow 8617
#define kNtErrorDsPolicyNotKnown 8618
#define kNtErrorNoSiteSettingsObject 8619
#define kNtErrorNoSecrets 8620
#define kNtErrorNoWritableDcFound 8621
#define kNtErrorDsNoServerObject 8622
#define kNtErrorDsNoNtdsaObject 8623
#define kNtErrorDsNonAsqSearch 8624
#define kNtErrorDsAuditFailure 8625
#define kNtErrorDsInvalidSearchFlagSubtree 8626
#define kNtErrorDsInvalidSearchFlagTuple 8627
#define kNtErrorDsHierarchyTableTooDeep 8628
#define kNtErrorDsDraCorruptUtdVector 8629
#define kNtErrorDsDraSecretsDenied 8630
#define kNtErrorDsReservedMapiId 8631
#define kNtErrorDsMapiIdNotAvailable 8632
#define kNtErrorDsDraMissingKrbtgtSecret 8633
#define kNtErrorDsDomainNameExistsInForest 8634
#define kNtErrorDsFlatNameExistsInForest 8635
#define kNtErrorInvalidUserPrincipalName 8636
#define kNtErrorDsOidMappedGroupCantHaveMembers 8637
#define kNtErrorDsOidNotFound 8638
#define kNtErrorDsDraRecycledTarget 8639
#define kNtErrorDsDisallowedNcRedirect 8640
#define kNtErrorDsHighAdldsFfl 8641
#define kNtErrorDsHighDsaVersion 8642
#define kNtErrorDsLowAdldsFfl 8643
#define kNtErrorDomainSidSameAsLocalWorkstation 8644
#define kNtErrorDsUndeleteSamValidationFailed 8645
#define kNtErrorIncorrectAccountType 8646
#define kNtErrorDsSpnValueNotUniqueInForest 8647
#define kNtErrorDsUpnValueNotUniqueInForest 8648
#define kNtErrorDsMissingForestTrust 8649
#define kNtErrorDsValueKeyNotUnique 8650
#define kNtErrorIpsecQmPolicyExists 13000
#define kNtErrorIpsecQmPolicyNotFound 13001
#define kNtErrorIpsecQmPolicyInUse 13002
#define kNtErrorIpsecMmPolicyExists 13003
#define kNtErrorIpsecMmPolicyNotFound 13004
#define kNtErrorIpsecMmPolicyInUse 13005
#define kNtErrorIpsecMmFilterExists 13006
#define kNtErrorIpsecMmFilterNotFound 13007
#define kNtErrorIpsecTransportFilterExists 13008
#define kNtErrorIpsecTransportFilterNotFound 13009
#define kNtErrorIpsecMmAuthExists 13010
#define kNtErrorIpsecMmAuthNotFound 13011
#define kNtErrorIpsecMmAuthInUse 13012
#define kNtErrorIpsecDefaultMmPolicyNotFound 13013
#define kNtErrorIpsecDefaultMmAuthNotFound 13014
#define kNtErrorIpsecDefaultQmPolicyNotFound 13015
#define kNtErrorIpsecTunnelFilterExists 13016
#define kNtErrorIpsecTunnelFilterNotFound 13017
#define kNtErrorIpsecMmFilterPendingDeletion 13018
#define kNtErrorIpsecTransportFilterPendingDeletion 13019
#define kNtErrorIpsecTunnelFilterPendingDeletion 13020
#define kNtErrorIpsecMmPolicyPendingDeletion 13021
#define kNtErrorIpsecMmAuthPendingDeletion 13022
#define kNtErrorIpsecQmPolicyPendingDeletion 13023
#define kNtErrorIpsecIkeNegStatusBegin 13800
#define kNtErrorIpsecIkeAuthFail 13801
#define kNtErrorIpsecIkeAttribFail 13802
#define kNtErrorIpsecIkeNegotiationPending 13803
#define kNtErrorIpsecIkeGeneralProcessingError 13804
#define kNtErrorIpsecIkeTimedOut 13805
#define kNtErrorIpsecIkeNoCert 13806
#define kNtErrorIpsecIkeSaDeleted 13807
#define kNtErrorIpsecIkeSaReaped 13808
#define kNtErrorIpsecIkeMmAcquireDrop 13809
#define kNtErrorIpsecIkeQmAcquireDrop 13810
#define kNtErrorIpsecIkeQueueDropMm 13811
#define kNtErrorIpsecIkeQueueDropNoMm 13812
#define kNtErrorIpsecIkeDropNoResponse 13813
#define kNtErrorIpsecIkeMmDelayDrop 13814
#define kNtErrorIpsecIkeQmDelayDrop 13815
#define kNtErrorIpsecIkeError 13816
#define kNtErrorIpsecIkeCrlFailed 13817
#define kNtErrorIpsecIkeInvalidKeyUsage 13818
#define kNtErrorIpsecIkeInvalidCertType 13819
#define kNtErrorIpsecIkeNoPrivateKey 13820
#define kNtErrorIpsecIkeSimultaneousRekey 13821
#define kNtErrorIpsecIkeDhFail 13822
#define kNtErrorIpsecIkeCriticalPayloadNotRecognized 13823
#define kNtErrorIpsecIkeInvalidHeader 13824
#define kNtErrorIpsecIkeNoPolicy 13825
#define kNtErrorIpsecIkeInvalidSignature 13826
#define kNtErrorIpsecIkeKerberosError 13827
#define kNtErrorIpsecIkeNoPublicKey 13828
#define kNtErrorIpsecIkeProcessErr 13829
#define kNtErrorIpsecIkeProcessErrSa 13830
#define kNtErrorIpsecIkeProcessErrProp 13831
#define kNtErrorIpsecIkeProcessErrTrans 13832
#define kNtErrorIpsecIkeProcessErrKe 13833
#define kNtErrorIpsecIkeProcessErrId 13834
#define kNtErrorIpsecIkeProcessErrCert 13835
#define kNtErrorIpsecIkeProcessErrCertReq 13836
#define kNtErrorIpsecIkeProcessErrHash 13837
#define kNtErrorIpsecIkeProcessErrSig 13838
#define kNtErrorIpsecIkeProcessErrNonce 13839
#define kNtErrorIpsecIkeProcessErrNotify 13840
#define kNtErrorIpsecIkeProcessErrDelete 13841
#define kNtErrorIpsecIkeProcessErrVendor 13842
#define kNtErrorIpsecIkeInvalidPayload 13843
#define kNtErrorIpsecIkeLoadSoftSa 13844
#define kNtErrorIpsecIkeSoftSaTornDown 13845
#define kNtErrorIpsecIkeInvalidCookie 13846
#define kNtErrorIpsecIkeNoPeerCert 13847
#define kNtErrorIpsecIkePeerCrlFailed 13848
#define kNtErrorIpsecIkePolicyChange 13849
#define kNtErrorIpsecIkeNoMmPolicy 13850
#define kNtErrorIpsecIkeNotcbpriv 13851
#define kNtErrorIpsecIkeSecloadfail 13852
#define kNtErrorIpsecIkeFailsspinit 13853
#define kNtErrorIpsecIkeFailqueryssp 13854
#define kNtErrorIpsecIkeSrvacqfail 13855
#define kNtErrorIpsecIkeSrvquerycred 13856
#define kNtErrorIpsecIkeGetspifail 13857
#define kNtErrorIpsecIkeInvalidFilter 13858
#define kNtErrorIpsecIkeOutOfMemory 13859
#define kNtErrorIpsecIkeAddUpdateKeyFailed 13860
#define kNtErrorIpsecIkeInvalidPolicy 13861
#define kNtErrorIpsecIkeUnknownDoi 13862
#define kNtErrorIpsecIkeInvalidSituation 13863
#define kNtErrorIpsecIkeDhFailure 13864
#define kNtErrorIpsecIkeInvalidGroup 13865
#define kNtErrorIpsecIkeEncrypt 13866
#define kNtErrorIpsecIkeDecrypt 13867
#define kNtErrorIpsecIkePolicyMatch 13868
#define kNtErrorIpsecIkeUnsupportedId 13869
#define kNtErrorIpsecIkeInvalidHash 13870
#define kNtErrorIpsecIkeInvalidHashAlg 13871
#define kNtErrorIpsecIkeInvalidHashSize 13872
#define kNtErrorIpsecIkeInvalidEncryptAlg 13873
#define kNtErrorIpsecIkeInvalidAuthAlg 13874
#define kNtErrorIpsecIkeInvalidSig 13875
#define kNtErrorIpsecIkeLoadFailed 13876
#define kNtErrorIpsecIkeRpcDelete 13877
#define kNtErrorIpsecIkeBenignReinit 13878
#define kNtErrorIpsecIkeInvalidResponderLifetimeNotify 13879
#define kNtErrorIpsecIkeInvalidMajorVersion 13880
#define kNtErrorIpsecIkeInvalidCertKeylen 13881
#define kNtErrorIpsecIkeMmLimit 13882
#define kNtErrorIpsecIkeNegotiationDisabled 13883
#define kNtErrorIpsecIkeQmLimit 13884
#define kNtErrorIpsecIkeMmExpired 13885
#define kNtErrorIpsecIkePeerMmAssumedInvalid 13886
#define kNtErrorIpsecIkeCertChainPolicyMismatch 13887
#define kNtErrorIpsecIkeUnexpectedMessageId 13888
#define kNtErrorIpsecIkeInvalidAuthPayload 13889
#define kNtErrorIpsecIkeDosCookieSent 13890
#define kNtErrorIpsecIkeShuttingDown 13891
#define kNtErrorIpsecIkeCgaAuthFailed 13892
#define kNtErrorIpsecIkeProcessErrNatoa 13893
#define kNtErrorIpsecIkeInvalidMmForQm 13894
#define kNtErrorIpsecIkeQmExpired 13895
#define kNtErrorIpsecIkeTooManyFilters 13896
#define kNtErrorIpsecIkeNegStatusEnd 13897
#define kNtErrorIpsecIkeKillDummyNapTunnel 13898
#define kNtErrorIpsecIkeInnerIpAssignmentFailure 13899
#define kNtErrorIpsecIkeRequireCpPayloadMissing 13900
#define kNtErrorIpsecKeyModuleImpersonationNegotiationPending 13901
#define kNtErrorIpsecIkeCoexistenceSuppress 13902
#define kNtErrorIpsecIkeRatelimitDrop 13903
#define kNtErrorIpsecIkePeerDoesntSupportMobike 13904
#define kNtErrorIpsecIkeAuthorizationFailure 13905
#define kNtErrorIpsecIkeStrongCredAuthorizationFailure 13906
#define kNtErrorIpsecIkeAuthorizationFailureWithOptionalRetry 13907
#define kNtErrorIpsecIkeStrongCredAuthorizationAndCertmapFailure 13908
#define kNtErrorIpsecIkeNegStatusExtendedEnd 13909
#define kNtErrorIpsecBadSpi 13910
#define kNtErrorIpsecSaLifetimeExpired 13911
#define kNtErrorIpsecWrongSa 13912
#define kNtErrorIpsecReplayCheckFailed 13913
#define kNtErrorIpsecInvalidPacket 13914
#define kNtErrorIpsecIntegrityCheckFailed 13915
#define kNtErrorIpsecClearTextDrop 13916
#define kNtErrorIpsecAuthFirewallDrop 13917
#define kNtErrorIpsecThrottleDrop 13918
#define kNtErrorIpsecDospBlock 13925
#define kNtErrorIpsecDospReceivedMulticast 13926
#define kNtErrorIpsecDospInvalidPacket 13927
#define kNtErrorIpsecDospStateLookupFailed 13928
#define kNtErrorIpsecDospMaxEntries 13929
#define kNtErrorIpsecDospKeymodNotAllowed 13930
#define kNtErrorIpsecDospNotInstalled 13931
#define kNtErrorIpsecDospMaxPerIpRatelimitQueues 13932
#define kNtErrorSxsSectionNotFound 14000
#define kNtErrorSxsCantGenActctx 14001
#define kNtErrorSxsInvalidActctxdataFormat 14002
#define kNtErrorSxsAssemblyNotFound 14003
#define kNtErrorSxsManifestFormatError 14004
#define kNtErrorSxsManifestParseError 14005
#define kNtErrorSxsActivationContextDisabled 14006
#define kNtErrorSxsKeyNotFound 14007
#define kNtErrorSxsVersionConflict 14008
#define kNtErrorSxsWrongSectionType 14009
#define kNtErrorSxsThreadQueriesDisabled 14010
#define kNtErrorSxsProcessDefaultAlreadySet 14011
#define kNtErrorSxsUnknownEncodingGroup 14012
#define kNtErrorSxsUnknownEncoding 14013
#define kNtErrorSxsInvalidXmlNamespaceUri 14014
#define kNtErrorSxsRootManifestDependencyNotInstalled 14015
#define kNtErrorSxsLeafManifestDependencyNotInstalled 14016
#define kNtErrorSxsInvalidAssemblyIdentityAttribute 14017
#define kNtErrorSxsManifestMissingRequiredDefaultNamespace 14018
#define kNtErrorSxsManifestInvalidRequiredDefaultNamespace 14019
#define kNtErrorSxsPrivateManifestCrossPathWithReparsePoint 14020
#define kNtErrorSxsDuplicateDllName 14021
#define kNtErrorSxsDuplicateWindowclassName 14022
#define kNtErrorSxsDuplicateClsid 14023
#define kNtErrorSxsDuplicateIid 14024
#define kNtErrorSxsDuplicateTlbid 14025
#define kNtErrorSxsDuplicateProgid 14026
#define kNtErrorSxsDuplicateAssemblyName 14027
#define kNtErrorSxsFileHashMismatch 14028
#define kNtErrorSxsPolicyParseError 14029
#define kNtErrorSxsXmlEMissingquote 14030
#define kNtErrorSxsXmlECommentsyntax 14031
#define kNtErrorSxsXmlEBadstartnamechar 14032
#define kNtErrorSxsXmlEBadnamechar 14033
#define kNtErrorSxsXmlEBadcharinstring 14034
#define kNtErrorSxsXmlEXmldeclsyntax 14035
#define kNtErrorSxsXmlEBadchardata 14036
#define kNtErrorSxsXmlEMissingwhitespace 14037
#define kNtErrorSxsXmlEExpectingtagend 14038
#define kNtErrorSxsXmlEMissingsemicolon 14039
#define kNtErrorSxsXmlEUnbalancedparen 14040
#define kNtErrorSxsXmlEInternalerror 14041
#define kNtErrorSxsXmlEUnexpectedWhitespace 14042
#define kNtErrorSxsXmlEIncompleteEncoding 14043
#define kNtErrorSxsXmlEMissingParen 14044
#define kNtErrorSxsXmlEExpectingclosequote 14045
#define kNtErrorSxsXmlEMultipleColons 14046
#define kNtErrorSxsXmlEInvalidDecimal 14047
#define kNtErrorSxsXmlEInvalidHexidecimal 14048
#define kNtErrorSxsXmlEInvalidUnicode 14049
#define kNtErrorSxsXmlEWhitespaceorquestionmark 14050
#define kNtErrorSxsXmlEUnexpectedendtag 14051
#define kNtErrorSxsXmlEUnclosedtag 14052
#define kNtErrorSxsXmlEDuplicateattribute 14053
#define kNtErrorSxsXmlEMultipleroots 14054
#define kNtErrorSxsXmlEInvalidatrootlevel 14055
#define kNtErrorSxsXmlEBadxmldecl 14056
#define kNtErrorSxsXmlEMissingroot 14057
#define kNtErrorSxsXmlEUnexpectedeof 14058
#define kNtErrorSxsXmlEBadperefinsubset 14059
#define kNtErrorSxsXmlEUnclosedstarttag 14060
#define kNtErrorSxsXmlEUnclosedendtag 14061
#define kNtErrorSxsXmlEUnclosedstring 14062
#define kNtErrorSxsXmlEUnclosedcomment 14063
#define kNtErrorSxsXmlEUncloseddecl 14064
#define kNtErrorSxsXmlEUnclosedcdata 14065
#define kNtErrorSxsXmlEReservednamespace 14066
#define kNtErrorSxsXmlEInvalidencoding 14067
#define kNtErrorSxsXmlEInvalidswitch 14068
#define kNtErrorSxsXmlEBadxmlcase 14069
#define kNtErrorSxsXmlEInvalidStandalone 14070
#define kNtErrorSxsXmlEUnexpectedStandalone 14071
#define kNtErrorSxsXmlEInvalidVersion 14072
#define kNtErrorSxsXmlEMissingequals 14073
#define kNtErrorSxsProtectionRecoveryFailed 14074
#define kNtErrorSxsProtectionPublicKeyTooShort 14075
#define kNtErrorSxsProtectionCatalogNotValid 14076
#define kNtErrorSxsUntranslatableHresult 14077
#define kNtErrorSxsProtectionCatalogFileMissing 14078
#define kNtErrorSxsMissingAssemblyIdentityAttribute 14079
#define kNtErrorSxsInvalidAssemblyIdentityAttributeName 14080
#define kNtErrorSxsAssemblyMissing 14081
#define kNtErrorSxsCorruptActivationStack 14082
#define kNtErrorSxsCorruption 14083
#define kNtErrorSxsEarlyDeactivation 14084
#define kNtErrorSxsInvalidDeactivation 14085
#define kNtErrorSxsMultipleDeactivation 14086
#define kNtErrorSxsProcessTerminationRequested 14087
#define kNtErrorSxsReleaseActivationContext 14088
#define kNtErrorSxsSystemDefaultActivationContextEmpty 14089
#define kNtErrorSxsInvalidIdentityAttributeValue 14090
#define kNtErrorSxsInvalidIdentityAttributeName 14091
#define kNtErrorSxsIdentityDuplicateAttribute 14092
#define kNtErrorSxsIdentityParseError 14093
#define kNtErrorMalformedSubstitutionString 14094
#define kNtErrorSxsIncorrectPublicKeyToken 14095
#define kNtErrorUnmappedSubstitutionString 14096
#define kNtErrorSxsAssemblyNotLocked 14097
#define kNtErrorSxsComponentStoreCorrupt 14098
#define kNtErrorAdvancedInstallerFailed 14099
#define kNtErrorXmlEncodingMismatch 14100
#define kNtErrorSxsManifestIdentitySameButContentsDifferent 14101
#define kNtErrorSxsIdentitiesDifferent 14102
#define kNtErrorSxsAssemblyIsNotADeployment 14103
#define kNtErrorSxsFileNotPartOfAssembly 14104
#define kNtErrorSxsManifestTooBig 14105
#define kNtErrorSxsSettingNotRegistered 14106
#define kNtErrorSxsTransactionClosureIncomplete 14107
#define kNtErrorSmiPrimitiveInstallerFailed 14108
#define kNtErrorGenericCommandFailed 14109
#define kNtErrorSxsFileHashMissing 14110
#define kNtErrorEvtInvalidChannelPath 15000
#define kNtErrorEvtInvalidQuery 15001
#define kNtErrorEvtPublisherMetadataNotFound 15002
#define kNtErrorEvtEventTemplateNotFound 15003
#define kNtErrorEvtInvalidPublisherName 15004
#define kNtErrorEvtInvalidEventData 15005
#define kNtErrorEvtChannelNotFound 15007
#define kNtErrorEvtMalformedXmlText 15008
#define kNtErrorEvtSubscriptionToDirectChannel 15009
#define kNtErrorEvtConfigurationError 15010
#define kNtErrorEvtQueryResultStale 15011
#define kNtErrorEvtQueryResultInvalidPosition 15012
#define kNtErrorEvtNonValidatingMsxml 15013
#define kNtErrorEvtFilterAlreadyscoped 15014
#define kNtErrorEvtFilterNoteltset 15015
#define kNtErrorEvtFilterInvarg 15016
#define kNtErrorEvtFilterInvtest 15017
#define kNtErrorEvtFilterInvtype 15018
#define kNtErrorEvtFilterParseerr 15019
#define kNtErrorEvtFilterUnsupportedop 15020
#define kNtErrorEvtFilterUnexpectedtoken 15021
#define kNtErrorEvtInvalidOperationOverEnabledDirectChannel 15022
#define kNtErrorEvtInvalidChannelPropertyValue 15023
#define kNtErrorEvtInvalidPublisherPropertyValue 15024
#define kNtErrorEvtChannelCannotActivate 15025
#define kNtErrorEvtFilterTooComplex 15026
#define kNtErrorEvtMessageNotFound 15027
#define kNtErrorEvtMessageIdNotFound 15028
#define kNtErrorEvtUnresolvedValueInsert 15029
#define kNtErrorEvtUnresolvedParameterInsert 15030
#define kNtErrorEvtMaxInsertsReached 15031
#define kNtErrorEvtEventDefinitionNotFound 15032
#define kNtErrorEvtMessageLocaleNotFound 15033
#define kNtErrorEvtVersionTooOld 15034
#define kNtErrorEvtVersionTooNew 15035
#define kNtErrorEvtCannotOpenChannelOfQuery 15036
#define kNtErrorEvtPublisherDisabled 15037
#define kNtErrorEvtFilterOutOfRange 15038
#define kNtErrorEcSubscriptionCannotActivate 15080
#define kNtErrorEcLogDisabled 15081
#define kNtErrorEcCircularForwarding 15082
#define kNtErrorEcCredstoreFull 15083
#define kNtErrorEcCredNotFound 15084
#define kNtErrorEcNoActiveChannel 15085
#define kNtErrorMuiFileNotFound 15100
#define kNtErrorMuiInvalidFile 15101
#define kNtErrorMuiInvalidRcConfig 15102
#define kNtErrorMuiInvalidLocaleName 15103
#define kNtErrorMuiInvalidUltimatefallbackName 15104
#define kNtErrorMuiFileNotLoaded 15105
#define kNtErrorResourceEnumUserStop 15106
#define kNtErrorMuiIntlsettingsUilangNotInstalled 15107
#define kNtErrorMuiIntlsettingsInvalidLocaleName 15108
#define kNtErrorMrmRuntimeNoDefaultOrNeutralResource 15110
#define kNtErrorMrmInvalidPriconfig 15111
#define kNtErrorMrmInvalidFileType 15112
#define kNtErrorMrmUnknownQualifier 15113
#define kNtErrorMrmInvalidQualifierValue 15114
#define kNtErrorMrmNoCandidate 15115
#define kNtErrorMrmNoMatchOrDefaultCandidate 15116
#define kNtErrorMrmResourceTypeMismatch 15117
#define kNtErrorMrmDuplicateMapName 15118
#define kNtErrorMrmDuplicateEntry 15119
#define kNtErrorMrmInvalidResourceIdentifier 15120
#define kNtErrorMrmFilepathTooLong 15121
#define kNtErrorMrmUnsupportedDirectoryType 15122
#define kNtErrorMrmInvalidPriFile 15126
#define kNtErrorMrmNamedResourceNotFound 15127
#define kNtErrorMrmMapNotFound 15135
#define kNtErrorMrmUnsupportedProfileType 15136
#define kNtErrorMrmInvalidQualifierOperator 15137
#define kNtErrorMrmIndeterminateQualifierValue 15138
#define kNtErrorMrmAutomergeEnabled 15139
#define kNtErrorMrmTooManyResources 15140
#define kNtErrorMrmUnsupportedFileTypeForMerge 15141
#define kNtErrorMrmUnsupportedFileTypeForLoadUnloadPriFile 15142
#define kNtErrorMrmNoCurrentViewOnThread 15143
#define kNtErrorDifferentProfileResourceManagerExist 15144
#define kNtErrorOperationNotAllowedFromSystemComponent 15145
#define kNtErrorMrmDirectRefToNonDefaultResource 15146
#define kNtErrorMrmGenerationCountMismatch 15147
#define kNtErrorPriMergeVersionMismatch 15148
#define kNtErrorPriMergeMissingSchema 15149
#define kNtErrorPriMergeLoadFileFailed 15150
#define kNtErrorPriMergeAddFileFailed 15151
#define kNtErrorPriMergeWriteFileFailed 15152
#define kNtErrorPriMergeMultiplePackageFamiliesNotAllowed 15153
#define kNtErrorPriMergeMultipleMainPackagesNotAllowed 15154
#define kNtErrorPriMergeBundlePackagesNotAllowed 15155
#define kNtErrorPriMergeMainPackageRequired 15156
#define kNtErrorPriMergeResourcePackageRequired 15157
#define kNtErrorPriMergeInvalidFileName 15158
#define kNtErrorMcaInvalidCapabilitiesString 15200
#define kNtErrorMcaInvalidVcpVersion 15201
#define kNtErrorMcaMonitorViolatesMccsSpecification 15202
#define kNtErrorMcaMccsVersionMismatch 15203
#define kNtErrorMcaUnsupportedMccsVersion 15204
#define kNtErrorMcaInternalError 15205
#define kNtErrorMcaInvalidTechnologyTypeReturned 15206
#define kNtErrorMcaUnsupportedColorTemperature 15207
#define kNtErrorAmbiguousSystemDevice 15250
#define kNtErrorSystemDeviceNotFound 15299
#define kNtErrorHashNotSupported 15300
#define kNtErrorHashNotPresent 15301
#define kNtErrorSecondaryIcProviderNotRegistered 15321
#define kNtErrorGpioClientInformationInvalid 15322
#define kNtErrorGpioVersionNotSupported 15323
#define kNtErrorGpioInvalidRegistrationPacket 15324
#define kNtErrorGpioOperationDenied 15325
#define kNtErrorGpioIncompatibleConnectMode 15326
#define kNtErrorGpioInterruptAlreadyUnmasked 15327
#define kNtErrorCannotSwitchRunlevel 15400
#define kNtErrorInvalidRunlevelSetting 15401
#define kNtErrorRunlevelSwitchTimeout 15402
#define kNtErrorRunlevelSwitchAgentTimeout 15403
#define kNtErrorRunlevelSwitchInProgress 15404
#define kNtErrorServicesFailedAutostart 15405
#define kNtErrorComTaskStopPending 15501
#define kNtErrorInstallOpenPackageFailed 15600
#define kNtErrorInstallPackageNotFound 15601
#define kNtErrorInstallInvalidPackage 15602
#define kNtErrorInstallResolveDependencyFailed 15603
#define kNtErrorInstallOutOfDiskSpace 15604
#define kNtErrorInstallNetworkFailure 15605
#define kNtErrorInstallRegistrationFailure 15606
#define kNtErrorInstallDeregistrationFailure 15607
#define kNtErrorInstallCancel 15608
#define kNtErrorInstallFailed 15609
#define kNtErrorRemoveFailed 15610
#define kNtErrorPackageAlreadyExists 15611
#define kNtErrorNeedsRemediation 15612
#define kNtErrorInstallPrerequisiteFailed 15613
#define kNtErrorPackageRepositoryCorrupted 15614
#define kNtErrorInstallPolicyFailure 15615
#define kNtErrorPackageUpdating 15616
#define kNtErrorDeploymentBlockedByPolicy 15617
#define kNtErrorPackagesInUse 15618
#define kNtErrorRecoveryFileCorrupt 15619
#define kNtErrorInvalidStagedSignature 15620
#define kNtErrorDeletingExistingApplicationdataStoreFailed 15621
#define kNtErrorInstallPackageDowngrade 15622
#define kNtErrorSystemNeedsRemediation 15623
#define kNtErrorAppxIntegrityFailureClrNgen 15624
#define kNtErrorResiliencyFileCorrupt 15625
#define kNtErrorInstallFirewallServiceNotRunning 15626
#define kNtErrorPackageMoveFailed 15627
#define kNtErrorInstallVolumeNotEmpty 15628
#define kNtErrorInstallVolumeOffline 15629
#define kNtErrorInstallVolumeCorrupt 15630
#define kNtErrorNeedsRegistration 15631
#define kNtErrorInstallWrongProcessorArchitecture 15632
#define kNtErrorDevSideloadLimitExceeded 15633
#define kNtErrorInstallOptionalPackageRequiresMainPackage 15634
#define kNtErrorPackageNotSupportedOnFilesystem 15635
#define kNtErrorPackageMoveBlockedByStreaming 15636
#define kNtErrorInstallOptionalPackageApplicationidNotUnique 15637
#define kNtErrorPackageStagingOnhold 15638
#define kNtErrorInstallInvalidRelatedSetUpdate 15639
#define kNtErrorPackagesReputationCheckFailed 15643
#define kNtErrorPackagesReputationCheckTimedout 15644
#define kNtErrorStateLoadStoreFailed 15800
#define kNtErrorStateGetVersionFailed 15801
#define kNtErrorStateSetVersionFailed 15802
#define kNtErrorStateStructuredResetFailed 15803
#define kNtErrorStateOpenContainerFailed 15804
#define kNtErrorStateCreateContainerFailed 15805
#define kNtErrorStateDeleteContainerFailed 15806
#define kNtErrorStateReadSettingFailed 15807
#define kNtErrorStateWriteSettingFailed 15808
#define kNtErrorStateDeleteSettingFailed 15809
#define kNtErrorStateQuerySettingFailed 15810
#define kNtErrorStateReadCompositeSettingFailed 15811
#define kNtErrorStateWriteCompositeSettingFailed 15812
#define kNtErrorStateEnumerateContainerFailed 15813
#define kNtErrorStateEnumerateSettingsFailed 15814
#define kNtErrorStateCompositeSettingValueSizeLimitExceeded 15815
#define kNtErrorStateSettingValueSizeLimitExceeded 15816
#define kNtErrorStateSettingNameSizeLimitExceeded 15817
#define kNtErrorStateContainerNameSizeLimitExceeded 15818
#define kNtErrorApiUnavailable 15841

#define kNtWaitIoCompletion 0xc0

/* WinSock Error Codes: 10000-11999 */
#define WSABASEERR 10000
#define WSAEINTR 10004
#define WSAEBADF 10009
#define WSAEACCES 10013
#define WSAEFAULT 10014
#define WSAEINVAL 10022
#define WSAEMFILE 10024
#define WSAEWOULDBLOCK 10035
#define WSAEINPROGRESS 10036
#define WSAEALREADY 10037
#define WSAENOTSOCK 10038
#define WSAEDESTADDRREQ 10039
#define WSAEMSGSIZE 10040
#define WSAEPROTOTYPE 10041
#define WSAENOPROTOOPT 10042
#define WSAEPROTONOSUPPORT 10043
#define WSAESOCKTNOSUPPORT 10044
#define WSAEOPNOTSUPP 10045
#define WSAEPFNOSUPPORT 10046
#define WSAEAFNOSUPPORT 10047
#define WSAEADDRINUSE 10048
#define WSAEADDRNOTAVAIL 10049
#define WSAENETDOWN 10050
#define WSAENETUNREACH 10051
#define WSAENETRESET 10052
#define WSAECONNABORTED 10053
#define WSAECONNRESET 10054
#define WSAENOBUFS 10055
#define WSAEISCONN 10056
#define WSAENOTCONN 10057
#define WSAESHUTDOWN 10058
#define WSAETOOMANYREFS 10059
#define WSAETIMEDOUT 10060
#define WSAECONNREFUSED 10061
#define WSAELOOP 10062
#define WSAENAMETOOLONG 10063
#define WSAEHOSTDOWN 10064
#define WSAEHOSTUNREACH 10065
#define WSAENOTEMPTY 10066
#define WSAEPROCLIM 10067
#define WSAEUSERS 10068
#define WSAEDQUOT 10069
#define WSAESTALE 10070
#define WSAEREMOTE 10071
#define WSASYSNOTREADY 10091
#define WSAVERNOTSUPPORTED 10092
#define WSANOTINITIALISED 10093
#define WSAEDISCON 10101
#define WSAENOMORE 10102
#define WSAECANCELLED 10103
#define WSAEINVALIDPROCTABLE 10104
#define WSAEINVALIDPROVIDER 10105
#define WSAEPROVIDERFAILEDINIT 10106
#define WSASYSCALLFAILURE 10107
#define WSASERVICE_NOT_FOUND 10108
#define WSATYPE_NOT_FOUND 10109
#define WSA_E_NO_MORE 10110
#define WSA_E_CANCELLED 10111
#define WSAEREFUSED 10112
#define WSAHOST_NOT_FOUND 11001
#define WSATRY_AGAIN 11002
#define WSANO_RECOVERY 11003
#define WSANO_DATA 11004
#define WSA_QOS_RECEIVERS 11005
#define WSA_QOS_SENDERS 11006
#define WSA_QOS_NO_SENDERS 11007
#define WSA_QOS_NO_RECEIVERS 11008
#define WSA_QOS_REQUEST_CONFIRMED 11009
#define WSA_QOS_ADMISSION_FAILURE 11010
#define WSA_QOS_POLICY_FAILURE 11011
#define WSA_QOS_BAD_STYLE 11012
#define WSA_QOS_BAD_OBJECT 11013
#define WSA_QOS_TRAFFIC_CTRL_ERROR 11014
#define WSA_QOS_GENERIC_ERROR 11015
#define WSA_QOS_ESERVICETYPE 11016
#define WSA_QOS_EFLOWSPEC 11017
#define WSA_QOS_EPROVSPECBUF 11018
#define WSA_QOS_EFILTERSTYLE 11019
#define WSA_QOS_EFILTERTYPE 11020
#define WSA_QOS_EFILTERCOUNT 11021
#define WSA_QOS_EOBJLENGTH 11022
#define WSA_QOS_EFLOWCOUNT 11023
#define WSA_QOS_EUNKOWNPSOBJ 11024
#define WSA_QOS_EPOLICYOBJ 11025
#define WSA_QOS_EFLOWDESC 11026
#define WSA_QOS_EPSFLOWSPEC 11027
#define WSA_QOS_EPSFILTERSPEC 11028
#define WSA_QOS_ESDMODEOBJ 11029
#define WSA_QOS_ESHAPERATEOBJ 11030
#define WSA_QOS_RESERVED_PETYPE 11031
#define WSA_SECURE_HOST_NOT_FOUND 11032
#define WSA_IPSEC_NAME_POLICY_ERROR 11033

#define WSA_WAIT_FAILED -1u
#define WSA_WAIT_EVENT_0 0
#define WSA_WAIT_IO_COMPLETION 0xc0
#define WSA_WAIT_TIMEOUT 258
#define WSA_MAXIMUM_WAIT_EVENTS 64
#define WSA_IO_PENDING 997



/*!BEGIN libc/nt/events.h */

#define COSMOPOLITAN_LIBC_NT_EVENTS_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » events                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int32_t GetMessage(struct NtMsg *lpMsg, int64_t hWnd, uint32_t wMsgFilterMin,
                   uint32_t wMsgFilterMax);
int32_t TranslateMessage(const struct NtMsg *lpMsg);
intptr_t DispatchMessage(const struct NtMsg *lpMsg);
void PostQuitMessage(int nExitCode);
bool32 GetCursorPos(struct NtPoint *lpPoint);
int64_t SendMessage(int64_t hWnd, uint32_t Msg, uint64_t wParam,
                    int64_t lParam);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/files.h */

#define COSMOPOLITAN_LIBC_NT_FILES_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » files                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtHandleFlagInherit          1 /* SetHandleInformation */
#define kNtHandleFlagProtectFromClose 2

#define kNtFindFirstExCaseSensitive 1
#define kNtFindFirstExLargeFetch    2

#define kNtDuplicateCloseSource 1
#define kNtDuplicateSameAccess  2

#define kNtSymbolicLinkFlagDirectory 1

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

intptr_t LoadResource(int64_t hModule, int64_t hResInfo);
uint32_t SetHandleCount(uint32_t uNumber);
uint32_t GetLogicalDrives(void);
bool32 FlushFileBuffers(int64_t hFile);

int64_t ReOpenFile(int64_t hOriginalFile, uint32_t dwDesiredAccess,
                   uint32_t dwShareMode, uint32_t dwFlagsAndAttributes);

bool32 DeleteFile(const char16_t *lpFileName) paramsnonnull();

bool32 CopyFile(const char16_t *lpExistingFileName,
                const char16_t *lpNewFileName, bool32 bFailIfExists)
    paramsnonnull();

bool32 MoveFile(const char16_t *lpExistingFileName,
                const char16_t *lpNewFileName) paramsnonnull();
bool32 MoveFileEx(const char16_t *lpExistingFileName,
                  const char16_t *lpNewFileName, int dwFlags) paramsnonnull();

bool32 SetCurrentDirectory(const char16_t *lpPathName);
uint32_t GetCurrentDirectory(uint32_t nBufferLength, char16_t *out_lpBuffer);

bool32 CreateDirectory(const char16_t *lpPathName,
                       struct NtSecurityAttributes *lpSecurityAttributes);
bool32 RemoveDirectory(const char16_t *lpPathName);

bool32 DuplicateHandle(int64_t hSourceProcessHandle, int64_t hSourceHandle,
                       int64_t hTargetProcessHandle, int64_t *lpTargetHandle,
                       uint32_t dwDesiredAccess, bool32 bInheritHandle,
                       uint32_t dwOptions);

bool32 GetHandleInformation(int64_t hObject, uint32_t *out_lpdwFlags);
bool32 SetHandleInformation(int64_t hObject, uint32_t dwMask, uint32_t dwFlags);
int GetFileType(int64_t hFile);

bool32 GetFileInformationByHandleEx(int64_t hFile,
                                    uint32_t FileInformationClass,
                                    void *out_lpFileInformation,
                                    uint32_t dwBufferSize);

bool32 GetFileInformationByHandle(
    int64_t hFile, struct NtByHandleFileInformation *lpFileInformation);

uint32_t GetFileAttributes(const char16_t *lpFileName);
bool32 GetFileAttributesEx(
    const char16_t *lpFileName, int fInfoLevelId /* kNtGetFileExInfoStandard */,
    void *out_lpFileInformation /* → struct NtWin32FileAttributeData * */)
    paramsnonnull();

uint32_t GetCompressedFileSize(const char16_t *lpFileName,
                               uint32_t *lpFileSizeHigh);
bool32 SetFileAttributes(const char16_t *lpFileName, uint32_t dwFileAttributes);
bool32 GetFileTime(int64_t hFile, struct NtFileTime *opt_lpCreationFileTime,
                   struct NtFileTime *opt_lpLastAccessFileTime,
                   struct NtFileTime *opt_lpLastWriteFileTime);
bool32 SetFileTime(int64_t hFile,
                   const struct NtFileTime *opt_lpCreationFileTime,
                   const struct NtFileTime *opt_lpLastAccessFileTime,
                   const struct NtFileTime *opt_lpLastWriteFileTime);

bool32 DeviceIoControl(int64_t hDevice, uint32_t dwIoControlCode,
                       void *lpInBuffer, uint32_t nInBufferSize,
                       void *lpOutBuffer, uint32_t nOutBufferSize,
                       uint32_t *lpBytesReturned,
                       struct NtOverlapped *lpOverlapped);

bool32 LockFile(int64_t hFile, uint32_t dwFileOffsetLow,
                uint32_t dwFileOffsetHigh, uint32_t nNumberOfBytesToLockLow,
                uint32_t nNumberOfBytesToLockHigh);
bool32 LockFileEx(int64_t hFile, uint32_t dwFlags, uint32_t dwReserved,
                  uint32_t nNumberOfBytesToLockLow,
                  uint32_t nNumberOfBytesToLockHigh,
                  struct NtOverlapped *lpOverlapped) paramsnonnull();
bool32 UnlockFile(int64_t hFile, uint32_t dwFileOffsetLow,
                  uint32_t dwFileOffsetHigh, uint32_t nNumberOfBytesToUnlockLow,
                  uint32_t nNumberOfBytesToUnlockHigh);
bool32 UnlockFileEx(int64_t hFile, uint32_t dwReserved,
                    uint32_t nNumberOfBytesToUnlockLow,
                    uint32_t nNumberOfBytesToUnlockHigh,
                    struct NtOverlapped *lpOverlapped) paramsnonnull();

bool32 CreateHardLink(const char16_t *lpFileName,
                      const char16_t *lpExistingFileName,
                      struct NtSecurityAttributes *reserved)
    paramsnonnull((1, 2));
bool32 CreateSymbolicLink(const char16_t *lpSymlinkFileName,
                          const char16_t *lpTargetPathName, uint32_t dwFlags)
    paramsnonnull();

uint32_t SetFilePointer(int64_t hFile, int32_t lDistanceToMove,
                        int32_t *optional_lpDistanceToMoveHigh,
                        int dwMoveMethod);
bool32 SetFilePointerEx(int64_t hFile, int64_t liDistanceToMove,
                        int64_t *optional_lpNewFilePointer, int dwMoveMethod);

bool32 SetEndOfFile(int64_t hFile);
bool32 SetFileValidData(int64_t hFile, int64_t ValidDataLength);

bool32 GetFileSecurity(const char16_t *lpFileName,
                       uint32_t RequestedInformation,
                       struct NtSecurityDescriptor *pSecurityDescriptor,
                       uint32_t nLength, uint32_t *lpnLengthNeeded);

bool32 OpenProcessToken(int64_t hProcessHandle, uint32_t dwDesiredAccess,
                        int64_t *out_hTokenHandle);
bool32 DuplicateToken(int64_t hExistingTokenHandle, int dwImpersonationLevel,
                      int64_t *out_hDuplicateTokenHandle);
bool32 DuplicateTokenEx(int64_t hExistingToken, unsigned int dwDesiredAccess,
                        struct NtSecurityAttributes *lpTokenAttributes,
                        int ImpersonationLevel, int TokenType,
                        int64_t *out_phNewToken);

bool32 AccessCheck(struct NtSecurityDescriptor *pSecurityDescriptor,
                   int64_t ClientToken, unsigned int DesiredAccess,
                   struct NtGenericMapping *lpGenericMapping,
                   struct NtPrivilegeSet *lpPrivilegeSet,
                   unsigned int *PrivilegeSetLength,
                   unsigned int *GrantedAccess, bool32 *AccessStatus);

void MapGenericMask(uint32_t *AccessMask,
                    struct NtGenericMapping *GenericMapping);

int64_t FindFirstFile(const char16_t *lpFileName,
                      struct NtWin32FindData *out_lpFindFileData);
int64_t FindFirstFileEx(const char16_t *lpFileName, int fInfoLevelId,
                        void *out_lpFindFileData, int fSearchOp,
                        void *reserved_lpSearchFilter,
                        uint32_t dwAdditionalFlags);
bool32 FindNextFile(int64_t hFindFile,
                    struct NtWin32FindData *out_lpFindFileData);
bool32 FindClose(int64_t inout_hFindFile);

int64_t FindFirstVolume(char16_t *out_lpszVolumeName, uint32_t cchBufferLength);
bool32 FindNextVolume(int64_t inout_hFindVolume, char16_t *out_lpszVolumeName,
                      uint32_t cchBufferLength);
bool32 FindVolumeClose(int64_t hFindVolume);

bool32 ReadFileScatter(
    int64_t hFileOpenedWithOverlappedAndNoBuffering,
    const union NtFileSegmentElement
        aNullTerminatedPageAlignedSizedSegmentArray[],
    uint32_t nNumberOfBytesToReadThatsMultipleOfFileVolumeSectorSize,
    uint32_t *lpReserved, struct NtOverlapped *inout_lpOverlapped)
    paramsnonnull();

bool32 WriteFileGather(int64_t hFileOpenedWithOverlappedAndNoBuffering,
                       const union NtFileSegmentElement aSegmentArray[],
                       uint32_t nNumberOfBytesToWrite, uint32_t *lpReserved,
                       struct NtOverlapped inout_lpOverlapped) paramsnonnull();

#define kNtFileNameNormalized 0x0
#define kNtFileNameOpened     0x8
#define kNtVolumeNameDos      0x0 /* e.g. \\?\C:\Users\jart */
#define kNtVolumeNameGuid     0x1 /* e.g. \\?\Volume{ea38-etc.}\Users\jart */
#define kNtVolumeNameNt       0x2 /* e.g. \Device\HarddiskVolume4\Users\jart */
#define kNtVolumeNameNone     0x4 /* e.g. \Users\jart */
uint32_t GetFinalPathNameByHandle(int64_t hFile, char16_t *out_path,
                                  uint32_t arraylen, uint32_t flags);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/files.inc */

#define CopyFile(...) __imp_CopyFileW(__VA_ARGS__)
extern typeof(CopyFile) *const __imp_CopyFileW __msabi;

#define FlushFileBuffers(...) __imp_FlushFileBuffers(__VA_ARGS__)
extern typeof(FlushFileBuffers) *const __imp_FlushFileBuffers __msabi;

#define GetFileType(...) __imp_GetFileType(__VA_ARGS__)
extern typeof(GetFileType) *const __imp_GetFileType __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/iocp.h */

#define COSMOPOLITAN_LIBC_NT_IOCP_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » i/o completion ports                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtFileSkipCompletionPortOnSuccess 1
#define kNtFileSkipSetEventOnHandle        2

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef void (*NtOverlappedCompletionRoutine)(
    uint32_t dwErrorCode, uint32_t dwNumberOfBytesTransfered,
    struct NtOverlapped *inout_lpOverlapped);

int64_t CreateIoCompletionPort(int64_t FileHandleOrNeg1,
                               int64_t opt_ExistingCompletionPortOrZero,
                               void *StatePointer,
                               uint32_t NumberOfConcurrentThreads);

bool32 GetQueuedCompletionStatus(int64_t CompletionPort,
                                 uint32_t *lpNumberOfBytesTransferred,
                                 void *StatePointerPointer,
                                 struct NtOverlapped **lpOverlapped,
                                 uint32_t dwMilliseconds);

bool32 GetQueuedCompletionStatusEx(
    int64_t CompletionPort,
    struct NtOverlappedEntry *out_lpCompletionPortEntries, uint32_t ulCount,
    uint32_t *out_ulNumEntriesRemoved, uint32_t dwMilliseconds,
    bool32 fAlertable);

bool32 PostQueuedCompletionStatus(int64_t CompletionPort,
                                  uint32_t dwNumberOfBytesTransferred,
                                  uint32_t *dwCompletionKey,
                                  struct NtOverlapped *opt_lpOverlapped);

bool32 SetFileCompletionNotificationModes(int64_t FileHandle,
                                          unsigned char Flags);

bool32 ReadFileEx(int64_t hFile, void *lpBuffer, uint32_t nNumberOfBytesToRead,
                  uint32_t *lpNumberOfBytesRead,
                  struct NtOverlapped *opt_lpOverlapped,
                  NtOverlappedCompletionRoutine lpCompletionRoutine);

bool32 WriteFileEx(int64_t hFile, const void *lpBuffer,
                   uint32_t nNumberOfBytesToWrite,
                   struct NtOverlapped *lpOverlapped,
                   NtOverlappedCompletionRoutine lpCompletionRoutine);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/ipc.h */

#define COSMOPOLITAN_LIBC_NT_IPC_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » ipc                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

/* CreateNamedPipe:dwOpenMode */
#define kNtPipeAccessInbound  0x00000001
#define kNtPipeAccessOutbound 0x00000002
#define kNtPipeAccessDuplex   0x00000003

/* CreateNamedPipe::dwPipeMode */
#define kNtPipeWait                0x00000000
#define kNtPipeNowait              0x00000001
#define kNtPipeReadmodeByte        0x00000000
#define kNtPipeReadmodeMessage     0x00000002
#define kNtPipeTypeByte            0x00000000
#define kNtPipeTypeMessage         0x00000004
#define kNtPipeAcceptRemoteClients 0x00000000
#define kNtPipeRejectRemoteClients 0x00000008

/* CreateNamedPipe::nMaxInstances */
#define NT_PIPE_UNLIMITED_INSTANCES 255

/* CreateNamedPipeInfo */
#define PIPE_CLIENT_END 0x00000000
#define PIPE_SERVER_END 0x00000001

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 CreatePipe(int64_t *out_hReadPipe, int64_t *out_hWritePipe,
                  const struct NtSecurityAttributes *opt_lpPipeAttributes,
                  uint32_t nSize) paramsnonnull((1, 2));

int64_t CreateNamedPipe(
    const char16_t *lpName, uint32_t dwOpenMode, uint32_t dwPipeMode,
    uint32_t nMaxInstances, uint32_t nOutBufferSize, uint32_t nInBufferSize,
    uint32_t nDefaultTimeOut,
    const struct NtSecurityAttributes *opt_lpSecurityAttributes)
    paramsnonnull((1));

bool32 CallNamedPipe(const char16_t *lpNamedPipeName, void *lpInBuffer,
                     uint32_t nInBufferSize, void *lpOutBuffer,
                     uint32_t nOutBufferSize, uint32_t *lpBytesRead,
                     uint32_t nTimeOut);

bool32 ConnectNamedPipe(int64_t *hNamedPipe, struct NtOverlapped *lpOverlapped);
bool32 WaitNamedPipe(const char16_t *lpNamedPipeName, uint32_t nTimeOut);
bool32 DisconnectNamedPipe(int64_t *hNamedPipe);

bool32 SetNamedPipeHandleState(int64_t *hNamedPipe, uint32_t *lpMode,
                               uint32_t *lpMaxCollectionCount,
                               uint32_t *lpCollectDataTimeout);

bool32 PeekNamedPipe(int64_t *hNamedPipe, void *lpBuffer, uint32_t nBufferSize,
                     uint32_t *lpBytesRead, uint32_t *lpTotalBytesAvail,
                     uint32_t *lpBytesLeftThisMessage);

bool32 TransactNamedPipe(int64_t *hNamedPipe, void *lpInBuffer,
                         uint32_t nInBufferSize, void *lpOutBuffer,
                         uint32_t nOutBufferSize, uint32_t *lpBytesRead,
                         struct NtOverlapped *lpOverlapped);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/memory.h */

#define COSMOPOLITAN_LIBC_NT_MEMORY_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » memory                                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtNumaNoPreferredNode 0xffffffffu

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int64_t CreateFileMappingNuma(
    int64_t opt_hFile /* -1ul is MAP_ANONYMOUS */,
    const struct NtSecurityAttributes *opt_lpFileMappingAttributes,
    uint32_t flProtect, uint32_t dwMaximumSizeHigh, uint32_t dwMaximumSizeLow,
    const char16_t *opt_lpName, uint32_t nndDesiredNumaNode);

void *MapViewOfFileExNuma(
    int64_t hFileMappingObject, /* @see CreateFileMapping() */
    uint32_t dwDesiredAccess, uint32_t dwFileOffsetHigh, /* high order bits */
    uint32_t dwFileOffsetLow,                            /* low order bits */
    size_t dwNumberOfBytesToMap, void *opt_lpDesiredBaseAddress,
    uint32_t nndDesiredNumaNode);

bool32 UnmapViewOfFile(const void *lpBaseAddress);
bool32 FlushViewOfFile(const void *lpBaseAddress,
                       size_t dwNumberOfBytesToFlush);

void *VirtualAlloc(void *opt_lpAddress, uint64_t dwSize,
                   uint32_t flAllocationType, uint32_t flProtect);
bool32 VirtualFree(void *lpAddress, uint64_t dwSize, uint32_t dwFreeType);
bool32 VirtualProtect(void *lpAddress, uint64_t dwSize, uint32_t flNewProtect,
                      uint32_t *lpflOldProtect) paramsnonnull();
uint64_t VirtualQuery(const void *lpAddress,
                      struct NtMemoryBasicInformation *lpBuffer,
                      uint64_t dwLength);
void *VirtualAllocEx(int64_t hProcess, void *lpAddress, uint64_t dwSize,
                     uint32_t flAllocationType, uint32_t flProtect);

bool32 PrefetchVirtualMemory(int64_t hProcess, const uint32_t *NumberOfEntries,
                             struct NtMemoryRangeEntry *VirtualAddresses,
                             uint32_t reserved_Flags);
bool32 OfferVirtualMemory(void *inout_VirtualAddress, size_t Size,
                          int Priority);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/memory.inc */

#define CreateFileMappingNuma(...) __imp_CreateFileMappingNumaW(__VA_ARGS__)
#define MapViewOfFileExNuma(...)   __imp_MapViewOfFileExNuma(__VA_ARGS__)
#define FlushViewOfFile(...)       __imp_FlushViewOfFile(__VA_ARGS__)
#define UnmapViewOfFile(...)       __imp_UnmapViewOfFile(__VA_ARGS__)

extern typeof(UnmapViewOfFile) *const __imp_UnmapViewOfFile __msabi;
extern typeof(FlushViewOfFile) *const __imp_FlushViewOfFile __msabi;
extern typeof(MapViewOfFileExNuma) *const __imp_MapViewOfFileExNuma __msabi;
extern typeof(CreateFileMappingNuma) *const
    __imp_CreateFileMappingNumaW __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/messagebox.h */

#define COSMOPOLITAN_LIBC_NT_MESSAGEBOX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int MessageBox(int64_t hWnd, const char16_t *lpText, const char16_t *lpCaption,
               uint32_t mbType);
int MessageBoxEx(int64_t hWnd, const char16_t *lpText,
                 const char16_t *lpCaption, uint32_t mbType,
                 uint16_t wLanguageId);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/ntdll.h */

#define COSMOPOLITAN_LIBC_NT_NTDLL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » beyond the pale                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
    “The functions and structures in [for these APIs] are internal to
     the operating system and subject to change from one release of
     Windows to the next, and possibly even between service packs for
     each release.” ──Quoth MSDN */

#define __nt_system_call_dispatcher (wambda *)0x7ffe0308

extern const struct NtUnicodeString *const RtlNtdllName;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § new technology » beyond the pale » eponymous runtime      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define NT_PROCESS_FLAGS_CREATE_SUSPENDED 0x00000001
#define NT_PROCESS_FLAGS_INHERIT_HANDLES  0x00000002
#define NT_PROCESS_FLAGS_NO_SYNCHRONIZE   0x00000004
#define NT_RTL_CLONE_PARENT               0
#define NT_RTL_CLONE_CHILD                297

NtStatus NtCallbackReturn(void *opt_Result, uint32_t ResultLength,
                          int32_t Status);
NtStatus NtTestAlert(void);

NtStatus NtOpenFile(int64_t *out_FileHandle, uint32_t DesiredAccess,
                    struct NtObjectAttributes *ObjectAttributes,
                    struct NtIoStatusBlock *out_IoStatusBlock,
                    uint32_t ShareAccess, uint32_t OpenOptions);

NtStatus NtQueryInformationToken(int64_t TokenHandle,
                                 uint32_t TokenInformationClass,
                                 void *out_TokenInformation,
                                 uint32_t TokenInformationLength,
                                 uint32_t *out_ReturnLength);
NtStatus NtYieldExecution(void);
NtStatus NtQuerySystemInformation(uint32_t info_class, void *out_info,
                                  uint32_t info_size,
                                  uint32_t *out_bytes_received);
NtStatus NtReadVirtualMemory(int64_t ProcessHandle, const void *BaseAddress,
                             void *out_Buffer, size_t BufferLength,
                             size_t *opt_out_ReturnLength);
NtStatus NtCreateTimer(void **out_TimerHandle, uint32_t DesiredAccess,
                       struct NtObjectAttributes *ObjectAttributes,
                       uint32_t TimerType);
NtStatus NtSetTimer(void *TimerHandle, int64_t *DueTime, void *TimerApcRoutine,
                    void *TimerContext, int32_t Resume, int32_t Period,
                    int32_t *out_PreviousState);
NtStatus NtQueryObject(void *ObjectHandle, int ObjectInformationClass,
                       void *out_ObjectInformation,
                       uint32_t ObjectInformationLength,
                       uint32_t *opt_out_ReturnLength);
NtStatus NtQueryFullAttributesFile(
    struct NtObjectAttributes *attributes,
    struct NtFileNetworkOpenInformation *out_info);
NtStatus NtCreateKey(void **out_KeyHandle, uint32_t DesiredAccess,
                     struct NtObjectAttributes *ObjectAttributes,
                     uint32_t TitleIndex, struct NtUnicodeString *opt_Class,
                     uint32_t CreateOptions, uint32_t *opt_out_Disposition);
NtStatus NtOpenKey(void **out_KeyHandle, uint32_t DesiredAccess,
                   struct NtObjectAttributes *ObjectAttributes);
NtStatus NtSetValueKey(void *KeyHandle, struct NtUnicodeString *ValueName,
                       uint32_t opt_TitleIndex, uint32_t Type, void *Data,
                       uint32_t DataSize);
NtStatus NtDeleteKey(void *KeyHandle);
NtStatus NtQueryValueKey(void *KeyHandle, struct NtUnicodeString *ValueName,
                         int KeyValueInformationClass,
                         void *out_KeyValueInformation, uint32_t Length,
                         uint32_t *out_ResultLength);
NtStatus NtFlushKey(void *KeyHandle);
NtStatus NtEnumerateKey(int64_t hkey, uint32_t index, int info_class,
                        void *out_key_info, uint32_t key_info_size,
                        uint32_t *out_bytes_received);
NtStatus NtEnumerateValueKey(int64_t hKey, uint32_t index, int info_class,
                             void *out_key_info, uint32_t key_info_size,
                             uint32_t *out_bytes_received);
NtStatus NtQuerySystemTime(int64_t *SystemTime);
NtStatus NtDeleteFile(struct NtObjectAttributes *ObjectAttributes);
NtStatus NtFlushBuffersFile(int64_t FileHandle,
                            struct NtIoStatusBlock *out_IoStatusBlock);
NtStatus NtCreateIoCompletion(void **out_IoCompletionHandle,
                              uint32_t DesiredAccess,
                              struct NtObjectAttributes *ObjectAttributes,
                              uint32_t NumberOfConcurrentThreads);
NtStatus NtRaiseHardError(int32_t ErrorStatus, uint32_t NumberOfArguments,
                          uint32_t UnicodeStringArgumentsMask, void *Arguments,
                          uint32_t MessageBoxType,
                          uint32_t *out_MessageBoxResult);
NtStatus NtRaiseException(struct NtExceptionRecord *ExceptionRecord,
                          struct NtContext *Context, int32_t SearchFrames);
NtStatus NtCreateEvent(void **out_EventHandle, uint32_t DesiredAccess,
                       struct NtObjectAttributes *ObjectAttributes,
                       int EventType, int32_t InitialState);
NtStatus NtWaitForSingleObject(void *ObjectHandle, int32_t Alertable,
                               int64_t *TimeOut);
NtStatus NtSetEvent(void *EventHandle, int32_t *opt_out_PreviousState);
NtStatus NtClearEvent(void *EventHandle);
NtStatus NtSignalAndWaitForSingleObject(void *ObjectToSignal,
                                        void *WaitableObject, int32_t Alertable,
                                        int64_t *opt_Time);
NtStatus NtQueryPerformanceCounter(int64_t *out_PerformanceCount,
                                   int64_t *opt_out_PerformanceFrequency);
NtStatus NtFsControlFile(int64_t FileHandle, void *opt_Event,
                         NtIoApcRoutine opt_ApcRoutine, void *opt_ApcContext,
                         struct NtIoStatusBlock *out_IoStatusBlock,
                         uint32_t FsControlCode, void *opt_InputBuffer,
                         uint32_t InputBufferLength, void *opt_out_OutputBuffer,
                         uint32_t OutputBufferLength);
NtStatus NtCancelIoFile(int64_t FileHandle,
                        struct NtIoStatusBlock *out_IoStatusBlock);
NtStatus NtCreateProfile(void **out_ProfileHandle, int64_t ProcessHandle,
                         void *Base, uint32_t Size, uint32_t BucketShift,
                         uint32_t *Buffer, uint32_t BufferLength, int Source,
                         uint32_t ProcessorMask);
NtStatus NtSetIntervalProfile(uint32_t Interval, int Source);
NtStatus NtQueryIntervalProfile(int Source, uint32_t *out_Interval);
NtStatus NtStartProfile(void *ProfileHandle);
NtStatus NtStopProfile(void *ProfileHandle);
NtStatus NtCreateDirectoryObject(int64_t *out_DirectoryHandle,
                                 uint32_t DesiredAccess,
                                 struct NtObjectAttributes *ObjectAttributes);
NtStatus NtOpenDirectoryObject(int64_t *out_DirectoryHandle,
                               uint32_t DesiredAccess,
                               struct NtObjectAttributes *ObjectAttributes);
NtStatus NtOpenSymbolicLinkObject(int64_t *out_DirectoryHandle,
                                  uint32_t DesiredAccess,
                                  struct NtObjectAttributes *ObjectAttributes);
NtStatus NtQuerySymbolicLinkObject(int64_t DirectoryHandle,
                                   struct NtUnicodeString *inout_TargetName,
                                   uint32_t *opt_out_ReturnLength);
NtStatus ZwAreMappedFilesTheSame(void *Address1, void *Address2);
NtStatus NtQueryVolumeInformationFile(int64_t FileHandle,
                                      struct NtIoStatusBlock *out_IoStatusBlock,
                                      void *out_FsInformation, uint32_t Length,
                                      uint32_t FsInformationClass);
NtStatus NtQuerySecurityObject(
    int64_t handle, int RequestedInformation,
    struct NtSecurityDescriptor *out_SecurityDescriptor,
    uint32_t SecurityDescriptorLength, uint32_t *out_ReturnLength);
NtStatus NtQueueApcThread(int64_t ThreadHandle, NtPkNormalRoutine ApcRoutine,
                          void *opt_ApcContext, void *opt_Argument1,
                          void *opt_Argument2);
NtStatus NtFlushInstructionCache(int64_t ProcessHandle, void *opt_BaseAddress,
                                 size_t FlushSize);
NtStatus NtQueryAttributesFile(const struct NtObjectAttributes *object,
                               struct NtFileBasicInformation *file_information);
NtStatus NtQueryDirectoryFile(
    int64_t FileHandle, void *opt_Event, NtIoApcRoutine opt_ApcRoutine,
    void *opt_ApcContext, struct NtIoStatusBlock *out_IoStatusBlock,
    void *out_FileInformation, uint32_t FileInformationLength,
    uint32_t FileInformationClass, int32_t ReturnSingleEntry,
    struct NtUnicodeString *opt_FileName, int32_t RestartScan);
NtStatus NtFlushVirtualMemory(int64_t ProcessHandle, void **inout_BaseAddress,
                              uint32_t **inout_FlushSize,
                              struct NtIoStatusBlock *out_IoStatusBlock);
NtStatus NtQueryInformationJobObject(void *JobHandle, int JobInformationClass,
                                     void *out_JobInformation,
                                     uint32_t JobInformationLength,
                                     uint32_t *opt_out_ReturnLength);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § new technology » beyond the pale » runtime library        ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

NtStatus RtlInitializeCriticalSection(struct NtCriticalSection *out_crit);
NtStatus RtlDeleteCriticalSection(struct NtCriticalSection *crit);
NtStatus RtlEnterCriticalSection(struct NtCriticalSection *inout_crit);
NtStatus RtlLeaveCriticalSection(struct NtCriticalSection *inout_crit);
NtStatus RtlTryEnterCriticalSection(struct NtCriticalSection *inout_crit);
NtStatus RtlInitUnicodeString(struct NtUnicodeString *inout_DestinationString,
                              const char16_t *SourceString);
void RtlFreeUnicodeString(struct NtUnicodeString **string);
NtStatus RtlQueryEnvironmentVariable_U(char16_t *Environment,
                                       struct NtUnicodeString *Name,
                                       struct NtUnicodeString *Value);
NtStatus RtlConvertSidToUnicodeString(struct NtUnicodeString *out_UnicodeString,
                                      void *Sid,
                                      int32_t AllocateDestinationString);
void *RtlCreateHeap(uint32_t flags, void *base, size_t reserve_sz,
                    size_t commit_sz, void *lock, void *params);
NtStatus RtlDestroyHeap(void *base);
void *RtlAllocateHeap(int64_t heap, uint32_t flags, size_t size);
void *RtlReAllocateHeap(int64_t heap, uint32_t flags, void *ptr, size_t size);
NtStatus RtlFreeHeap(int64_t heap, uint32_t flags, void *ptr);
size_t RtlSizeHeap(int64_t heap, uint32_t flags, void *ptr);
NtStatus RtlValidateHeap(int64_t heap, uint32_t flags, void *ptr);
NtStatus RtlLockHeap(int64_t heap);
NtStatus RtlUnlockHeap(int64_t heap);
NtStatus RtlGetProcessHeaps(uint32_t count, void **out_Heaps);
NtStatus RtlWalkHeap(int64_t heap, void *out_Info);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/ntdll.inc */

#define NtYieldExecution(...) __imp_NtYieldExecution(__VA_ARGS__)

extern typeof(NtYieldExecution) *const __imp_NtYieldExecution __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/ntdllimport.h */

/*-*- mode:unix-assembly; indent-tabs-mode:t; tab-width:8; coding:utf-8     -*-│
│vi: set et ft=asm ts=8 tw=8 fenc=utf-8                                     :vi│
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#define COSMOPOLITAN_LIBC_NT_NTDLLIMPORT_H_


/*!BEGIN ape/relocations.h */

#define COSMOPOLITAN_APE_RELOCATIONS_H_
/*─────────────────────────────────────────────────────────────────────────────╗
│ αcτµαlly pδrταblε εxεcµταblε § relocations                                   │
╚──────────────────────────────────────────────────────────────────────────────╝
  One of the things αcτµαlly pδrταblε εxεcµταblε does a good job
  abstracting, is how a program needs to exist at three addresses
  simultaneously during the early stages of the loading process.

  By default, the linker calculates all symbols using virtual addresses.
  In some cases it's necessary to use addend macros that change virtual
  addresses into the other two types: physical and real. */

#ifndef IMAGE_BASE_VIRTUAL
#define IMAGE_BASE_VIRTUAL 0x400000
#endif

#ifndef IMAGE_BASE_PHYSICAL
#define IMAGE_BASE_PHYSICAL 0x100000
#endif

#ifndef REAL_SCRATCH_AREA
/**
 * Location of anything goes memory for real mode.
 *
 * The MBR won't load program content beyond this address, so we have
 * room for buffers, page tables, etc. before we reach the stack frame.
 */
#define REAL_SCRATCH_AREA 0x40000
#endif

#ifndef REAL_STACK_FRAME
/**
 * Location of real mode 64kb stack frame.
 *
 * This address was chosen because memory beyond 0x80000 can't be
 * accessed safely without consulting e820.
 */
#define REAL_STACK_FRAME 0x70000
#endif

/**
 * Returns Relative Virtual Address.
 */
#define RVA(x) ((x) - (IMAGE_BASE_VIRTUAL))

/**
 * Adjusts virtual address so it's relative to load address.
 */
#define PHYSICAL(x) ((x) - (IMAGE_BASE_VIRTUAL - IMAGE_BASE_PHYSICAL))

/**
 * Makes high-entropy read-only addresses relocatable in real mode.
 */
#define REAL(x) ((x) - (IMAGE_BASE_VIRTUAL - IMAGE_BASE_REAL))

#if IMAGE_BASE_VIRTUAL % 0x200000 != 0
#error "IMAGE_BASE_VIRTUAL must be 2mb aligned"
#endif
#if IMAGE_BASE_PHYSICAL % 0x1000 != 0
#error "IMAGE_BASE_PHYSICAL must be 4kb aligned"
#endif
#if IMAGE_BASE_REAL % 0x1000 != 0
#error "IMAGE_BASE_REAL must be 4kb aligned"
#endif

#ifdef __ASSEMBLER__
/* clang-format off */

.macro	.ntimp	fn:req
	yoink	_init_ntdll
	.initbss 202,_init_ntdll.\fn
__imp_\fn:
	.quad	0
	.endobj	__imp_\fn,globl,hidden
	.previous
	.initro 202,_init_ntdll.2.\fn
	.quad	RVA(.L\fn)
	.previous
	.section .rodata.str1.1,"aSM",@progbits,1
.L\fn:
	.asciz	"\fn"
	.previous
.endm

/* clang-format on */
#endif /* __ASSEMBLER__ */


/*!BEGIN libc/nt/paint.h */

#define COSMOPOLITAN_LIBC_NT_PAINT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § new technology » cpu graphics                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int64_t BeginPaint(int64_t hWnd, struct NtPaintStruct *lpPaint);
int32_t EndPaint(int64_t hWnd, const struct NtPaintStruct *lpPaint);
int32_t BitBlt(int64_t hdc, int x, int y, int cx, int cy, int64_t hdcSrc,
               int x1, int y1, uint32_t rop);
int32_t GetClientRect(int64_t hWnd, struct NtRect *lpRect);
int32_t GetWindowRect(int64_t hWnd, struct NtRect *lpRect);
int32_t SetBkMode(int64_t hdc, int mode);
uint32_t SetTextColor(int64_t hdc, uint32_t color);
uint32_t SetTextAlign(int64_t hdc, uint32_t align);
int32_t SetTextJustification(int64_t hdc, int extra, int count);
int32_t DrawText(int64_t hdc, const char16_t *lpchText, int cchText,
                 struct NtRect *lprc, uint32_t format);
int32_t DrawTextEx(int64_t hdc, char16_t *lpchText, int cchText,
                   struct NtRect *lprc, uint32_t format,
                   struct NtDrawTextParams *lpdtp);
int32_t FillRect(int64_t hDC, const struct NtRect *lpRC, int64_t hBrush);
uint32_t GetPixel(int64_t hdc, int x, int y);
uint32_t SetPixel(int64_t hdc, int x, int y, uint32_t color);
bool32 RedrawWindow(int64_t hWnd, const struct NtRect *opt_lprcUpdate,
                    int64_t opt_hrgnUpdate, uint32_t rdwFlags);
int64_t CreateCompatibleDC(int64_t hdc);
int64_t CreateCompatibleBitmap(int64_t hdc, int cx, int cy);
int64_t SelectObject(int64_t hdc, int64_t h);
bool32 DeleteObject(int64_t ho);
bool32 DeleteDC(int64_t hdc);
int SaveDC(int64_t hdc);
bool32 RestoreDC(int64_t hdc, int nSavedDC);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/paint.inc */

#define SetPixel(...) __imp_SetPixel(__VA_ARGS__)
#define GetPixel(...) __imp_GetPixel(__VA_ARGS__)

extern typeof(SetPixel) *const __imp_SetPixel __msabi;
extern typeof(GetPixel) *const __imp_GetPixel __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/privilege.h */

#define COSMOPOLITAN_LIBC_NT_PRIVILEGE_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » check your privilege                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtSePrivilegeEnabledByDefault 0x00000001u
#define kNtSePrivilegeEnabled          0x00000002u
#define kNtSePrivilegeRemoved          0x00000004u
#define kNtSePrivilegeUsedForAccess    0x80000000u

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 LookupPrivilegeValue(const char16_t *opt_lpSystemName,
                            const char16_t *lpName, struct NtLuid *out_lpLuid);

bool32 AdjustTokenPrivileges(int64_t TokenHandle, bool32 DisableAllPrivileges,
                             const struct NtTokenPrivileges *opt_NewState,
                             uint32_t BufferLength,
                             struct NtTokenPrivileges *opt_out_PreviousState,
                             uint32_t *opt_out_ReturnLength);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/process.h */

#define COSMOPOLITAN_LIBC_NT_PROCESS_H_


/*!BEGIN libc/nt/startupinfo.h */

#define COSMOPOLITAN_LIBC_NT_NTSTARTUPINFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void GetStartupInfo(struct NtStartupInfo *lpStartupInfo);

bool32 InitializeProcThreadAttributeList(
    struct NtProcThreadAttributeList *opt_inout_lpAttributeList,
    uint32_t dwAttributeCount, uint32_t reserved_dwFlags, size_t *inout_lpSize)
    paramsnonnull((4));
bool32 UpdateProcThreadAttribute(
    struct NtProcThreadAttributeList *inout_lpAttributeList, uint32_t dwFlags,
    const uint32_t *Attribute, const void *lpValue, size_t cbSize,
    void *reserved_lpPreviousValue, size_t *reserved_lpReturnSize)
    paramsnonnull((1, 3, 4));
void DeleteProcThreadAttributeList(
    struct NtProcThreadAttributeList *inout_lpAttributeList) paramsnonnull();

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/startupinfo.inc */

#define GetStartupInfo(...) __imp_GetStartupInfoW(__VA_ARGS__)

extern typeof(GetStartupInfo) *const __imp_GetStartupInfoW __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » processes                                ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

bool32 CreateProcess(const char16_t *opt_lpApplicationName,
                     char16_t *lpCommandLine,
                     struct NtSecurityAttributes *opt_lpProcessAttributes,
                     struct NtSecurityAttributes *opt_lpThreadAttributes,
                     bool32 bInheritHandles, uint32_t dwCreationFlags,
                     void *opt_lpEnvironment,
                     const char16_t *opt_lpCurrentDirectory,
                     const struct NtStartupInfo *lpStartupInfo,
                     struct NtProcessInformation *opt_out_lpProcessInformation)
    paramsnonnull((2, 9));

uint32_t GetThreadId(int64_t hThread);   /* cf. NT_TID */
uint32_t GetProcessId(int64_t hProcess); /* cf. NT_PID */
void SetLastError(uint32_t dwErrCode);
uint32_t FormatMessage(uint32_t dwFlags, const void *lpSource,
                       uint32_t dwMessageId, uint32_t dwLanguageId,
                       char16_t *lpBuffer, uint32_t nSize, va_list *Arguments);
int64_t OpenProcess(uint32_t dwDesiredAccess, bool32 bInheritHandle,
                    uint32_t dwProcessId);
uint32_t GetCurrentProcessId(void); /* %gs:0x40 */
uint32_t GetEnvironmentVariable(const char16_t *lpName, char16_t *lpBuffer,
                                uint32_t nSize);
uint32_t SetEnvironmentVariable(const char16_t *lpName, char16_t *lpValue);
int32_t SetEnvironmentStrings(char16_t *NewEnvironment);
bool32 GetProcessAffinityMask(int64_t hProcess,
                              uintptr_t *lpProcessAffinityMask,
                              uintptr_t *lpSystemAffinityMask);
uint64_t /*bool32*/ SetProcessAffinityMask(int64_t hProcess,
                                           uintptr_t dwProcessAffinityMask);

/* e.g. kNtAboveNormalPriorityClass, kNtHighPriorityClass */
uint32_t GetPriorityClass(int64_t hProcess);
bool32 SetPriorityClass(int64_t hProcess, uint32_t dwPriorityClass);
bool32 SetProcessPriorityBoost(int64_t hProcess, bool32 bDisablePriorityBoost);
bool32 GetProcessPriorityBoost(int64_t hProcess, bool32 *pDisablePriorityBoost);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/process.inc */

#define GetEnvironmentVariable(...) __imp_GetEnvironmentVariableW(__VA_ARGS__)
extern typeof(GetEnvironmentVariable) *const
    __imp_GetEnvironmentVariableW __msabi;

#define SetEnvironmentVariable(...) __imp_SetEnvironmentVariableW(__VA_ARGS__)
extern typeof(SetEnvironmentVariable) *const
    __imp_SetEnvironmentVariableW __msabi;

#define GetPriorityClass(...) __imp_GetPriorityClass(__VA_ARGS__)
extern typeof(GetPriorityClass) *const __imp_GetPriorityClass __msabi;

#define SetPriorityClass(...) __imp_SetPriorityClass(__VA_ARGS__)
extern typeof(SetPriorityClass) *const __imp_SetPriorityClass __msabi;

#define GetCurrentProcessId(...) __imp_GetCurrentProcessId(__VA_ARGS__)
extern typeof(GetCurrentProcessId) *const __imp_GetCurrentProcessId __msabi;

#define CreateProcess(...) __imp_CreateProcessW(__VA_ARGS__)
extern typeof(CreateProcess) *const __imp_CreateProcessW __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/registry.h */

#define COSMOPOLITAN_LIBC_NT_REGISTRY_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » registry                                 ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtMaxKeyNameChars   255
#define kNtMaxValueNameChars 16383
#define kNtMaxValueBytes     0x100000

#define kNtHkeyClassesRoot              0x80000000l
#define kNtHkeyCurrentUser              0x80000001l
#define kNtHkeyLocalMachine             0x80000002l
#define kNtHkeyUsers                    0x80000003l
#define kNtHkeyPerformanceData          0x80000004l
#define kNtHkeyPerformanceText          0x80000050l
#define kNtHkeyPerformanceNlstext       0x80000060l
#define kNtHkeyCurrentConfig            0x80000005l
#define kNtHkeyDynData                  0x80000006l
#define kNtHkeyCurrentUserLocalSettings 0x80000007l

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int RegOpenKey(int64_t hKey, const char16_t *opt_lpSubKey,
               int64_t *out_phkResult) paramsnonnull((3));
int RegOpenKeyEx(int64_t hKey, const char16_t *opt_lpSubKey,
                 uint32_t opt_ulOptions, int samDesired, int64_t *out_phkResult)
    paramsnonnull((5));
int RegCloseKey(int64_t hKey);

int RegGetValue(int64_t hkey, const char16_t *opt_lpSubKey,
                const char16_t *opt_lpValue, unsigned dwFlags, int *opt_pdwType,
                void *opt_out_pvData, uint32_t *opt_inout_pcbDataBytes);
int RegSetValue(int64_t hKey, const char16_t *lpSubKey, int dwType,
                const char16_t *lpData, uint32_t cbData);
int RegSetValueEx(int64_t hKey, const char16_t *lpValueName, uint32_t Reserved,
                  int dwType, const unsigned char *lpData, uint32_t cbData);

int RegQueryInfoKey(int64_t hKey, char16_t *opt_out_lpClass,
                    uint32_t *opt_inout_lpClassLen, uint32_t *lpReserved,
                    uint32_t *opt_out_lpcSubKeys,
                    uint32_t *opt_out_lpcbMaxSubKeyBytes,
                    uint32_t *opt_out_lpcbMaxClassBytes,
                    uint32_t *opt_out_lpcValues,
                    uint32_t *opt_out_lpcbMaxValueNameBytes,
                    uint32_t *opt_out_lpcbMaxValueBytes,
                    uint32_t *opt_out_lpcbSecurityDescriptorBytes,
                    struct NtFileTime *opt_out_lpftLastWriteTime);
int RegEnumKey(int64_t hKey, uint32_t dwIndex, char16_t *opt_lpName,
               uint32_t NameLen);
int RegEnumKeyEx(int64_t hKey, uint32_t dwIndex, char16_t *out_lpName,
                 uint32_t *inout_lpcchName, uint32_t *lpReserved,
                 char16_t *opt_out_lpClass, uint32_t *opt_inout_lpcchClassLen,
                 struct NtFileTime *opt_out_lpftLastWriteTime);

int RegEnumValue(int64_t hKey, uint32_t dwIndex, char16_t *lpValueName,
                 uint32_t *lpValueNameLen, uint32_t *lpReserved,
                 int *opt_out_lpType, unsigned char *opt_out_lpData,
                 uint32_t *opt_inout_lpcbDataBytes);
int RegQueryValue(int64_t hKey, const char16_t *opt_lpSubKey,
                  char16_t *opt_out_lpData, int32_t *opt_inout_lpcbDataBytes);
int RegQueryValueEx(int64_t hKey, const char16_t *opt_lpValueName,
                    uint32_t *lpReserved, int *opt_out_lpType,
                    unsigned char *opt_out_lpData,
                    uint32_t *opt_inout_lpcbDataBytes);

int RegOverridePredefKey(int64_t hKey, int64_t hNewHKey);
int RegOpenUserClassesRoot(void *hToken, uint32_t dwOptions, int samDesired,
                           int64_t *phkResult);
int RegOpenCurrentUser(int samDesired, int64_t *phkResult);
int RegDisablePredefinedCache();
int RegConnectRegistry(const char16_t *lpMachineName, int64_t hKey,
                       int64_t *phkResult);
int RegConnectRegistryEx(const char16_t *lpMachineName, int64_t hKey,
                         uint32_t Flags, int64_t *phkResult);
int RegCreateKey(int64_t hKey, const char16_t *lpSubKey, int64_t *phkResult);
int RegCreateKeyEx(int64_t hKey, const char16_t *lpSubKey, uint32_t Reserved,
                   int16_t *lpClass, uint32_t dwOptions, int samDesired,
                   struct NtSecurityAttributes *lpSecurityAttributes,
                   int64_t *phkResult, uint32_t *lpdwDisposition);
int RegDeleteKey(int64_t hKey, const char16_t *lpSubKey);
int RegDeleteKeyEx(int64_t hKey, const char16_t *lpSubKey, int samDesired,
                   uint32_t Reserved);
int RegDeleteTree(int64_t hKey, const char16_t *opt_lpSubKey);
int RegDisableReflectionKey(int64_t hBase);
int RegEnableReflectionKey(int64_t hBase);
int RegQueryReflectionKey(int64_t hBase, bool32 *bIsReflectionDisabled);
int RegDeleteValue(int64_t hKey, const char16_t *lpValueName);
int RegFlushKey(int64_t hKey);
int RegGetKeySecurity(int64_t hKey, uint32_t SecurityInformation,
                      void *pSecurityDescriptor,
                      uint32_t *lpcbSecurityDescriptorBytes);
int RegLoadKey(int64_t hKey, const char16_t *lpSubKey, const char16_t *lpFile);
int RegNotifyChangeKeyValue(int64_t hKey, bool32 bWatchSubtree,
                            uint32_t dwNotifyFilter, void *hEvent,
                            int fAsynchronous);
int RegQueryMultipleValues(int64_t hKey, struct NtValent *inout_val_list,
                           uint32_t num_vals, int16_t *out_lpValueBuf,
                           uint32_t *inout_ldwTotsize) paramsnonnull();
int RegReplaceKey(int64_t hKey, const char16_t *lpSubKey,
                  const char16_t *lpNewFile, const char16_t *lpOldFile);
int RegRestoreKey(int64_t hKey, const char16_t *lpFile, uint32_t dwFlags);
int RegSaveKey(int64_t hKey, const char16_t *lpFile,
               struct NtSecurityAttributes *lpSecurityAttributes);
int RegSetKeySecurity(int64_t hKey, uint32_t SecurityInformation,
                      void *pSecurityDescriptor);
int RegUnLoadKey(int64_t hKey, const char16_t *lpSubKey);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/runtime.h */

#define COSMOPOLITAN_LIBC_NT_RUNTIME_H_

/**
 * @fileoverview NT Obligatory Runtime Functions.
 *
 * These functions are placed in their own file because they're (a)
 * abstracted by the Cosmopolitan runtime; and (b) it helps GCC avoid
 * bloating binaries with debug information the user doesn't need.
 */

#define kNtCpUtf8             65001
#define kNtInvalidHandleValue -1L
#define kNtStdInputHandle     -10L
#define kNtStdOutputHandle    -11L
#define kNtStdErrorHandle     -12L

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

char16_t *GetCommandLine(void) nosideeffect;
char16_t *GetEnvironmentStrings(void) nodiscard;
bool32 FreeEnvironmentStrings(char16_t *) paramsnonnull();
bool32 ReadFile(int64_t hFile, void *lpBuffer, uint32_t nNumberOfBytesToRead,
                uint32_t *lpNumberOfBytesRead,
                struct NtOverlapped *opt_lpOverlapped);
bool32 WriteFile(int64_t hFile, const void *lpBuffer,
                 uint32_t nNumberOfBytesToWrite,
                 uint32_t *lpNumberOfBytesWritten,
                 struct NtOverlapped *opt_lpOverlapped);
bool32 TerminateProcess(int64_t hProcess, uint32_t uExitCode);
int64_t GetCurrentProcess(void) pureconst;
void ExitProcess(uint32_t uExitCode) wontreturn;
uint32_t GetLastError(void) nosideeffect;
bool32 CloseHandle(int64_t hObject) nothrow nocallback;
intptr_t GetStdHandle(int64_t nStdHandle) nosideeffect;
bool32 SetStdHandle(int64_t nStdHandle, int64_t hHandle);
bool32 SetDefaultDllDirectories(unsigned dirflags);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/runtime.inc */

#define FreeEnvironmentStrings(...) __imp_FreeEnvironmentStringsW(__VA_ARGS__)
extern typeof(FreeEnvironmentStrings) *const
    __imp_FreeEnvironmentStringsW __msabi;

#define GetCommandLine(...) __imp_GetCommandLineW(__VA_ARGS__)
extern typeof(GetCommandLine) *const __imp_GetCommandLineW __msabi;

#define GetEnvironmentStrings(...) __imp_GetEnvironmentStringsW(__VA_ARGS__)
extern typeof(GetEnvironmentStrings) *const
    __imp_GetEnvironmentStringsW __msabi;

#define GetStdHandle(...) __imp_GetStdHandle(__VA_ARGS__)
extern typeof(GetStdHandle) *const __imp_GetStdHandle __msabi;

#define SetStdHandle(...) __imp_SetStdHandle(__VA_ARGS__)
extern typeof(SetStdHandle) *const __imp_SetStdHandle __msabi;

#define ReadFile(...) __imp_ReadFile(__VA_ARGS__)
extern typeof(ReadFile) *const __imp_ReadFile __msabi;

#define WriteFile(...) __imp_WriteFile(__VA_ARGS__)
extern typeof(WriteFile) *const __imp_WriteFile __msabi;

#define SetDefaultDllDirectories(...) \
  __imp_SetDefaultDllDirectories(__VA_ARGS__)
extern typeof(SetDefaultDllDirectories) *const
    __imp_SetDefaultDllDirectories __msabi;

#define GetCurrentProcess(...) __imp_GetCurrentProcess(__VA_ARGS__)
extern typeof(GetCurrentProcess) *const __imp_GetCurrentProcess __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/signals.h */

#define COSMOPOLITAN_LIBC_NT_EXCEPTIONS_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » signals                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef int (*NtTopLevelExceptionFilter)(const struct NtExceptionPointers *);
typedef int32_t (*NtVectoredExceptionHandler)(struct NtExceptionPointers *);

int SetErrorMode(int uMode);

int64_t AddVectoredExceptionHandler(uint32_t First,
                                    NtVectoredExceptionHandler pHandler);
int64_t AddVectoredContinueHandler(uint32_t First,
                                   NtVectoredExceptionHandler pHandler);

uint32_t RemoveVectoredExceptionHandler(int64_t hHandle);
uint32_t RemoveVectoredContinueHandler(int64_t hHandle);

NtTopLevelExceptionFilter SetUnhandledExceptionFilter(
    NtTopLevelExceptionFilter opt_lpTopLevelExceptionFilter);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/signals.inc */

#define SetErrorMode(...) __imp_SetErrorMode(__VA_ARGS__)
#define AddVectoredExceptionHandler(...) \
  __imp_AddVectoredExceptionHandler(__VA_ARGS__)
#define AddVectoredContinueHandler(...) \
  __imp_AddVectoredContinueHandler(__VA_ARGS__)
#define RemoveVectoredExceptionHandler(...) \
  __imp_RemoveVectoredExceptionHandler(__VA_ARGS__)
#define RemoveVectoredContinueHandler(...) \
  __imp_RemoveVectoredContinueHandler(__VA_ARGS__)
#define SetUnhandledExceptionFilter(...) \
  __imp_SetUnhandledExceptionFilter(__VA_ARGS__)

extern typeof(SetErrorMode) *const __imp_SetErrorMode __msabi;
extern typeof(AddVectoredExceptionHandler) *const
    __imp_AddVectoredExceptionHandler __msabi;
extern typeof(AddVectoredContinueHandler) *const
    __imp_AddVectoredContinueHandler __msabi;
extern typeof(RemoveVectoredExceptionHandler) *const
    __imp_RemoveVectoredExceptionHandler __msabi;
extern typeof(RemoveVectoredContinueHandler) *const
    __imp_RemoveVectoredContinueHandler __msabi;
extern typeof(SetUnhandledExceptionFilter) *const
    __imp_SetUnhandledExceptionFilter __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/synchronization.h */

#define COSMOPOLITAN_LIBC_NT_SYNCHRONIZATION_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » synchronization                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define InterlockedAdd(PTR, VAL)                                           \
  ({                                                                       \
    typeof(*(PTR)) Res;                                                    \
    typeof(Res) Val = (VAL);                                               \
    asm volatile("lock xadd\t%0,%1" : "=r"(Res), "+m"(*(PTR)) : "0"(Val)); \
    Res + Val;                                                             \
  })

#define InterlockedExchange(PTR, VAL)                      \
  ({                                                       \
    typeof(*(PTR)) Res = (VAL);                            \
    asm volatile("xchg\t%0,%1" : "+r"(Res), "+m"(*(PTR))); \
    Res;                                                   \
  })

typedef void (*NtTimerapcroutine)(void *lpArgToCompletionRoutine,
                                  uint32_t dwTimerLowValue,
                                  uint32_t dwTimerHighValue);
typedef void (*NtWaitOrTimerCallback)(void *lpParameter,
                                      bool32 TimerOrWaitFired);

void Sleep(uint32_t dwMilliseconds);
uint32_t SleepEx(uint32_t dwMilliseconds, bool32 bAlertable);

void GetSystemTime(struct NtSystemTime *lpSystemTime);
bool32 SystemTimeToFileTime(const struct NtSystemTime *lpSystemTime,
                            struct NtFileTime *lpFileTime);
void GetSystemTimeAsFileTime(struct NtFileTime *);        /* win8+ */
void GetSystemTimePreciseAsFileTime(struct NtFileTime *); /* win8+ */

uint32_t WaitForSingleObject(int64_t hHandle, uint32_t dwMilliseconds);
uint32_t WaitForMultipleObjects(uint32_t nCount, const int64_t *lpHandles,
                                bool32 bWaitAll, uint32_t dwMilliseconds);
uint32_t WaitForSingleObjectEx(int64_t hHandle, uint32_t dwMilliseconds,
                               bool32 bAlertable);
uint32_t WaitForMultipleObjectsEx(unsigned int nCount, const int64_t *lpHandles,
                                  bool32 bWaitAll, uint32_t dwMilliseconds,
                                  bool32 bAlertable);
bool32 RegisterWaitForSingleObject(int64_t *phNewWaitObject, int64_t hObject,
                                   NtWaitOrTimerCallback Callback,
                                   void *Context, uint32_t dwMilliseconds,
                                   uint32_t dwFlags);

int64_t CreateWaitableTimer(struct NtSecurityAttributes *lpTimerAttributes,
                            bool32 bManualReset, const char16_t *lpTimerName);
bool32 SetWaitableTimer(int64_t hTimer, const int64_t *lpDueTimeAsFtOrNegRela,
                        int32_t opt_lPeriodMs, NtTimerapcroutine opt_callback,
                        void *lpArgToCallback, bool32 fUnsleepSystem);

int32_t SetEvent(int64_t hEvent);
int32_t ResetEvent(int64_t hEvent);
int32_t PulseEvent(int64_t hEvent);

int32_t ReleaseMutex(int64_t hMutex);
int32_t ReleaseSemaphore(int64_t hSemaphore, int32_t lReleaseCount,
                         int *lpPreviousCount);

void InitializeCriticalSection(struct NtCriticalSection *lpCriticalSection);
void EnterCriticalSection(struct NtCriticalSection *lpCriticalSection);
void LeaveCriticalSection(struct NtCriticalSection *lpCriticalSection);
int32_t TryEnterCriticalSection(struct NtCriticalSection *lpCriticalSection);
void DeleteCriticalSection(struct NtCriticalSection *lpCriticalSection);
int32_t InitializeCriticalSectionAndSpinCount(
    struct NtCriticalSection *lpCriticalSection, uint32_t dwSpinCount);
uint32_t SetCriticalSectionSpinCount(
    struct NtCriticalSection *lpCriticalSection, uint32_t dwSpinCount);

void InitializeSRWLock(intptr_t *);
void AcquireSRWLockExclusive(intptr_t *);
void AcquireSRWLockShared(intptr_t *);
void ReleaseSRWLockExclusive(intptr_t *);
void ReleaseSRWLockShared(intptr_t *);
void TryAcquireSRWLockExclusive(intptr_t *);
void TryAcquireSRWLockShared(intptr_t *);

uint64_t GetTickCount64(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/systeminfo.h */

#define COSMOPOLITAN_LIBC_NT_INFO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void GetSystemInfo(struct NtSystemInfo *lpSystemInfo);
uint32_t GetSystemDirectory(char16_t *lpBuffer, uint32_t uSize);
uint32_t GetSystemDirectoryA(char *lpBuffer, uint32_t uSize);
uint32_t GetWindowsDirectory(char16_t *lpBuffer, uint32_t uSize);
uint32_t GetTempPath(uint32_t uSize, char16_t *lpBuffer);

bool32 GetComputerNameEx(/* enum/computernameformat.h */ int NameType,
                         char16_t *opt_lpBuffer, uint32_t *nSize);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/systeminfo.inc */

#define GetSystemInfo(...) __imp_GetSystemInfo(__VA_ARGS__)
#define GetTempPath(...) __imp_GetTempPathW(__VA_ARGS__)

extern typeof(GetSystemInfo) *const __imp_GetSystemInfo __msabi;
extern typeof(GetTempPath) *const __imp_GetTempPathW __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/thread.h */

#define COSMOPOLITAN_LIBC_NT_THREADS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » threads                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

typedef uint32_t (*NtThreadStartRoutine)(void *lpParameter);

int64_t CreateThread(struct NtSecurityAttributes *lpThreadAttributes,
                     size_t dwStackSize, NtThreadStartRoutine lpStartAddress,
                     void *lpParameter, uint32_t dwCreationFlags,
                     uint32_t *opt_lpThreadId);

void ExitThread(uint32_t dwExitCode) wontreturn;
int64_t GetCurrentThread(void);
uint32_t GetCurrentThreadId(void);
uint64_t SetThreadAffinityMask(int64_t hThread, uintptr_t dwThreadAffinityMask);
int64_t OpenThread(uint32_t dwDesiredAccess, bool32 bInheritHandle,
                   uint32_t dwThreadId);
bool32 TerminateThread(int64_t hThread, uint32_t dwExitCode);
bool32 GetExitCodeThread(int64_t hThread, uint32_t *lpExitCode);

/* e.g. kNtThreadPriorityAboveNormal, -1u on error */
uint32_t GetThreadPriority(int64_t hThread);
bool32 SetThreadPriority(int64_t hThread, int32_t nPriority);
bool32 SetThreadPriorityBoost(int64_t hThread, bool32 bDisablePriorityBoost);
bool32 GetThreadPriorityBoost(int64_t hThread, bool32 *pDisablePriorityBoost);
bool32 GetThreadIOPendingFlag(int64_t hThread, bool32 *lpIOIsPending);

bool32 CancelSynchronousIo(int64_t hThread);
bool32 CancelIo(int64_t hFile);
bool32 CancelIoEx(int64_t hFile, struct NtOverlapped opt_lpOverlapped);

#if ShouldUseMsabiAttribute()


/*!BEGIN libc/nt/thunk/thread.inc */

#define GetCurrentThread(...)  __imp_GetCurrentThread(__VA_ARGS__)
#define GetThreadPriority(...) __imp_GetThreadPriority(__VA_ARGS__)
#define SetThreadPriority(...) __imp_SetThreadPriority(__VA_ARGS__)

extern typeof(GetCurrentThread) *const __imp_GetCurrentThread __msabi;
extern typeof(GetThreadPriority) *const __imp_GetThreadPriority __msabi;
extern typeof(SetThreadPriority) *const __imp_SetThreadPriority __msabi;
#endif /* ShouldUseMsabiAttribute() */
COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/windows.h */

#define COSMOPOLITAN_LIBC_NT_WINDOWS_H_
/*                            ░░░░
                       ▒▒▒░░░▒▒▒▒▒▒▒▓▓▓░
                      ▒▒▒▒░░░▒▒▒▒▒▒▓▓▓▓▓▓░
                     ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓░
                     ▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   ▓▓▓▓▓▓▒        ▒▒▒▓▓█
                    ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                   ░▒▒▒░░░░▒▒▒▒▒▒▓▓▓▓▓▓   █▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                   ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓░  ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
                  ▒▒▒▒░░░▒▒▒▒▒▒▒▓▓▓▓▓▓  ▒▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▒
                  ▒▒▒▒▓▓      ▓▒▒▓▓▓▓   ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                                   ▒▓  ▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓
                  ░░░░░░░░░░░▒▒▒▒      ▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓█
                ▒▒░░░░░░░░░░▒▒▒▒▒▓▓▓     ▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▓▓▓
               ░▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓░      ░▓███▓
               ▒▒░░░░░░░░░░▒▒▒▒▒▓▓░  ▒▓▓▓▒▒▒         ░▒▒▒▓   ████████████
              ▒▒░░░░░░░░░░░▒▒▒▒▒▓▓  ▒▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒░           ░███
              ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓            ███
             ▒▒░░░░░░░░░░▒▒▒▒▒▒▓▓  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒            ▓██
             ▒░░░░░░░░░░░▒▒▒▒▒▓▓   ▓▓▓▓▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▓           ▓██
            ▒▒░░░▒▒▒░░░▒▒░▒▒▒▓▓▒  ▒▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▒           ███
                            ░▒▓  ░▓▓▓▓▒▒▒▒▒▒▒▒░░░░▒▒▒▒▓          ▓██
╔────────────────────────────────────────────────────────────────▀▀▀─────────│─╗
│ cosmopolitan § new technology » windows                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int64_t CreateWindowEx(uint32_t dwExStyle, const char16_t *lpClassName,
                       const char16_t *lpWindowName, uint32_t dwStyle, int X,
                       int Y, int nWidth, int nHeight, int64_t hWndParent,
                       int64_t hMenu, int64_t hInstance, int64_t lpParam);

uint16_t RegisterClass(const struct NtWndClass *lpWndClass);

int64_t DefWindowProc(int64_t hWnd, uint32_t Msg, uint64_t wParam,
                      int64_t lParam);

int32_t CloseWindow(int64_t hWnd);
int32_t DestroyWindow(int64_t hWnd);
int32_t ShowWindow(int64_t hWnd, int sw);
int32_t ShowCaret(bool32 bShow);
int32_t AnimateWindow(int64_t hWnd, uint32_t dwTime, uint32_t dwFlags);
int64_t LoadIcon(int64_t hInstance, const char16_t *lpIconName);
int32_t MoveWindow(int64_t hWnd, int X, int Y, int nWidth, int nHeight,
                   bool32 bRepaint);
int32_t BringWindowToTop(int64_t hWnd);
int32_t IsWindowVisible(int64_t hWnd);
int32_t SetWindowText(int64_t hWnd, const char16_t *lpString);
int32_t GetWindowText(int64_t hWnd, char16_t *lpString, int nMaxCount);
int32_t SetWindowPos(int64_t hWnd, int64_t hWndInsertAfter, int X, int Y,
                     int cx, int cy, uint32_t uFlags);
bool32 GetWindowPlacement(int64_t hWnd, struct NtWindowPlacement *lpwndpl);
bool32 SetWindowPlacement(int64_t hWnd,
                          const struct NtWindowPlacement *lpwndpl);

int64_t GetCursor(void);
int64_t SetCursor(int64_t hCursor);
int32_t ShowCursor(bool32 bShow);
int64_t LoadCursor(int64_t opt_hInstance, const char16_t *lpCursorNameOrIdc);

bool32 IsWindow(int64_t hWnd);
bool32 IsMenu(int64_t hMenu);
bool32 IsChild(int64_t hWndParent, int64_t hWnd);
bool32 IsZoomed(int64_t hWnd);
bool32 IsIconic(int64_t hWnd);

uintptr_t SetTimer(int64_t opt_hWnd, uintptr_t nIDEvent, uint32_t uElapseMs,
                   NtTimerProc lpTimerFunc);
int32_t KillTimer(int64_t hWnd, uintptr_t uIDEvent);

int64_t SetCapture(int64_t hWnd);
bool32 ReleaseCapture(void);
int16_t GetKeyState(int32_t nVirtKey);

int64_t CreateMenu(void);
int64_t CreatePopupMenu(void);
int64_t GetMenu(int64_t hWnd);
bool32 DestroyMenu(int64_t hMenu);
int64_t GetSystemMenu(int64_t hWnd, bool32 bRevert);
bool32 AppendMenu(int64_t hMenu, uint32_t mfFlags, uintptr_t uIDNewItem,
                  const char16_t *lpNewItem);
bool32 InsertMenu(int64_t hMenu, uint32_t uPosition, uint32_t uFlags,
                  uintptr_t uIDNewItem, const char16_t *lpNewItem);
bool32 TrackPopupMenu(int64_t hMenu, uint32_t uFlags, int32_t x, int32_t y,
                      int32_t nReserved, int64_t hWnd,
                      const struct NtRect *prcRect);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/nt/winsock.h */

#define COSMOPOLITAN_LIBC_NT_WINSOCK_H_
/* ░▓█████████████████████████████████████████████▓▒
   ░█▓░░░░░░░░░▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▒░
   ░█▓░ ░▒▒▒▒  ▓██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▓▒▒
   ░█▓░ ░▓▓▓▒  ▓██▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██▓▒▒
   ░█▓░       ░▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██▓▒▒
   ░███████████████████████████████████████████████▓▒▒
   ░█▓░                                          ▒█▓▒▒
   ░█▓░                                          ▒█▓▒▒
   ░█▓░          ░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░             ▒█▓▒▒
   ░█▓░        ░▒░                 ▒█▓░          ▒█▓▒▒
   ░█▓░      ░░░░    ░░░░░░░░      ▒▓▓▓▒░        ▒█▓▒▒
   ░█▓░    ░░░░  ░░░░░▒▒▓███▓░░░░░░░░▒▓▓▓▓▒      ▒█▓▒▒
   ░█▓░   ░▒▒  ░░░░░░░▒▒████▓░░░░░░░░░░▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒  ░░░░░░░▒▒▓▓▓▓▓░░░░░░░░░▒▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒   ░░▒▒▒▒░░░░░ ░▒▒▒▒░░░░░▒▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒   ░░▒▓█▓░░░░░░░▒▓██▓░░░░▒▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒   ░░▒▓█▓░░░░░░░▒▓██▓░░░░▒▒██▓      ▒█▓▒▒
   ░█▓░   ░▒▒   ░░▒▓█▓░░░░░░░▒▓██▓░░░░▒▒██▓   ░▓█▓▒▒▒▒
   ░█▓░   ░▒▒   ░░▒▓█▓░░░░░░░▒▓██▓░░░░░▒██▓   ░████▓▒░
   ░█▓░     ░░░░░░░░▒▒░░░░░░░░░▒▒░░░▒▒▓▓▒░░    ░░▓███▓▒░
   ░█▓░      ░░░░░░░░░░░░░░░░░░░░░░▒▓▓▓▒░        ▒████▓▒░░░░░░
   ░█▓░        ░░▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░░        ░▓▓▓▓██▒░░░░░░░░
   ░█▓░          ▒█████████████████▒  ▓█▓▒░      ▒█▓ ░█▓      ░▓▓░
   ░█▓░                              ░▓████▒░    ▒█▓▒░  ░░░░░░░  ▓█▓░
   ░█▓░                                ░▓████▒░  ░▒░  ░░░░░░░░░░░  ░█▓
   ░█▓                                    ▒███▓▒▒░  ░░░░░░░░░░░░░░░  ▒▓▓
   ░██████████████████████████████████████▓▒▓█▓░  ░░░░░░░░░░░░░░░░░░ ▒█▓
    ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒░ ░░░░░░░░░░░░░░░░░░░░▒█▓
         ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒██▒▒▒░░░░░░░░░░░░░░░░░░░░░▒█▓
                                          ░██▒▒▒▒▒░░░░░░░░░░░░░░░░░░░▒█▓
                                          ░▓▓▓▒▒▒▒▒▒░░░░░░░░░░░░░░░░▒▓█▓
                                            ░▓▓▓▒▒▒▒▒▒░░░░░░░░░░░▒▒▒▒▓▓▒
                                              ░██▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒  ░█▓
                                                 ▒█▓▒▒▒▒▒▒▒▒▒▒▒██▓▒░ ░█▓
                                                   ▒█████████████▓▒▒░  ░██▒
╔────────────────────────────────────────────────────────────────▀▀▀▀───▀▀▀▀─│─╗
│ cosmopolitan § new technology » winsock                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define kNtCompEqual   0
#define kNtCompNotless 1

#define kNtWsaFlagOverlapped      0x01
#define kNtWsaFlagNoHandleInherit 0x80

#define kNtTfDisconnect       0x01
#define kNtTfReuseSocket      0x02
#define kNtTfWriteBehind      0x04
#define kNtTfUseDefaultWorker 0x00
#define kNtTfUseSystemThread  0x10
#define kNtTfUseKernelApc     0x20

#define kNtSoConnectTime          0x700C
#define kNtSoUpdateAcceptContext  0x700B
#define kNtSoUpdateConnectContext 0x7010

#define kNtSioAddressListChange           0x28000017u
#define kNtSioAddressListQuery            0x48000016u
#define kNtSioAddressListSort             0xC8000019u
#define kNtSioAssociateHandle             0x88000001u
#define kNtSioEnableCircularQueueing      0x28000002u
#define kNtSioFindRoute                   0x48000003u
#define kNtSioFlush                       0x28000004u
#define kNtSioGetBroadcastAddress         0x48000005u
#define kNtSioGetExtensionFunctionPointer 0xC8000006u
#define kNtSioGetGroupQos                 0xC8000008u
#define kNtSioGetQos                      0xC8000007u
#define kNtSioMulticastScope              0x8800000Au
#define kNtSioMultipointLoopback          0x88000009u
#define kNtSioQueryRssProcessorInfo       0x48000025u
#define kNtSioQueryTargetPnpHandle        0x48000018u
#define kNtSioReserved1                   0x8800001Au
#define kNtSioReserved2                   0x88000021u
#define kNtSioRoutingInterfaceChange      0x88000015u
#define kNtSioRoutingInterfaceQuery       0xC8000014u
#define kNtSioSetGroupQos                 0x8800000Cu
#define kNtSioSetQos                      0x8800000Bu
#define kNtSioSocketCloseNotify           0x9800000Du
#define kNtSioTranslateHandle             0xC800000Du
#define kNtSioUdpConnreset                0x9800000Cu
#define kNtSioUdpNetreset                 0x9800000Fu

#define kNtNspNotifyImmediately 0
#define kNtNspNotifyHwnd        1
#define kNtNspNotifyEvent       2
#define kNtNspNotifyPort        3
#define kNtNspNotifyApc         4

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct NtTimeval {
  int32_t tv_sec; /* [sic] */
  int32_t tv_usec;
};

struct NtIovec {
  uint32_t len;
  char *buf;
};

struct NtMsgHdr {
  struct sockaddr *name;
  int32_t namelen;
  struct NtIovec *lpBuffers;
  uint32_t dwBufferCount;
  struct NtIovec Control;
  uint32_t dwFlags;
};

struct NtWsaData {
  uint16_t wVersion;
  uint16_t wHighVersion;
  uint16_t iMaxSockets;
  uint16_t iMaxUdpDg;
  char *lpVendorInfo;
  char szDescription[257];
  char szSystemStatus[129];
};

struct NtSocketAddress {
  struct sockaddr *lpSockaddr;
  int32_t iSockaddrLength;
};

struct NtSocketAddressList {
  int32_t iAddressCount;
  struct NtSocketAddress Address[1];
};

struct NtAddrInfoEx {  /* win8+ */
  int32_t ai_flags;    /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
  int32_t ai_family;   /* PF_XXX */
  int32_t ai_socktype; /* SOCK_XXX */
  int32_t ai_protocol;
  uint64_t ai_addrlen;
  char16_t *ai_canonname;
  struct sockaddr *ai_addr;
  void *ai_blob;
  uint64_t ai_bloblen;
  struct NtGuid *ai_provider;
  struct NtAddrInfoEx *ai_next;
  int32_t ai_version;          /* v2 */
  char16_t *ai_fqdn;           /* v2 */
  int32_t ai_interfaceindex;   /* v3 */
  int64_t ai_resolutionhandle; /* v4 */
};

struct NtWsaProtocolChain {
  int32_t ChainLen;
  uint32_t ChainEntries[7];
};

struct NtWsaProtocolInfo {
  uint32_t dwServiceFlags1;
  uint32_t dwServiceFlags2;
  uint32_t dwServiceFlags3;
  uint32_t dwServiceFlags4;
  uint32_t dwProviderFlags;
  struct NtGuid ProviderId;
  uint32_t dwCatalogEntryId;
  struct NtWsaProtocolChain ProtocolChain;
  int32_t iVersion;
  int32_t iAddressFamily;
  int32_t iMaxSockAddr;
  int32_t iMinSockAddr;
  int32_t iSocketType;
  int32_t iProtocol;
  int32_t iProtocolMaxOffset;
  int32_t iNetworkByteOrder;
  int32_t iSecurityScheme;
  uint32_t dwMessageSize;
  uint32_t dwProviderReserved;
  char16_t szProtocol[256];
};

struct NtFlowSpec {
  uint32_t TokenRate;          /* bytes/sec */
  uint32_t TokenBucketSize;    /* bytes */
  uint32_t PeakBandwidth;      /* bytes/sec */
  uint32_t Latency;            /* µs */
  uint32_t DelayVariation;     /* µs */
  uint32_t ServiceType;        /* kNtServicetypeXxx */
  uint32_t MaxSduSize;         /* bytes */
  uint32_t MinimumPolicedSize; /* bytes */
};

struct NtQos {
  struct NtFlowSpec SendingFlowspec;
  struct NtFlowSpec ReceivingFlowspec;
  struct NtIovec ProviderSpecific;
};

struct NtWsaVersion {
  uint32_t dwVersion;
  int ecHow;
};

struct NtAfProtocols {
  int32_t iAddressFamily;
  int32_t iProtocol;
};

struct NtBlob {
  uint32_t cbSize;
  uint8_t pBlobData;
};

struct NtCsAddrInfo {
  struct NtSocketAddress LocalAddr;
  struct NtSocketAddress RemoteAddr;
  int32_t iSocketType;
  int32_t iProtocol;
};

struct NtWsaQuerySet {
  uint32_t dwSize; /* of this */
  char16_t *lpszServiceInstanceName;
  struct NtGuid *lpServiceClassId;
  struct NtWsaVersion *lpVersion;
  char16_t *lpszComment;
  uint32_t dwNameSpace;
  struct NtGuid *lpNSProviderId;
  char16_t *lpszContext;
  uint32_t dwNumberOfProtocols;
  struct NtAfProtocols *lpafpProtocols /*[dwNumberOfProtocols]*/;
  char16_t *lpszQueryString;
  uint32_t dwNumberOfCsAddrs;
  struct NtCsAddrInfo *lpcsaBuffer /*[dwNumberOfCsAddrs]*/;
  uint32_t dwOutputFlags;
  struct NtBlob *lpBlob;
};

struct NtWsaNamespaceInfoEx {
  struct NtGuid NSProviderId;
  uint32_t dwNameSpace;
  bool32 fActive;
  uint32_t dwVersion;
  char16_t *lpszIdentifier;
  struct NtBlob *ProviderSpecific;
};

struct NtWsansClassInfo {
  char16_t *lpszName;
  uint32_t dwNameSpace;
  uint32_t dwValueType;
  uint32_t dwValueSize;
  void *lpValue;
};

struct NtWsaServiceClassInfo {
  struct NtGuid *lpServiceClassId;
  char16_t *lpszServiceClassName;
  uint32_t dwCount;
  struct NtWsansClassInfo *lpClassInfos;
};

struct NtWsaNetworkEvents {
  int32_t lNetworkEvents;
  int32_t iErrorCode[10];
};

struct NtTransmitFileBuffers {
  void *Head;
  uint32_t HeadLength;
  void *Tail;
  uint32_t TailLength;
};

typedef int (*NtConditionProc)(
    const struct NtIovec *lpCallerId, const struct NtIovec *lpCallerData,
    struct NtQos *inout_lpSQOS, struct NtQos *inout_lpGQOS,
    const struct NtIovec *lpCalleeId, const struct NtIovec *lpCalleeData,
    uint32_t *out_group, const uint32_t *dwCallbackData);

typedef void (*NtWsaOverlappedCompletionRoutine)(
    uint32_t dwError, uint32_t cbTransferred,
    const struct NtOverlapped *lpOverlapped, uint32_t dwFlags);

struct NtWsaCompletion {
  int Type;
  union {
    struct {
      int64_t hWnd;
      uint32_t uMsg;
      uintptr_t context;
    } WindowMessage;
    struct {
      struct NtOverlapped *lpOverlapped;
    } Event;
    struct {
      struct NtOverlapped *lpOverlapped;
      NtWsaOverlappedCompletionRoutine lpfnCompletionProc;
    } Apc;
    struct {
      struct NtOverlapped *lpOverlapped;
      int64_t hPort;
      uint32_t Key;
    } Port;
  } Parameters;
};

struct NtFdSet {
  uint32_t fd_count;
  int64_t fd_array[64];
};

/**
 * Winsock2 prototypes.
 *
 * @note Some of the functions exported by WS2_32.DLL, e.g. bind(),
 *       overlap with the names used by System V. Prototypes for these
 *       functions are declared within their respective wrappers.
 */

int32_t WSAStartup(uint16_t wVersionRequested, struct NtWsaData *lpWSAData)
    paramsnonnull() nodiscard;

int WSACleanup(void);
int WSAGetLastError(void);
void WSASetLastError(int);

int __sys_bind_nt(uint64_t, const void *, int);
int __sys_closesocket_nt(uint64_t);
int __sys_getpeername_nt(uint64_t, void *, uint32_t *);
int __sys_getsockname_nt(uint64_t, void *, uint32_t *);
int __sys_getsockopt_nt(uint64_t, int, int, void *, uint32_t *);
int __sys_ioctlsocket_nt(uint64_t, int32_t, uint32_t *);
int __sys_listen_nt(uint64_t, int);
int __sys_setsockopt_nt(uint64_t, int, int, const void *, int);
int __sys_shutdown_nt(uint64_t, int);
int __sys_select_nt(int, struct NtFdSet *, struct NtFdSet *, struct NtFdSet *,
                    struct NtTimeval *);

uint64_t WSASocket(int af, int type, int protocol,
                   const struct NtWsaProtocolInfo *opt_lpProtocolInfo,
                   const uint32_t opt_group, uint32_t dwFlags) nodiscard;

int WSAConnect(uint64_t s, const struct sockaddr *name, const int namelen,
               const struct NtIovec *opt_lpCallerData,
               struct NtIovec *opt_out_lpCalleeData,
               const struct NtQos *opt_lpSQOS, const struct NtQos *opt_lpGQOS)
    paramsnonnull((2));

bool32 WSAConnectByName(uint64_t s, const char16_t *nodename,
                        const char16_t *servicename,
                        uint32_t *opt_inout_LocalAddressLength,
                        struct sockaddr *out_LocalAddress,
                        uint32_t *opt_inout_RemoteAddressLength,
                        struct sockaddr *out_RemoteAddress,
                        const struct NtTimeval *opt_timeout,
                        struct NtOverlapped *__Reserved) paramsnonnull((2, 3));

bool32 WSAConnectByList(uint64_t s,
                        const struct NtSocketAddressList *SocketAddress,
                        uint32_t *opt_inout_LocalAddressLength,
                        struct sockaddr *out_LocalAddress,
                        uint32_t *opt_inout_RemoteAddressLength,
                        struct sockaddr *out_RemoteAddress,
                        const struct NtTimeval *opt_timeout,
                        struct NtOverlapped *__Reserved) paramsnonnull((2));

int64_t WSAAccept(uint64_t s, struct sockaddr *out_addr,
                  int32_t *opt_inout_addrlen,
                  const NtConditionProc opt_lpfnCondition,
                  const uint32_t *opt_dwCallbackData)
    paramsnonnull((2)) nodiscard;

int WSASend(uint64_t s, const struct NtIovec *lpBuffers, uint32_t dwBufferCount,
            uint32_t *opt_out_lpNumberOfBytesSent, uint32_t dwFlags,
            struct NtOverlapped *opt_inout_lpOverlapped,
            const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2));

int WSASendMsg(int64_t Handle, const struct NtMsgHdr *lpMsg, uint32_t dwFlags,
               uint32_t *opt_out_lpNumberOfBytesSent,
               struct NtOverlapped *opt_inout_lpOverlapped,
               const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2));

int WSASendTo(uint64_t s, const struct NtIovec *lpBuffers,
              uint32_t dwBufferCount,
              uint32_t *opt_out_lpNumberOfBytesSent /* opt if !overlapped */,
              uint32_t dwFlags, const void *opt_tosockaddr,
              int32_t tosockaddrlen,
              struct NtOverlapped *opt_inout_lpOverlapped,
              const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2));

int WSAPoll(struct sys_pollfd_nt *inout_fdArray, uint32_t nfds,
            signed timeout_ms) paramsnonnull();

int WSARecv(uint64_t s, const struct NtIovec *out_lpBuffers,
            uint32_t dwBufferCount, uint32_t *opt_out_lpNumberOfBytesRecvd,
            uint32_t *inout_lpFlags,
            struct NtOverlapped *opt_inout_lpOverlapped,
            const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2, 5));

int WSARecvFrom(uint64_t s, const struct NtIovec *out_lpBuffers,
                uint32_t dwBufferCount, uint32_t *opt_out_lpNumberOfBytesRecvd,
                uint32_t *inout_lpFlags, void *out_fromsockaddr,
                uint32_t *inout_fromsockaddrlen,
                struct NtOverlapped *opt_inout_lpOverlapped,
                const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((2, 5));

int WSARecvDisconnect(uint64_t s,
                      const struct NtIovec *opt_lpInboundDisconnectData);

int WSADuplicateSocket(uint64_t s, uint32_t dwProcessId,
                       struct NtWsaProtocolInfo *out_lpProtocolInfo)
    paramsnonnull((3));

int WSAIoctl(uint64_t s, uint32_t dwIoControlCode, const void *lpvInBuffer,
             uint32_t cbInBuffer, void *out_lpvOutBuffer, uint32_t cbOutBuffer,
             uint32_t *out_lpcbBytesReturned,
             struct NtOverlapped *opt_inout_lpOverlapped,
             const NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((5, 7));

int WSANSPIoctl(int64_t hLookup, uint32_t dwControlCode,
                const void *lpvInBuffer, uint32_t cbInBuffer,
                void *out_lpvOutBuffer, uint32_t cbOutBuffer,
                uint32_t *out_lpcbBytesReturned,
                const struct NtWsaCompletion *opt_lpCompletion)
    paramsnonnull((3, 5, 7));

int64_t WSACreateEvent(void) nodiscard;
bool32 WSACloseEvent(const int64_t hEvent);
bool32 WSAResetEvent(const int64_t hEvent);
bool32 WSASetEvent(const int64_t hEvent);

int WSAEventSelect(uint64_t s, const int64_t opt_hEventObject,
                   long lNetworkEvents);

uint32_t WSAWaitForMultipleEvents(uint32_t cEvents, const int64_t *lphEvents,
                                  bool32 fWaitAll, uint32_t dwTimeout_ms,
                                  bool32 fAlertable) paramsnonnull();

int WSAEnumNetworkEvents(uint64_t s, const int64_t hEventObject,
                         struct NtWsaNetworkEvents *out_lpNetworkEvents)
    paramsnonnull();

bool32 WSAGetOverlappedResult(uint64_t s,
                              const struct NtOverlapped *lpOverlapped,
                              uint32_t *out_lpcbTransfer, bool32 fWait,
                              uint32_t *out_lpdwFlags) paramsnonnull();

int WSAEnumProtocols(const int32_t *opt_lpiProtocols,
                     struct NtWsaProtocolInfo *out_lpProtocolBuffer,
                     uint32_t *inout_lpdwBufferLength) paramsnonnull();

bool32 WSAGetQOSByName(uint64_t s, const struct NtIovec *lpQOSName,
                       struct NtQos *out_lpQOS) paramsnonnull();

uint64_t WSAJoinLeaf(uint64_t s, const struct sockaddr *name, const int namelen,
                     const struct NtIovec *opt_lpCallerData,
                     struct NtIovec *opt_out_lpCalleeData,
                     const struct NtQos *opt_lpSQOS,
                     const struct NtQos *opt_lpGQOS, uint32_t dwFlags)
    paramsnonnull((2, 4));

int WSALookupServiceBegin(const struct NtWsaQuerySet *lpqsRestrictions,
                          uint32_t dwControlFlags, int64_t *out_lphLookup)
    paramsnonnull();

int WSALookupServiceNext(const int64_t hLookup, uint32_t dwControlFlags,
                         uint32_t *inout_lpdwBufferLength,
                         struct NtWsaQuerySet *out_lpqsResults) paramsnonnull();

int WSALookupServiceEnd(int64_t hLookup);

int WSAAddressToString(const struct sockaddr *lpsaAddress,
                       uint32_t dwAddressLength,
                       const struct NtWsaProtocolInfo *opt_lpProtocolInfo,
                       char16_t *out_lpszAddressString,
                       uint32_t *inout_lpdwAddressStringLength)
    paramsnonnull((1, 4, 5));

int WSAStringToAddress(const char16_t *AddressString, int AddressFamily,
                       const struct NtWsaProtocolInfo *opt_lpProtocolInfo,
                       struct sockaddr *out_lpAddress,
                       int *inout_lpAddressLength) paramsnonnull((1, 3, 4));

int WSAEnumNameSpaceProvidersEx(uint32_t *inout_lpdwBufferLength,
                                struct NtWsaNamespaceInfoEx *out_lpnspBuffer)
    paramsnonnull();

int WSAProviderConfigChange(
    int64_t *inout_lpNotificationHandle,
    struct NtOverlapped *opt_inout_lpOverlapped,
    NtWsaOverlappedCompletionRoutine opt_lpCompletionRoutine)
    paramsnonnull((1));

int WSAInstallServiceClass(
    const struct NtWsaServiceClassInfo *lpServiceClassInfo) paramsnonnull();

int WSARemoveServiceClass(const struct NtGuid *lpServiceClassId)
    paramsnonnull();

int WSAGetServiceClassInfo(const struct NtGuid *lpProviderId,
                           const struct NtGuid *lpServiceClassId,
                           uint32_t *inout_lpdwBufSize,
                           struct NtWsaServiceClassInfo *out_lpServiceClassInfo)
    paramsnonnull((1, 2, 3));

int WSASetService(const struct NtWsaQuerySet *lpqsRegInfo, int essoperation,
                  uint32_t dwControlFlags) paramsnonnull();

int /* success==0 */ WSAGetServiceClassNameByClassId(
    const struct NtGuid *lpServiceClassId, char16_t *out_lpszServiceClassName,
    uint32_t *inout_lpdwBufferLength) paramsnonnull();

bool32 TransmitFile(int64_t hSocket, int64_t hFile,
                    uint32_t opt_nNumberOfBytesToWrite,
                    uint32_t opt_nNumberOfBytesPerSend,
                    struct NtOverlapped *opt_inout_lpOverlapped,
                    const struct NtTransmitFileBuffers *opt_lpTransmitBuffers,
                    uint32_t dwReserved);

bool32 AcceptEx(int64_t sListenSocket, int64_t sAcceptSocket,
                void *out_lpOutputBuffer /*[recvlen+local+remoteaddrlen]*/,
                uint32_t dwReceiveDataLength, uint32_t dwLocalAddressLength,
                uint32_t dwRemoteAddressLength, uint32_t *out_lpdwBytesReceived,
                struct NtOverlapped *inout_lpOverlapped);

void GetAcceptExSockaddrs(
    const void *lpOutputBuffer /*[recvsize+addrsize+addrlen]*/,
    uint32_t dwReceiveDataLength, uint32_t dwLocalAddressLength,
    uint32_t dwRemoteAddressLength,
    struct sockaddr **out_LocalSockaddr /*[*LocalSockaddrLength]*/,
    int *out_LocalSockaddrLength,
    struct sockaddr **out_RemoteSockaddr /*[*RemoteSockaddrLength]*/,
    int *out_RemoteSockaddrLength);

bool32 ConnectEx(int64_t s, const struct sockaddr *name, int namelen,
                 const void *opt_lpSendBuffer, uint32_t dwSendDataLength,
                 uint32_t *out_lpdwBytesSent,
                 struct NtOverlapped *inout_lpOverlapped);

bool32 DisconnectEx(int64_t s, struct NtOverlapped *inout_opt_lpOverlapped,
                    uint32_t dwFlags, uint32_t dwReserved);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/ohmyplus/vector.h */

#define COSMOPOLITAN_LIBC_OHMYPLUS_VECTOR_H_
#ifdef __cplusplus
extern "C" {
void __vector_reserve(size_t, size_t, intptr_t **, size_t *);
} /* extern c */
namespace std {

template <class T>
class vector {
 public:
  vector() : data_(NULL), size_(0), toto_(0) {
  }
  vector(size_t n) : data_(NULL), size_(n), toto_(0) {
    VectorReserve(n);
  }
  size_t size() const {
    return size_;
  }
  size_t capacity() const {
    return toto_;
  }
  T &front() {
    return data_[0];
  }
  T &back() {
    return data_[size_ - 1];
  }
  void clear() {
    size_ = 0;
  }
  void reserve(size_t n) {
    VectorReserve(n);
  }
  void resize(size_t n) {
    reserve((size_ = n));
  }
  bool empty() const {
    return !size_;
  }
  T &operator[](size_t i) {
    return data_[i];
  }

 private:
  T *data_;
  size_t size_;
  size_t toto_;
  void VectorReserve(size_t n) {
    __vector_reserve(n, sizeof(T), (intptr_t **)&data_, &toto_);
  }
};

};     /* namespace std */
#endif /* __cplusplus */


/*!BEGIN libc/rand/rand.h */

#define COSMOPOLITAN_LIBC_RAND_RAND_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § random                                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define RAND_MAX __INT_MAX__              /* only applies to rand() */
void srand(uint64_t) nothrow nocallback;  /* seeds rand() only      */
int rand(void) nothrow nocallback;        /* ≥0 unseeded lcg prng   */
uint32_t rand32(void) nothrow nocallback; /* random as possible rng */
uint64_t rand64(void) nothrow nocallback; /* random as possible rng */
double poz(double);                       /* verify our claims      */
double pochisq(double, int);
void rt_init(int);
void rt_add(void *, int);
void rt_end(double *, double *, double *, double *, double *);
void *rngset(void *, size_t, uint64_t (*)(void), size_t) paramsnonnull();
char *strfry(char *);
int getentropy(void *, size_t);
ssize_t getrandom(void *, size_t, unsigned);
int devrand(void *, size_t);
int64_t winrandish(void);
uint64_t rdrand(void);
uint64_t rdseed(void);
float randf(void);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/rand/xorshift.h */

#define COSMOPOLITAN_LIBC_RAND_XORSHIFT_H_

#define kMarsagliaXorshift64Seed 88172645463325252
#define kMarsagliaXorshift32Seed 2463534242

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint32_t MarsagliaXorshift32(uint32_t[hasatleast 1]);
uint64_t MarsagliaXorshift64(uint64_t[hasatleast 1]);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/buffer.h */

#define COSMOPOLITAN_LIBC_RUNTIME_BUFFER_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct GuardedBuffer {
  void *p;
};

void *balloc(struct GuardedBuffer *, unsigned, size_t);
void bfree(struct GuardedBuffer *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/carsort.h */

#define COSMOPOLITAN_LIBC_RUNTIME_CARSORT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

void carsort100(size_t, int32_t (*)[2]) paramsnonnull() nocallback nothrow;
void carsort1000(size_t, int32_t (*)[2]) paramsnonnull() nocallback nothrow;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/directmap.h */

#define COSMOPOLITAN_LIBC_RUNTIME_DIRECTMAP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct DirectMap {
  void *addr;
  int64_t maphandle;
};

struct DirectMap __mmap(void *, size_t, int, int, int, int64_t);
struct DirectMap sys_mmap_nt(void *, size_t, int, int, int64_t, int64_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/gc.h */

#define COSMOPOLITAN_LIBC_RUNTIME_GC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview Cosmopolitan Return-Oriented Garbage Collector.
 *
 * This is the same thing as {@code std::unique_ptr<>} in C++ or the
 * {@code defer} keyword in Go. We harness the power of ROP for good
 * using very few lines of code.
 */

/**
 * Releases resource when function returns.
 *
 * @warning do not return a gc()'d pointer
 * @warning do not realloc() with gc()'d pointer
 */
#define gc(THING) defer((void *)weakfree, (void *)(THING))

/**
 * Same as longjmp() but runs gc() / defer() destructors.
 */
void gclongjmp(jmp_buf, int) nothrow wontreturn paramsnonnull();

/**
 * Calls FN(ARG) when function returns.
 */
#ifndef __VSCODE_INTELLISENSE__
#define defer(FN, ARG)                                                 \
  ({                                                                   \
    autotype(ARG) Arg = (ARG);                                         \
    /* prevent weird opts like tail call */                            \
    asm volatile("" : "+g"(Arg) : : "memory");                         \
    __defer((struct StackFrame *)__builtin_frame_address(0), FN, Arg); \
    asm volatile("" : "+g"(Arg) : : "memory");                         \
    Arg;                                                               \
  })
#endif /* __VSCODE_INTELLISENSE__ */

void __defer(struct StackFrame *, void *, void *) hidden paramsnonnull((1, 2));

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/interruptiblecall.h */

#define COSMOPOLITAN_LIBC_RUNTIME_INTERRUPTIBLECALL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct InterruptibleCall {
  struct InterruptibleCall *prev;
  intptr_t returnval;
  int sig;
  int flags;
  jmp_buf jb;
  struct sigaction sa_new;
  struct sigaction sa_old;
};

intptr_t interruptiblecall(struct InterruptibleCall *state,
                           intptr_t callback(intptr_t p1, intptr_t p2,
                                             intptr_t p3, intptr_t p4),
                           intptr_t p1, intptr_t p2, intptr_t p3, intptr_t p4);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/memtrack.h */

#define COSMOPOLITAN_LIBC_RUNTIME_MEMTRACK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define _kAutomapStart  0x0000100080000000 /* asan can't spread its poison */
#define _kAutomapSize   0x00000fff80000000 /* beyond the above mem address */
#define _kFixedmapStart 0x0000200000000000

/*
 * TODO: Why can't we allocate addresses above 4GB on Windows 7 x64?
 * https://github.com/jart/cosmopolitan/issues/19
 */
#define MEMTRACK_ADDRESS(NORMAL, WIN7) \
  (!(IsWindows() && NtGetVersion() < kNtVersionWindows10) ? NORMAL : WIN7)
#define kAutomapStart  MEMTRACK_ADDRESS(_kAutomapStart, 0x10000000)
#define kAutomapSize   MEMTRACK_ADDRESS(_kAutomapSize, 0x40000000)
#define kFixedmapStart MEMTRACK_ADDRESS(_kFixedmapStart, 0x40000000)

struct MemoryIntervals {
  long i;
  struct MemoryInterval {
    int x;
    int y;
    long h;
    int prot;
    int flags;
  } p[128];
};

extern struct MemoryIntervals _mmi;

unsigned FindMemoryInterval(const struct MemoryIntervals *, int) nosideeffect;
bool AreMemoryIntervalsOk(const struct MemoryIntervals *) nosideeffect;
void PrintMemoryIntervals(int, const struct MemoryIntervals *);
int TrackMemoryInterval(struct MemoryIntervals *, int, int, long, int, int);
int ReleaseMemoryIntervals(struct MemoryIntervals *, int, int,
                           void (*)(struct MemoryIntervals *, int, int));
void ReleaseMemoryNt(struct MemoryIntervals *, int, int);
int UntrackMemoryIntervals(void *, size_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/runtime/sysconf.h */

#define COSMOPOLITAN_LIBC_RUNTIME_SYSCONF_H_


/*!BEGIN libc/sysv/consts/auxv.h */

#define COSMOPOLITAN_LIBC_CALLS_AUXV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long AT_BASE;
extern const long AT_BASE_PLATFORM;
extern const long AT_CLKTCK;
extern const long AT_DCACHEBSIZE;
extern const long AT_EGID;
extern const long AT_ENTRY;
extern const long AT_EUID;
extern const long AT_EXECFD;
extern const long AT_EXECFN;
extern const long AT_GID;
extern const long AT_ICACHEBSIZE;
extern const long AT_NOTELF;
extern const long AT_NO_AUTOMOUNT;
extern const long AT_OSRELDATE;
extern const long AT_PAGESZ;
extern const long AT_PHDR;
extern const long AT_PHENT;
extern const long AT_PHNUM;
extern const long AT_PLATFORM;
extern const long AT_RANDOM;
extern const long AT_SECURE;
extern const long AT_SYSINFO_EHDR;
extern const long AT_UCACHEBSIZE;
extern const long AT_UID;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define AT_BASE          SYMBOLIC(AT_BASE)
#define AT_BASE_PLATFORM SYMBOLIC(AT_BASE_PLATFORM)
#define AT_CLKTCK        SYMBOLIC(AT_CLKTCK)
#define AT_DCACHEBSIZE   SYMBOLIC(AT_DCACHEBSIZE)
#define AT_EGID          SYMBOLIC(AT_EGID)
#define AT_ENTRY         SYMBOLIC(AT_ENTRY)
#define AT_EUID          SYMBOLIC(AT_EUID)
#define AT_EXECFD        SYMBOLIC(AT_EXECFD)
#define AT_EXECFN        SYMBOLIC(AT_EXECFN)
#define AT_GID           SYMBOLIC(AT_GID)
#define AT_ICACHEBSIZE   SYMBOLIC(AT_ICACHEBSIZE)
#define AT_NOTELF        SYMBOLIC(AT_NOTELF)
#define AT_NO_AUTOMOUNT  SYMBOLIC(AT_NO_AUTOMOUNT)
#define AT_OSRELDATE     SYMBOLIC(AT_OSRELDATE)
#define AT_PAGESZ        SYMBOLIC(AT_PAGESZ)
#define AT_PHDR          SYMBOLIC(AT_PHDR)
#define AT_PHENT         SYMBOLIC(AT_PHENT)
#define AT_PHNUM         SYMBOLIC(AT_PHNUM)
#define AT_PLATFORM      SYMBOLIC(AT_PLATFORM)
#define AT_RANDOM        SYMBOLIC(AT_RANDOM)
#define AT_SECURE        SYMBOLIC(AT_SECURE)
#define AT_SYSINFO_EHDR  SYMBOLIC(AT_SYSINFO_EHDR)
#define AT_UCACHEBSIZE   SYMBOLIC(AT_UCACHEBSIZE)
#define AT_UID           SYMBOLIC(AT_UID)


#define _SC_ARG_MAX   0
#define _SC_CLK_TCK   2
#define _SC_PAGESIZE  30
#define _SC_PAGE_SIZE 30

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

long sysconf(int);

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define sysconf(X) __sysconf(X)
forceinline long __sysconf(int thing) {
  switch (thing) {
    case _SC_ARG_MAX:
      return ARG_MAX;
    case _SC_CLK_TCK: {
      extern const long __AT_CLKTCK asm("AT_CLKTCK");
      long res = getauxval(__AT_CLKTCK);
      if (!res) res = 100;
      return res;
    }
    case _SC_PAGESIZE:
      return FRAMESIZE;
    default:
      return -1;
  }
}
#endif /* GNU && !ANSI */

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/epoll.h */

#define COSMOPOLITAN_LIBC_SOCK_WEPOLL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef union epoll_data {
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
} epoll_data_t;

struct thatispacked epoll_event {
  uint32_t events;
  epoll_data_t data;
};

int epoll_create(int);
int epoll_create1(int);
int epoll_ctl(int, int, int, struct epoll_event *);
int epoll_wait(int, struct epoll_event *, int, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sock/select.h */

#define COSMOPOLITAN_LIBC_SOCK_SELECT_H_

#define FD_SETSIZE 1024 /* it's 64 on windows */

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef struct fd_set {
  uint64_t fds_bits[FD_SETSIZE / 64];
} fd_set;

#define FD_ISSET(FD, SET) (((SET)->fds_bits[(FD) >> 6] >> ((FD)&63)) & 1)
#define FD_SET(FD, SET)   ((SET)->fds_bits[(FD) >> 6] |= 1ull << ((FD)&63))
#define FD_CLR(FD, SET)   ((SET)->fds_bits[(FD) >> 6] &= ~(1ull << ((FD)&63)))
#define FD_ZERO(SET)      memset((SET)->fds_bits, 0, sizeof((SET)->fds_bits))

int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/stdio_ext.h */

#define COSMOPOLITAN_LIBC_STDIO_STDIO_EXT_H_

#define FSETLOCKING_QUERY    0
#define FSETLOCKING_INTERNAL 1
#define FSETLOCKING_BYCALLER 2

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

size_t __fbufsize(FILE *);
size_t __fpending(FILE *);
int __flbf(FILE *);
int __freadable(FILE *);
int __fwritable(FILE *);
int __freading(FILE *);
int __fwriting(FILE *);
int __fsetlocking(FILE *, int);
void _flushlbf(void);
void __fpurge(FILE *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/temp.h */

#define COSMOPOLITAN_LIBC_STDIO_TEMP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

nodiscard FILE *tmpfile(void);
nodiscard int mkstemp(char *);
nodiscard int mkostemp(char *, unsigned);
nodiscard int mkstemps(char *, int);
nodiscard int mkostemps(char *, int, unsigned);
nodiscard int mkostempsm(char *, int, unsigned, int);
compatfn char *mktemp(char *);

int mkostempsmi(char *, int, unsigned, uint64_t *, int,
                int (*)(const char *, int, ...)) hidden nodiscard;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/stdio/unlocked.h */

#define COSMOPOLITAN_LIBC_STDIO_UNLOCKED_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

int getc_unlocked(FILE *) paramsnonnull();
int getchar_unlocked(void);
int putc_unlocked(int, FILE *) paramsnonnull();
int putchar_unlocked(int);
void clearerr_unlocked(FILE *);
int feof_unlocked(FILE *);
int ferror_unlocked(FILE *);
int fileno_unlocked(FILE *);
int fflush_unlocked(FILE *);
int fgetc_unlocked(FILE *);
int fputc_unlocked(int, FILE *);
size_t fread_unlocked(void *, size_t, size_t, FILE *);
size_t fwrite_unlocked(const void *, size_t, size_t, FILE *);
char *fgets_unlocked(char *, int, FILE *);
int fputs_unlocked(const char *, FILE *);
wint_t getwc_unlocked(FILE *);
wint_t getwchar_unlocked(void);
wint_t fgetwc_unlocked(FILE *);
wint_t fputwc_unlocked(wchar_t, FILE *);
wint_t putwc_unlocked(wchar_t, FILE *);
wint_t putwchar_unlocked(wchar_t);
wchar_t *fgetws_unlocked(wchar_t *, int, FILE *);
int fputws_unlocked(const wchar_t *, FILE *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/highwayhash64.h */

#define COSMOPOLITAN_LIBC_STR_HIGHWAYHASH64_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint64_t HighwayHash64(const uint8_t *, size_t, const uint64_t[4]);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/thompike.h */

#define COSMOPOLITAN_LIBC_STR_THOMPIKE_H_

#define ThomPikeCont(x)     (((x)&0300) == 0200)
#define ThomPikeByte(x)     ((x) & (((1 << ThomPikeMsb(x)) - 1) | 3))
#define ThomPikeLen(x)      (7 - ThomPikeMsb(x))
#define ThomPikeMsb(x)      (((x)&0xff) < 252 ? bsr(~(x)&0xff) : 1)
#define ThomPikeMerge(x, y) ((x) << 6 | (y)&077)



/*!BEGIN libc/str/tpenc.h */

#define COSMOPOLITAN_LIBC_STR_TPENC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

uint64_t tpenc(int32_t) pureconst;

#ifndef __STRICT_ANSI__
#define tpenc(CODE)            \
  ({                           \
    long Edi, Buf;             \
    asm("call\ttpenc"          \
        : "=a"(Buf), "=D"(Edi) \
        : "1"(CODE)            \
        : "rcx", "rdx", "cc"); \
    Buf;                       \
  })
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/undeflate.h */

#define COSMOPOLITAN_LIBC_STR_UNDEFLATE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct DeflateState {
  uint8_t lenlens[19];
  uint32_t lencodes[19];
  uint32_t distcodes[32];
  uint32_t litcodes[288];
  uint8_t lens[288 + 32];
};

ssize_t undeflate(void *output, size_t outputsize, void *input,
                  size_t inputsize, struct DeflateState *ds);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/str/utf16.h */

#define COSMOPOLITAN_LIBC_STR_UTF16_H_

#define UTF16_MASK 0xfc00
#define UTF16_MOAR 0xd800 /* 0xD800..0xDBFF */
#define UTF16_CONT 0xdc00 /* 0xDC00..0xDBFF */

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define IsUcs2(wc)         (((wc)&UTF16_MASK) != UTF16_MOAR)
#define IsUtf16Cont(wc)    (((wc)&UTF16_MASK) == UTF16_CONT)
#define MergeUtf16(lo, hi) ((((lo)-0xD800) << 10) + ((hi)-0xDC00) + 0x10000)
#define EncodeUtf16(wc)                                    \
  (__builtin_expect(((0x0000 <= (wc) && (wc) <= 0xFFFF) || \
                     (0xE000 <= (wc) && (wc) <= 0xFFFF)),  \
                    1)                                     \
       ? (wc)                                              \
       : 0x10000 <= (wc) && (wc) <= 0x10FFFF               \
             ? (((((wc)-0x10000) >> 10) + 0xD800) |        \
                ((((wc)-0x10000) & 1023) + 0xDC00) << 16)  \
             : 0xFFFD)

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/errfuns.h */

#define COSMOPOLITAN_LIBC_SYSV_ERRFUNS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * @fileoverview Optimized error return paths.
 *
 * Saying this:
 *
 *     return einval();
 *
 * Instead of this:
 *
 *     errno = EINVAL;
 *     return -1;
 *
 * Allows the compiler to generate 11 fewer bytes of code each time.
 *
 * @return always -1
 * @see libc/sysv/errfuns.inc (for implementation)
 */

intptr_t einval(void) relegated;
intptr_t eperm(void) relegated;
intptr_t enoent(void) relegated;
intptr_t esrch(void) relegated;
intptr_t eintr(void) relegated;
intptr_t eio(void) relegated;
intptr_t enxio(void) relegated;
intptr_t e2big(void) relegated;
intptr_t enoexec(void) relegated;
intptr_t ebadf(void) relegated;
intptr_t echild(void) relegated;
intptr_t eagain(void) relegated;
intptr_t enomem(void) relegated;
intptr_t eacces(void) relegated;
intptr_t efault(void) relegated;
intptr_t enotblk(void) relegated;
intptr_t ebusy(void) relegated;
intptr_t eexist(void) relegated;
intptr_t exdev(void) relegated;
intptr_t enodev(void) relegated;
intptr_t enotdir(void) relegated;
intptr_t eisdir(void) relegated;
intptr_t enfile(void) relegated;
intptr_t emfile(void) relegated;
intptr_t enotty(void) relegated;
intptr_t enotsup(void) relegated;
intptr_t etxtbsy(void) relegated;
intptr_t efbig(void) relegated;
intptr_t enospc(void) relegated;
intptr_t espipe(void) relegated;
intptr_t erofs(void) relegated;
intptr_t emlink(void) relegated;
intptr_t epipe(void) relegated;
intptr_t edom(void) relegated;
intptr_t erange(void) relegated;
intptr_t edeadlk(void) relegated;
intptr_t enametoolong(void) relegated;
intptr_t enolck(void) relegated;
intptr_t enosys(void) relegated;
intptr_t enotempty(void) relegated;
intptr_t eloop(void) relegated;
intptr_t enomsg(void) relegated;
intptr_t eidrm(void) relegated;
intptr_t echrng(void) relegated;
intptr_t el2nsync(void) relegated;
intptr_t el3hlt(void) relegated;
intptr_t el3rst(void) relegated;
intptr_t elnrng(void) relegated;
intptr_t eunatch(void) relegated;
intptr_t enocsi(void) relegated;
intptr_t el2hlt(void) relegated;
intptr_t ebade(void) relegated;
intptr_t ebadr(void) relegated;
intptr_t exfull(void) relegated;
intptr_t enoano(void) relegated;
intptr_t ebadrqc(void) relegated;
intptr_t ebadslt(void) relegated;
intptr_t enostr(void) relegated;
intptr_t enodata(void) relegated;
intptr_t etime(void) relegated;
intptr_t enosr(void) relegated;
intptr_t enonet(void) relegated;
intptr_t enopkg(void) relegated;
intptr_t eremote(void) relegated;
intptr_t enolink(void) relegated;
intptr_t eadv(void) relegated;
intptr_t esrmnt(void) relegated;
intptr_t ecomm(void) relegated;
intptr_t eproto(void) relegated;
intptr_t emultihop(void) relegated;
intptr_t edotdot(void) relegated;
intptr_t ebadmsg(void) relegated;
intptr_t eoverflow(void) relegated;
intptr_t enotuniq(void) relegated;
intptr_t ebadfd(void) relegated;
intptr_t eremchg(void) relegated;
intptr_t elibacc(void) relegated;
intptr_t elibbad(void) relegated;
intptr_t elibscn(void) relegated;
intptr_t elibmax(void) relegated;
intptr_t elibexec(void) relegated;
intptr_t eilseq(void) relegated;
intptr_t erestart(void) relegated;
intptr_t estrpipe(void) relegated;
intptr_t eusers(void) relegated;
intptr_t enotsock(void) relegated;
intptr_t edestaddrreq(void) relegated;
intptr_t emsgsize(void) relegated;
intptr_t eprototype(void) relegated;
intptr_t enoprotoopt(void) relegated;
intptr_t eprotonosupport(void) relegated;
intptr_t esocktnosupport(void) relegated;
intptr_t eopnotsupp(void) relegated;
intptr_t epfnosupport(void) relegated;
intptr_t eafnosupport(void) relegated;
intptr_t eaddrinuse(void) relegated;
intptr_t eaddrnotavail(void) relegated;
intptr_t enetdown(void) relegated;
intptr_t enetunreach(void) relegated;
intptr_t enetreset(void) relegated;
intptr_t econnaborted(void) relegated;
intptr_t econnreset(void) relegated;
intptr_t enobufs(void) relegated;
intptr_t eisconn(void) relegated;
intptr_t enotconn(void) relegated;
intptr_t eshutdown(void) relegated;
intptr_t etoomanyrefs(void) relegated;
intptr_t etimedout(void) relegated;
intptr_t econnrefused(void) relegated;
intptr_t ehostdown(void) relegated;
intptr_t ehostunreach(void) relegated;
intptr_t ealready(void) relegated;
intptr_t einprogress(void) relegated;
intptr_t estale(void) relegated;
intptr_t euclean(void) relegated;
intptr_t enotnam(void) relegated;
intptr_t enavail(void) relegated;
intptr_t eisnam(void) relegated;
intptr_t eremoteio(void) relegated;
intptr_t edquot(void) relegated;
intptr_t enomedium(void) relegated;
intptr_t emediumtype(void) relegated;
intptr_t ecanceled(void) relegated;
intptr_t enokey(void) relegated;
intptr_t ekeyexpired(void) relegated;
intptr_t ekeyrevoked(void) relegated;
intptr_t ekeyrejected(void) relegated;
intptr_t eownerdead(void) relegated;
intptr_t enotrecoverable(void) relegated;
intptr_t erfkill(void) relegated;
intptr_t ehwpoison(void) relegated;

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define __ERRFUN(FUNC)                              \
  ({                                                \
    intptr_t NegOne;                                \
    asm("call\t" FUNC : "=a"(NegOne), "=m"(errno)); \
    NegOne;                                         \
  })
#define einval()          __ERRFUN("einval")
#define eperm()           __ERRFUN("eperm")
#define enoent()          __ERRFUN("enoent")
#define esrch()           __ERRFUN("esrch")
#define eintr()           __ERRFUN("eintr")
#define eio()             __ERRFUN("eio")
#define enxio()           __ERRFUN("enxio")
#define e2big()           __ERRFUN("e2big")
#define enoexec()         __ERRFUN("enoexec")
#define ebadf()           __ERRFUN("ebadf")
#define echild()          __ERRFUN("echild")
#define eagain()          __ERRFUN("eagain")
#define enomem()          __ERRFUN("enomem")
#define eacces()          __ERRFUN("eacces")
#define efault()          __ERRFUN("efault")
#define enotblk()         __ERRFUN("enotblk")
#define ebusy()           __ERRFUN("ebusy")
#define eexist()          __ERRFUN("eexist")
#define exdev()           __ERRFUN("exdev")
#define enodev()          __ERRFUN("enodev")
#define enotdir()         __ERRFUN("enotdir")
#define eisdir()          __ERRFUN("eisdir")
#define enfile()          __ERRFUN("enfile")
#define emfile()          __ERRFUN("emfile")
#define enotty()          __ERRFUN("enotty")
#define enotsup()         __ERRFUN("enotsup")
#define etxtbsy()         __ERRFUN("etxtbsy")
#define efbig()           __ERRFUN("efbig")
#define enospc()          __ERRFUN("enospc")
#define espipe()          __ERRFUN("espipe")
#define erofs()           __ERRFUN("erofs")
#define emlink()          __ERRFUN("emlink")
#define epipe()           __ERRFUN("epipe")
#define edom()            __ERRFUN("edom")
#define erange()          __ERRFUN("erange")
#define edeadlk()         __ERRFUN("edeadlk")
#define enametoolong()    __ERRFUN("enametoolong")
#define enolck()          __ERRFUN("enolck")
#define enosys()          __ERRFUN("enosys")
#define enotempty()       __ERRFUN("enotempty")
#define eloop()           __ERRFUN("eloop")
#define enomsg()          __ERRFUN("enomsg")
#define eidrm()           __ERRFUN("eidrm")
#define echrng()          __ERRFUN("echrng")
#define el2nsync()        __ERRFUN("el2nsync")
#define el3hlt()          __ERRFUN("el3hlt")
#define el3rst()          __ERRFUN("el3rst")
#define elnrng()          __ERRFUN("elnrng")
#define eunatch()         __ERRFUN("eunatch")
#define enocsi()          __ERRFUN("enocsi")
#define el2hlt()          __ERRFUN("el2hlt")
#define ebade()           __ERRFUN("ebade")
#define ebadr()           __ERRFUN("ebadr")
#define exfull()          __ERRFUN("exfull")
#define enoano()          __ERRFUN("enoano")
#define ebadrqc()         __ERRFUN("ebadrqc")
#define ebadslt()         __ERRFUN("ebadslt")
#define enostr()          __ERRFUN("enostr")
#define enodata()         __ERRFUN("enodata")
#define etime()           __ERRFUN("etime")
#define enosr()           __ERRFUN("enosr")
#define enonet()          __ERRFUN("enonet")
#define enopkg()          __ERRFUN("enopkg")
#define eremote()         __ERRFUN("eremote")
#define enolink()         __ERRFUN("enolink")
#define eadv()            __ERRFUN("eadv")
#define esrmnt()          __ERRFUN("esrmnt")
#define ecomm()           __ERRFUN("ecomm")
#define eproto()          __ERRFUN("eproto")
#define emultihop()       __ERRFUN("emultihop")
#define edotdot()         __ERRFUN("edotdot")
#define ebadmsg()         __ERRFUN("ebadmsg")
#define eoverflow()       __ERRFUN("eoverflow")
#define enotuniq()        __ERRFUN("enotuniq")
#define ebadfd()          __ERRFUN("ebadfd")
#define eremchg()         __ERRFUN("eremchg")
#define elibacc()         __ERRFUN("elibacc")
#define elibbad()         __ERRFUN("elibbad")
#define elibscn()         __ERRFUN("elibscn")
#define elibmax()         __ERRFUN("elibmax")
#define elibexec()        __ERRFUN("elibexec")
#define eilseq()          __ERRFUN("eilseq")
#define erestart()        __ERRFUN("erestart")
#define estrpipe()        __ERRFUN("estrpipe")
#define eusers()          __ERRFUN("eusers")
#define enotsock()        __ERRFUN("enotsock")
#define edestaddrreq()    __ERRFUN("edestaddrreq")
#define emsgsize()        __ERRFUN("emsgsize")
#define eprototype()      __ERRFUN("eprototype")
#define enoprotoopt()     __ERRFUN("enoprotoopt")
#define eprotonosupport() __ERRFUN("eprotonosupport")
#define esocktnosupport() __ERRFUN("esocktnosupport")
#define eopnotsupp()      __ERRFUN("eopnotsupp")
#define epfnosupport()    __ERRFUN("epfnosupport")
#define eafnosupport()    __ERRFUN("eafnosupport")
#define eaddrinuse()      __ERRFUN("eaddrinuse")
#define eaddrnotavail()   __ERRFUN("eaddrnotavail")
#define enetdown()        __ERRFUN("enetdown")
#define enetunreach()     __ERRFUN("enetunreach")
#define enetreset()       __ERRFUN("enetreset")
#define econnaborted()    __ERRFUN("econnaborted")
#define econnreset()      __ERRFUN("econnreset")
#define enobufs()         __ERRFUN("enobufs")
#define eisconn()         __ERRFUN("eisconn")
#define enotconn()        __ERRFUN("enotconn")
#define eshutdown()       __ERRFUN("eshutdown")
#define etoomanyrefs()    __ERRFUN("etoomanyrefs")
#define etimedout()       __ERRFUN("etimedout")
#define econnrefused()    __ERRFUN("econnrefused")
#define ehostdown()       __ERRFUN("ehostdown")
#define ehostunreach()    __ERRFUN("ehostunreach")
#define ealready()        __ERRFUN("ealready")
#define einprogress()     __ERRFUN("einprogress")
#define estale()          __ERRFUN("estale")
#define euclean()         __ERRFUN("euclean")
#define enotnam()         __ERRFUN("enotnam")
#define enavail()         __ERRFUN("enavail")
#define eisnam()          __ERRFUN("eisnam")
#define eremoteio()       __ERRFUN("eremoteio")
#define edquot()          __ERRFUN("edquot")
#define enomedium()       __ERRFUN("enomedium")
#define emediumtype()     __ERRFUN("emediumtype")
#define ecanceled()       __ERRFUN("ecanceled")
#define enokey()          __ERRFUN("enokey")
#define ekeyexpired()     __ERRFUN("ekeyexpired")
#define ekeyrevoked()     __ERRFUN("ekeyrevoked")
#define ekeyrejected()    __ERRFUN("ekeyrejected")
#define eownerdead()      __ERRFUN("eownerdead")
#define enotrecoverable() __ERRFUN("enotrecoverable")
#define erfkill()         __ERRFUN("erfkill")
#define ehwpoison()       __ERRFUN("ehwpoison")
#endif

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/af.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_AF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long AF_ALG;
extern const long AF_APPLETALK;
extern const long AF_ASH;
extern const long AF_ATMPVC;
extern const long AF_ATMSVC;
extern const long AF_AX25;
extern const long AF_BLUETOOTH;
extern const long AF_BRIDGE;
extern const long AF_CAIF;
extern const long AF_CAN;
extern const long AF_ECONET;
extern const long AF_FILE;
extern const long AF_IB;
extern const long AF_IEEE802154;
extern const long AF_INET6;
extern const long AF_INET;
extern const long AF_IPX;
extern const long AF_IRDA;
extern const long AF_ISDN;
extern const long AF_IUCV;
extern const long AF_KCM;
extern const long AF_KEY;
extern const long AF_LLC;
extern const long AF_LOCAL;
extern const long AF_MAX;
extern const long AF_MPLS;
extern const long AF_NETBEUI;
extern const long AF_NETLINK;
extern const long AF_NETROM;
extern const long AF_NFC;
extern const long AF_PACKET;
extern const long AF_PHONET;
extern const long AF_PPPOX;
extern const long AF_RDS;
extern const long AF_ROSE;
extern const long AF_ROUTE;
extern const long AF_RXRPC;
extern const long AF_SECURITY;
extern const long AF_SNA;
extern const long AF_TIPC;
extern const long AF_UNIX;
extern const long AF_UNSPEC;
extern const long AF_VSOCK;
extern const long AF_WANPIPE;
extern const long AF_X25;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define AF_ALG SYMBOLIC(AF_ALG)
#define AF_APPLETALK SYMBOLIC(AF_APPLETALK)
#define AF_ASH SYMBOLIC(AF_ASH)
#define AF_ATMPVC SYMBOLIC(AF_ATMPVC)
#define AF_ATMSVC SYMBOLIC(AF_ATMSVC)
#define AF_AX25 SYMBOLIC(AF_AX25)
#define AF_BLUETOOTH SYMBOLIC(AF_BLUETOOTH)
#define AF_BRIDGE SYMBOLIC(AF_BRIDGE)
#define AF_CAIF SYMBOLIC(AF_CAIF)
#define AF_CAN SYMBOLIC(AF_CAN)
#define AF_ECONET SYMBOLIC(AF_ECONET)
#define AF_FILE SYMBOLIC(AF_FILE)
#define AF_IB SYMBOLIC(AF_IB)
#define AF_IEEE802154 SYMBOLIC(AF_IEEE802154)
#define AF_INET LITERALLY(2)
#define AF_INET6 SYMBOLIC(AF_INET6)
#define AF_IPX SYMBOLIC(AF_IPX)
#define AF_IRDA SYMBOLIC(AF_IRDA)
#define AF_ISDN SYMBOLIC(AF_ISDN)
#define AF_IUCV SYMBOLIC(AF_IUCV)
#define AF_KCM SYMBOLIC(AF_KCM)
#define AF_KEY SYMBOLIC(AF_KEY)
#define AF_LLC SYMBOLIC(AF_LLC)
#define AF_LOCAL SYMBOLIC(AF_LOCAL)
#define AF_MAX SYMBOLIC(AF_MAX)
#define AF_MPLS SYMBOLIC(AF_MPLS)
#define AF_NETBEUI SYMBOLIC(AF_NETBEUI)
#define AF_NETLINK SYMBOLIC(AF_NETLINK)
#define AF_NETROM SYMBOLIC(AF_NETROM)
#define AF_NFC SYMBOLIC(AF_NFC)
#define AF_PACKET SYMBOLIC(AF_PACKET)
#define AF_PHONET SYMBOLIC(AF_PHONET)
#define AF_PPPOX SYMBOLIC(AF_PPPOX)
#define AF_RDS SYMBOLIC(AF_RDS)
#define AF_ROSE SYMBOLIC(AF_ROSE)
#define AF_ROUTE SYMBOLIC(AF_ROUTE)
#define AF_RXRPC SYMBOLIC(AF_RXRPC)
#define AF_SECURITY SYMBOLIC(AF_SECURITY)
#define AF_SNA SYMBOLIC(AF_SNA)
#define AF_TIPC SYMBOLIC(AF_TIPC)
#define AF_UNIX LITERALLY(1)
#define AF_UNSPEC LITERALLY(0)
#define AF_VSOCK SYMBOLIC(AF_VSOCK)
#define AF_WANPIPE SYMBOLIC(AF_WANPIPE)
#define AF_X25 SYMBOLIC(AF_X25)



/*!BEGIN libc/sysv/consts/ai.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_AI_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long AI_ADDRCONFIG;
extern const long AI_ALL;
extern const long AI_CANONNAME;
extern const long AI_NUMERICHOST;
extern const long AI_NUMERICSERV;
extern const long AI_PASSIVE;
extern const long AI_V4MAPPED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define AI_ADDRCONFIG SYMBOLIC(AI_ADDRCONFIG)
#define AI_ALL SYMBOLIC(AI_ALL)
#define AI_CANONNAME LITERALLY(2)
#define AI_NUMERICHOST LITERALLY(4)
#define AI_NUMERICSERV SYMBOLIC(AI_NUMERICSERV)
#define AI_PASSIVE LITERALLY(1)
#define AI_V4MAPPED SYMBOLIC(AI_V4MAPPED)



/*!BEGIN libc/sysv/consts/arphrd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ARPHRD_H_

#define ARPHRD_ETHER SYMBOLIC(ARPHRD_ETHER)
#define ARPHRD_FCFABRIC SYMBOLIC(ARPHRD_FCFABRIC)
#define ARPHRD_IEEE80211 SYMBOLIC(ARPHRD_IEEE80211)
#define ARPHRD_IEEE80211_PRISM SYMBOLIC(ARPHRD_IEEE80211_PRISM)
#define ARPHRD_IEEE80211_RADIOTAP SYMBOLIC(ARPHRD_IEEE80211_RADIOTAP)
#define ARPHRD_IEEE802154 SYMBOLIC(ARPHRD_IEEE802154)
#define ARPHRD_IEEE802_TR SYMBOLIC(ARPHRD_IEEE802_TR)
#define ARPHRD_LOCALTLK SYMBOLIC(ARPHRD_LOCALTLK)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long ARPHRD_ETHER;
extern const long ARPHRD_FCFABRIC;
extern const long ARPHRD_IEEE80211;
extern const long ARPHRD_IEEE80211_PRISM;
extern const long ARPHRD_IEEE80211_RADIOTAP;
extern const long ARPHRD_IEEE802154;
extern const long ARPHRD_IEEE802_TR;
extern const long ARPHRD_LOCALTLK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/at.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_AT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview AT_xxx constants for fcntl(), fopenat(), etc..
 * @see libc/sysv/consts/auxv.h for getauxval() constants
 */

extern const long AT_FDCWD;
extern const long AT_SYMLINK_FOLLOW;
extern const long AT_SYMLINK_NOFOLLOW;
extern const long AT_REMOVEDIR;
extern const long AT_EACCESS;
extern const long AT_EMPTY_PATH;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define AT_FDCWD            SYMBOLIC(AT_FDCWD)
#define AT_SYMLINK_FOLLOW   SYMBOLIC(AT_SYMLINK_FOLLOW)
#define AT_SYMLINK_NOFOLLOW SYMBOLIC(AT_SYMLINK_NOFOLLOW)
#define AT_REMOVEDIR        SYMBOLIC(AT_REMOVEDIR)
#define AT_EACCESS          SYMBOLIC(AT_EACCESS)
#define AT_EMPTY_PATH       SYMBOLIC(AT_EMPTY_PATH)



/*!BEGIN libc/sysv/consts/blk.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_BLK_H_

#define BLK_BYTECOUNT SYMBOLIC(BLK_BYTECOUNT)
#define BLK_EOF SYMBOLIC(BLK_EOF)
#define BLK_EOR SYMBOLIC(BLK_EOR)
#define BLK_ERRORS SYMBOLIC(BLK_ERRORS)
#define BLK_RESTART SYMBOLIC(BLK_RESTART)

#define BLKBSZGET SYMBOLIC(BLKBSZGET)
#define BLKBSZSET SYMBOLIC(BLKBSZSET)
#define BLKFLSBUF SYMBOLIC(BLKFLSBUF)
#define BLKFRAGET SYMBOLIC(BLKFRAGET)
#define BLKFRASET SYMBOLIC(BLKFRASET)
#define BLKGETSIZE SYMBOLIC(BLKGETSIZE)
#define BLKGETSIZE64 SYMBOLIC(BLKGETSIZE64)
#define BLKRAGET SYMBOLIC(BLKRAGET)
#define BLKRASET SYMBOLIC(BLKRASET)
#define BLKROGET SYMBOLIC(BLKROGET)
#define BLKROSET SYMBOLIC(BLKROSET)
#define BLKRRPART SYMBOLIC(BLKRRPART)
#define BLKSECTGET SYMBOLIC(BLKSECTGET)
#define BLKSECTSET SYMBOLIC(BLKSECTSET)
#define BLKSSZGET SYMBOLIC(BLKSSZGET)
#define BLKTYPE SYMBOLIC(BLKTYPE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long BLK_BYTECOUNT;
extern const long BLK_EOF;
extern const long BLK_EOR;
extern const long BLK_ERRORS;
extern const long BLK_RESTART;

extern const long BLKBSZGET;
extern const long BLKBSZSET;
extern const long BLKFLSBUF;
extern const long BLKFRAGET;
extern const long BLKFRASET;
extern const long BLKGETSIZE64;
extern const long BLKGETSIZE;
extern const long BLKRAGET;
extern const long BLKRASET;
extern const long BLKROGET;
extern const long BLKROSET;
extern const long BLKRRPART;
extern const long BLKSECTGET;
extern const long BLKSECTSET;
extern const long BLKSSZGET;
extern const long BLKTYPE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/bus.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_BUS_H_

#define BUS_ADRALN SYMBOLIC(BUS_ADRALN)
#define BUS_ADRERR SYMBOLIC(BUS_ADRERR)
#define BUS_DEVICE_RESET SYMBOLIC(BUS_DEVICE_RESET)
#define BUS_MCEERR_AO SYMBOLIC(BUS_MCEERR_AO)
#define BUS_MCEERR_AR SYMBOLIC(BUS_MCEERR_AR)
#define BUS_OBJERR SYMBOLIC(BUS_OBJERR)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long BUS_ADRALN;
extern const long BUS_ADRERR;
extern const long BUS_DEVICE_RESET;
extern const long BUS_MCEERR_AO;
extern const long BUS_MCEERR_AR;
extern const long BUS_OBJERR;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/c.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_C_H_

#define C_IRGRP SYMBOLIC(C_IRGRP)
#define C_IROTH SYMBOLIC(C_IROTH)
#define C_IRUSR SYMBOLIC(C_IRUSR)
#define C_ISBLK SYMBOLIC(C_ISBLK)
#define C_ISCHR SYMBOLIC(C_ISCHR)
#define C_ISCTG SYMBOLIC(C_ISCTG)
#define C_ISDIR SYMBOLIC(C_ISDIR)
#define C_ISFIFO SYMBOLIC(C_ISFIFO)
#define C_ISGID SYMBOLIC(C_ISGID)
#define C_ISLNK SYMBOLIC(C_ISLNK)
#define C_ISREG SYMBOLIC(C_ISREG)
#define C_ISSOCK SYMBOLIC(C_ISSOCK)
#define C_ISUID SYMBOLIC(C_ISUID)
#define C_ISVTX SYMBOLIC(C_ISVTX)
#define C_IWGRP SYMBOLIC(C_IWGRP)
#define C_IWOTH SYMBOLIC(C_IWOTH)
#define C_IWUSR SYMBOLIC(C_IWUSR)
#define C_IXGRP SYMBOLIC(C_IXGRP)
#define C_IXOTH SYMBOLIC(C_IXOTH)
#define C_IXUSR SYMBOLIC(C_IXUSR)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long C_IRGRP;
extern const long C_IROTH;
extern const long C_IRUSR;
extern const long C_ISBLK;
extern const long C_ISCHR;
extern const long C_ISCTG;
extern const long C_ISDIR;
extern const long C_ISFIFO;
extern const long C_ISGID;
extern const long C_ISLNK;
extern const long C_ISREG;
extern const long C_ISSOCK;
extern const long C_ISUID;
extern const long C_ISVTX;
extern const long C_IWGRP;
extern const long C_IWOTH;
extern const long C_IWUSR;
extern const long C_IXGRP;
extern const long C_IXOTH;
extern const long C_IXUSR;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/cld.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_CLD_H_

#define CLD_CONTINUED SYMBOLIC(CLD_CONTINUED)
#define CLD_DUMPED SYMBOLIC(CLD_DUMPED)
#define CLD_EXITED SYMBOLIC(CLD_EXITED)
#define CLD_KILLED SYMBOLIC(CLD_KILLED)
#define CLD_STOPPED SYMBOLIC(CLD_STOPPED)
#define CLD_TRAPPED SYMBOLIC(CLD_TRAPPED)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long CLD_CONTINUED;
extern const long CLD_DUMPED;
extern const long CLD_EXITED;
extern const long CLD_KILLED;
extern const long CLD_STOPPED;
extern const long CLD_TRAPPED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/clock.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_CLOCK_H_

#define CLOCK_BOOTTIME SYMBOLIC(CLOCK_BOOTTIME)
#define CLOCK_BOOTTIME_ALARM SYMBOLIC(CLOCK_BOOTTIME_ALARM)
#define CLOCK_MONOTONIC SYMBOLIC(CLOCK_MONOTONIC)
#define CLOCK_MONOTONIC_COARSE SYMBOLIC(CLOCK_MONOTONIC_COARSE)
#define CLOCK_MONOTONIC_RAW SYMBOLIC(CLOCK_MONOTONIC_RAW)
#define CLOCK_PROCESS_CPUTIME_ID SYMBOLIC(CLOCK_PROCESS_CPUTIME_ID)
#define CLOCK_REALTIME SYMBOLIC(CLOCK_REALTIME)
#define CLOCK_REALTIME_ALARM SYMBOLIC(CLOCK_REALTIME_ALARM)
#define CLOCK_REALTIME_COARSE SYMBOLIC(CLOCK_REALTIME_COARSE)
#define CLOCK_TAI SYMBOLIC(CLOCK_TAI)
#define CLOCK_THREAD_CPUTIME_ID SYMBOLIC(CLOCK_THREAD_CPUTIME_ID)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long CLOCK_BOOTTIME;
extern const long CLOCK_BOOTTIME_ALARM;
extern const long CLOCK_MONOTONIC;
extern const long CLOCK_MONOTONIC_COARSE;
extern const long CLOCK_MONOTONIC_RAW;
extern const long CLOCK_PROCESS_CPUTIME_ID;
extern const long CLOCK_REALTIME;
extern const long CLOCK_REALTIME_ALARM;
extern const long CLOCK_REALTIME_COARSE;
extern const long CLOCK_TAI;
extern const long CLOCK_THREAD_CPUTIME_ID;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/dt.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_DT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long DT_UNKNOWN;
extern const long DT_FIFO;
extern const long DT_CHR;
extern const long DT_DIR;
extern const long DT_BLK;
extern const long DT_REG;
extern const long DT_LNK;
extern const long DT_SOCK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define DT_UNKNOWN LITERALLY(0)
#define DT_FIFO    LITERALLY(1)
#define DT_CHR     LITERALLY(2)
#define DT_DIR     LITERALLY(4)
#define DT_BLK     LITERALLY(6)
#define DT_REG     LITERALLY(8)
#define DT_LNK     LITERALLY(10)
#define DT_SOCK    LITERALLY(12)



/*!BEGIN libc/sysv/consts/eai.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_EAI_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long EAI_ADDRFAMILY;
extern const long EAI_AGAIN;
extern const long EAI_ALLDONE;
extern const long EAI_BADFLAGS;
extern const long EAI_CANCELED;
extern const long EAI_FAIL;
extern const long EAI_FAMILY;
extern const long EAI_IDN_ENCODE;
extern const long EAI_INPROGRESS;
extern const long EAI_INTR;
extern const long EAI_MEMORY;
extern const long EAI_NODATA;
extern const long EAI_NONAME;
extern const long EAI_NOTCANCELED;
extern const long EAI_OVERFLOW;
extern const long EAI_SERVICE;
extern const long EAI_SOCKTYPE;
extern const long EAI_SYSTEM;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define EAI_ADDRFAMILY SYMBOLIC(EAI_ADDRFAMILY)
#define EAI_AGAIN SYMBOLIC(EAI_AGAIN)
#define EAI_ALLDONE SYMBOLIC(EAI_ALLDONE)
#define EAI_BADFLAGS SYMBOLIC(EAI_BADFLAGS)
#define EAI_CANCELED SYMBOLIC(EAI_CANCELED)
#define EAI_FAIL SYMBOLIC(EAI_FAIL)
#define EAI_FAMILY SYMBOLIC(EAI_FAMILY)
#define EAI_IDN_ENCODE SYMBOLIC(EAI_IDN_ENCODE)
#define EAI_INPROGRESS SYMBOLIC(EAI_INPROGRESS)
#define EAI_INTR SYMBOLIC(EAI_INTR)
#define EAI_MEMORY SYMBOLIC(EAI_MEMORY)
#define EAI_NODATA SYMBOLIC(EAI_NODATA)
#define EAI_NONAME SYMBOLIC(EAI_NONAME)
#define EAI_NOTCANCELED SYMBOLIC(EAI_NOTCANCELED)
#define EAI_OVERFLOW SYMBOLIC(EAI_OVERFLOW)
#define EAI_SERVICE SYMBOLIC(EAI_SERVICE)
#define EAI_SOCKTYPE SYMBOLIC(EAI_SOCKTYPE)
#define EAI_SUCCESS LITERALLY(0)
#define EAI_SYSTEM SYMBOLIC(EAI_SYSTEM)



/*!BEGIN libc/sysv/consts/epoll.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_EPOLL_H_


/*!BEGIN libc/sysv/consts/o.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_O_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long O_ACCMODE;
extern const long O_APPEND;
extern const long O_ASYNC;
extern const long O_CLOEXEC;
extern const long O_CREAT;
extern const long O_DIRECT;
extern const long O_DIRECTORY;
extern const long O_DSYNC;
extern const long O_EXCL;
extern const long O_EXEC;
extern const long O_LARGEFILE;
extern const long O_NDELAY;
extern const long O_NOATIME;
extern const long O_NOCTTY;
extern const long O_NOFOLLOW;
extern const long O_NONBLOCK;
extern const long O_PATH;
extern const long O_RDONLY;
extern const long O_RDWR;
extern const long O_RSYNC;
extern const long O_SPARSE;
extern const long O_SYNC;
extern const long O_TMPFILE;
extern const long O_TRUNC;
extern const long O_TTY_INIT;
extern const long O_WRONLY;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define O_ACCMODE SYMBOLIC(O_ACCMODE)
#define O_APPEND SYMBOLIC(O_APPEND)
#define O_ASYNC SYMBOLIC(O_ASYNC)
#define O_CLOEXEC SYMBOLIC(O_CLOEXEC)
#define O_CREAT SYMBOLIC(O_CREAT)
#define O_DIRECT SYMBOLIC(O_DIRECT)
#define O_DIRECTORY SYMBOLIC(O_DIRECTORY)
#define O_DSYNC SYMBOLIC(O_DSYNC)
#define O_EXCL SYMBOLIC(O_EXCL)
#define O_EXEC SYMBOLIC(O_EXEC)
#define O_LARGEFILE SYMBOLIC(O_LARGEFILE)
#define O_NDELAY SYMBOLIC(O_NDELAY)
#define O_NOATIME SYMBOLIC(O_NOATIME)
#define O_NOCTTY SYMBOLIC(O_NOCTTY)
#define O_NOFOLLOW SYMBOLIC(O_NOFOLLOW)
#define O_NONBLOCK SYMBOLIC(O_NONBLOCK)
#define O_PATH SYMBOLIC(O_PATH)
#define O_RDONLY SYMBOLIC(O_RDONLY)
#define O_RDWR SYMBOLIC(O_RDWR)
#define O_RSYNC SYMBOLIC(O_RSYNC)
#define O_SPARSE SYMBOLIC(O_SPARSE)
#define O_SYNC SYMBOLIC(O_SYNC)
#define O_TMPFILE SYMBOLIC(O_TMPFILE)
#define O_TRUNC SYMBOLIC(O_TRUNC)
#define O_TTY_INIT SYMBOLIC(O_TTY_INIT)
#define O_WRONLY SYMBOLIC(O_WRONLY)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long EPOLL_CLOEXEC;

extern const long EPOLL_CTL_ADD;
extern const long EPOLL_CTL_DEL;
extern const long EPOLL_CTL_MOD;

extern const long EPOLLIN;
extern const long EPOLLPRI;
extern const long EPOLLOUT;
extern const long EPOLLERR;
extern const long EPOLLHUP;
extern const long EPOLLRDNORM;
extern const long EPOLLRDBAND;
extern const long EPOLLWRNORM;
extern const long EPOLLWRBAND;
extern const long EPOLLMSG;
extern const long EPOLLRDHUP;
extern const long EPOLLEXCLUSIVE;
extern const long EPOLLWAKEUP;
extern const long EPOLLONESHOT;
extern const long EPOLLET;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define EPOLL_CLOEXEC O_CLOEXEC

#define EPOLL_CTL_ADD LITERALLY(1)
#define EPOLL_CTL_DEL LITERALLY(2)
#define EPOLL_CTL_MOD LITERALLY(3)

#define EPOLLIN        LITERALLY(1)
#define EPOLLPRI       LITERALLY(2)
#define EPOLLOUT       LITERALLY(4)
#define EPOLLERR       LITERALLY(8)
#define EPOLLHUP       LITERALLY(0x10)
#define EPOLLRDNORM    LITERALLY(0x40)
#define EPOLLRDBAND    LITERALLY(0x80)
#define EPOLLWRNORM    LITERALLY(0x0100)
#define EPOLLWRBAND    LITERALLY(0x0200)
#define EPOLLMSG       LITERALLY(0x0400)
#define EPOLLRDHUP     LITERALLY(0x2000)
#define EPOLLEXCLUSIVE LITERALLY(0x10000000)
#define EPOLLWAKEUP    LITERALLY(0x20000000)
#define EPOLLONESHOT   LITERALLY(0x40000000)
#define EPOLLET        LITERALLY(0x80000000)



/*!BEGIN libc/sysv/consts/eth.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ETH_H_

#define ETH_P_CUST SYMBOLIC(ETH_P_CUST)
#define ETH_P_DDCMP SYMBOLIC(ETH_P_DDCMP)
#define ETH_P_DEC SYMBOLIC(ETH_P_DEC)
#define ETH_P_DIAG SYMBOLIC(ETH_P_DIAG)
#define ETH_P_DNA_DL SYMBOLIC(ETH_P_DNA_DL)
#define ETH_P_DNA_RC SYMBOLIC(ETH_P_DNA_RC)
#define ETH_P_DNA_RT SYMBOLIC(ETH_P_DNA_RT)
#define ETH_P_IEEE802154 SYMBOLIC(ETH_P_IEEE802154)
#define ETH_P_LAT SYMBOLIC(ETH_P_LAT)
#define ETH_P_LOCALTALK SYMBOLIC(ETH_P_LOCALTALK)
#define ETH_P_PPP_MP SYMBOLIC(ETH_P_PPP_MP)
#define ETH_P_RARP SYMBOLIC(ETH_P_RARP)
#define ETH_P_SCA SYMBOLIC(ETH_P_SCA)
#define ETH_P_WAN_PPP SYMBOLIC(ETH_P_WAN_PPP)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long ETH_P_CUST;
extern const long ETH_P_DDCMP;
extern const long ETH_P_DEC;
extern const long ETH_P_DIAG;
extern const long ETH_P_DNA_DL;
extern const long ETH_P_DNA_RC;
extern const long ETH_P_DNA_RT;
extern const long ETH_P_IEEE802154;
extern const long ETH_P_LAT;
extern const long ETH_P_LOCALTALK;
extern const long ETH_P_PPP_MP;
extern const long ETH_P_RARP;
extern const long ETH_P_SCA;
extern const long ETH_P_WAN_PPP;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/ex.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_EX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long EX_CANTCREAT;
extern const long EX_CONFIG;
extern const long EX_DATAERR;
extern const long EX_IOERR;
extern const long EX_NOHOST;
extern const long EX_NOINPUT;
extern const long EX_NOPERM;
extern const long EX_NOUSER;
extern const long EX_OK;
extern const long EX_OSERR;
extern const long EX_OSFILE;
extern const long EX_PROTOCOL;
extern const long EX_SOFTWARE;
extern const long EX_TEMPFAIL;
extern const long EX_UNAVAILABLE;
extern const long EX_USAGE;
extern const long EX__BASE;
extern const long EX__MAX;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define EX_CANTCREAT LITERALLY(73)
#define EX_CONFIG LITERALLY(78)
#define EX_DATAERR LITERALLY(65)
#define EX_IOERR LITERALLY(74)
#define EX_NOHOST LITERALLY(68)
#define EX_NOINPUT LITERALLY(66)
#define EX_NOPERM LITERALLY(77)
#define EX_NOUSER LITERALLY(67)
#define EX_OK LITERALLY(0)
#define EX_OSERR LITERALLY(71)
#define EX_OSFILE LITERALLY(72)
#define EX_PROTOCOL LITERALLY(76)
#define EX_SOFTWARE LITERALLY(70)
#define EX_TEMPFAIL LITERALLY(75)
#define EX_UNAVAILABLE LITERALLY(69)
#define EX_USAGE LITERALLY(64)
#define EX__BASE LITERALLY(64)
#define EX__MAX LITERALLY(78)



/*!BEGIN libc/sysv/consts/exit.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_EXIT_H_

#define EXIT_FAILURE SYMBOLIC(EXIT_FAILURE)
#define EXIT_SUCCESS SYMBOLIC(EXIT_SUCCESS)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long EXIT_FAILURE;
extern const long EXIT_SUCCESS;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/falloc.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FALLOC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long FALLOC_FL_KEEP_SIZE;
extern const long FALLOC_FL_PUNCH_HOLE;
extern const long FALLOC_FL_NO_HIDE_STALE;
extern const long FALLOC_FL_COLLAPSE_RANGE;
extern const long FALLOC_FL_ZERO_RANGE;
extern const long FALLOC_FL_INSERT_RANGE;
extern const long FALLOC_FL_UNSHARE_RANGE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define FALLOC_FL_KEEP_SIZE SYMBOLIC(FALLOC_FL_KEEP_SIZE)
#define FALLOC_FL_PUNCH_HOLE SYMBOLIC(FALLOC_FL_PUNCH_HOLE)
#define FALLOC_FL_NO_HIDE_STALE SYMBOLIC(FALLOC_FL_NO_HIDE_STALE)
#define FALLOC_FL_COLLAPSE_RANGE SYMBOLIC(FALLOC_FL_COLLAPSE_RANGE)
#define FALLOC_FL_ZERO_RANGE SYMBOLIC(FALLOC_FL_ZERO_RANGE)
#define FALLOC_FL_INSERT_RANGE SYMBOLIC(FALLOC_FL_INSERT_RANGE)
#define FALLOC_FL_UNSHARE_RANGE SYMBOLIC(FALLOC_FL_UNSHARE_RANGE)



/*!BEGIN libc/sysv/consts/fan.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FAN_H_

#define FAN_ACCESS SYMBOLIC(FAN_ACCESS)
#define FAN_ACCESS_PERM SYMBOLIC(FAN_ACCESS_PERM)
#define FAN_ALLOW SYMBOLIC(FAN_ALLOW)
#define FAN_ALL_CLASS_BITS SYMBOLIC(FAN_ALL_CLASS_BITS)
#define FAN_ALL_EVENTS SYMBOLIC(FAN_ALL_EVENTS)
#define FAN_ALL_INIT_FLAGS SYMBOLIC(FAN_ALL_INIT_FLAGS)
#define FAN_ALL_MARK_FLAGS SYMBOLIC(FAN_ALL_MARK_FLAGS)
#define FAN_ALL_OUTGOING_EVENTS SYMBOLIC(FAN_ALL_OUTGOING_EVENTS)
#define FAN_ALL_PERM_EVENTS SYMBOLIC(FAN_ALL_PERM_EVENTS)
#define FAN_CLASS_CONTENT SYMBOLIC(FAN_CLASS_CONTENT)
#define FAN_CLASS_NOTIF SYMBOLIC(FAN_CLASS_NOTIF)
#define FAN_CLASS_PRE_CONTENT SYMBOLIC(FAN_CLASS_PRE_CONTENT)
#define FAN_CLOEXEC SYMBOLIC(FAN_CLOEXEC)
#define FAN_CLOSE SYMBOLIC(FAN_CLOSE)
#define FAN_CLOSE_NOWRITE SYMBOLIC(FAN_CLOSE_NOWRITE)
#define FAN_CLOSE_WRITE SYMBOLIC(FAN_CLOSE_WRITE)
#define FAN_DENY SYMBOLIC(FAN_DENY)
#define FAN_EVENT_METADATA_LEN SYMBOLIC(FAN_EVENT_METADATA_LEN)
#define FAN_EVENT_ON_CHILD SYMBOLIC(FAN_EVENT_ON_CHILD)
#define FAN_MARK_ADD SYMBOLIC(FAN_MARK_ADD)
#define FAN_MARK_DONT_FOLLOW SYMBOLIC(FAN_MARK_DONT_FOLLOW)
#define FAN_MARK_FLUSH SYMBOLIC(FAN_MARK_FLUSH)
#define FAN_MARK_IGNORED_MASK SYMBOLIC(FAN_MARK_IGNORED_MASK)
#define FAN_MARK_IGNORED_SURV_MODIFY SYMBOLIC(FAN_MARK_IGNORED_SURV_MODIFY)
#define FAN_MARK_MOUNT SYMBOLIC(FAN_MARK_MOUNT)
#define FAN_MARK_ONLYDIR SYMBOLIC(FAN_MARK_ONLYDIR)
#define FAN_MARK_REMOVE SYMBOLIC(FAN_MARK_REMOVE)
#define FAN_MODIFY SYMBOLIC(FAN_MODIFY)
#define FAN_NOFD SYMBOLIC(FAN_NOFD)
#define FAN_NONBLOCK SYMBOLIC(FAN_NONBLOCK)
#define FAN_ONDIR SYMBOLIC(FAN_ONDIR)
#define FAN_OPEN SYMBOLIC(FAN_OPEN)
#define FAN_OPEN_PERM SYMBOLIC(FAN_OPEN_PERM)
#define FAN_Q_OVERFLOW SYMBOLIC(FAN_Q_OVERFLOW)
#define FAN_UNLIMITED_MARKS SYMBOLIC(FAN_UNLIMITED_MARKS)
#define FAN_UNLIMITED_QUEUE SYMBOLIC(FAN_UNLIMITED_QUEUE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long FAN_ACCESS;
extern const long FAN_ACCESS_PERM;
extern const long FAN_ALLOW;
extern const long FAN_ALL_CLASS_BITS;
extern const long FAN_ALL_EVENTS;
extern const long FAN_ALL_INIT_FLAGS;
extern const long FAN_ALL_MARK_FLAGS;
extern const long FAN_ALL_OUTGOING_EVENTS;
extern const long FAN_ALL_PERM_EVENTS;
extern const long FAN_CLASS_CONTENT;
extern const long FAN_CLASS_NOTIF;
extern const long FAN_CLASS_PRE_CONTENT;
extern const long FAN_CLOEXEC;
extern const long FAN_CLOSE;
extern const long FAN_CLOSE_NOWRITE;
extern const long FAN_CLOSE_WRITE;
extern const long FAN_DENY;
extern const long FAN_EVENT_METADATA_LEN;
extern const long FAN_EVENT_ON_CHILD;
extern const long FAN_MARK_ADD;
extern const long FAN_MARK_DONT_FOLLOW;
extern const long FAN_MARK_FLUSH;
extern const long FAN_MARK_IGNORED_MASK;
extern const long FAN_MARK_IGNORED_SURV_MODIFY;
extern const long FAN_MARK_MOUNT;
extern const long FAN_MARK_ONLYDIR;
extern const long FAN_MARK_REMOVE;
extern const long FAN_MODIFY;
extern const long FAN_NOFD;
extern const long FAN_NONBLOCK;
extern const long FAN_ONDIR;
extern const long FAN_OPEN;
extern const long FAN_OPEN_PERM;
extern const long FAN_Q_OVERFLOW;
extern const long FAN_UNLIMITED_MARKS;
extern const long FAN_UNLIMITED_QUEUE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/fd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long FD_CLOEXEC;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define FD_CLOEXEC LITERALLY(1)



/*!BEGIN libc/sysv/consts/fe.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FE_H_

#define FE_ALL_EXCEPT SYMBOLIC(FE_ALL_EXCEPT)
#define FE_DIVBYZERO SYMBOLIC(FE_DIVBYZERO)
#define FE_DOWNWARD SYMBOLIC(FE_DOWNWARD)
#define FE_INEXACT SYMBOLIC(FE_INEXACT)
#define FE_INVALID SYMBOLIC(FE_INVALID)
#define FE_OVERFLOW SYMBOLIC(FE_OVERFLOW)
#define FE_TONEAREST SYMBOLIC(FE_TONEAREST)
#define FE_TOWARDZERO SYMBOLIC(FE_TOWARDZERO)
#define FE_UNDERFLOW SYMBOLIC(FE_UNDERFLOW)
#define FE_UPWARD SYMBOLIC(FE_UPWARD)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long FE_ALL_EXCEPT;
extern const long FE_DIVBYZERO;
extern const long FE_DOWNWARD;
extern const long FE_INEXACT;
extern const long FE_INVALID;
extern const long FE_OVERFLOW;
extern const long FE_TONEAREST;
extern const long FE_TOWARDZERO;
extern const long FE_UNDERFLOW;
extern const long FE_UPWARD;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/f.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_F_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long F_DUPFD;
extern const long F_DUPFD_CLOEXEC;
extern const long F_GETFD;
extern const long F_GETFL;
extern const long F_GETLEASE;
extern const long F_GETLK64;
extern const long F_GETLK;
extern const long F_GETOWN;
extern const long F_GETOWN_EX;
extern const long F_GETPIPE_SZ;
extern const long F_GETSIG;
extern const long F_LOCK;
extern const long F_NOTIFY;
extern const long F_OFD_GETLK;
extern const long F_OFD_SETLK;
extern const long F_OFD_SETLKW;
extern const long F_RDLCK;
extern const long F_SETFD;
extern const long F_SETFL;
extern const long F_SETLEASE;
extern const long F_SETLK64;
extern const long F_SETLK;
extern const long F_SETLKW64;
extern const long F_SETLKW;
extern const long F_SETOWN;
extern const long F_SETOWN_EX;
extern const long F_SETPIPE_SZ;
extern const long F_SETSIG;
extern const long F_TEST;
extern const long F_TLOCK;
extern const long F_ULOCK;
extern const long F_UNLCK;
extern const long F_WRLCK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define F_GETFD LITERALLY(1)
#define F_SETFD LITERALLY(2)
#define F_GETFL LITERALLY(3)
#define F_SETFL LITERALLY(4)

#define F_DUPFD SYMBOLIC(F_DUPFD)
#define F_DUPFD_CLOEXEC SYMBOLIC(F_DUPFD_CLOEXEC)
#define F_GETLEASE SYMBOLIC(F_GETLEASE)
#define F_GETLK SYMBOLIC(F_GETLK)
#define F_GETLK64 SYMBOLIC(F_GETLK64)
#define F_GETOWN SYMBOLIC(F_GETOWN)
#define F_GETOWN_EX SYMBOLIC(F_GETOWN_EX)
#define F_GETPIPE_SZ SYMBOLIC(F_GETPIPE_SZ)
#define F_GETSIG SYMBOLIC(F_GETSIG)
#define F_LOCK SYMBOLIC(F_LOCK)
#define F_NOTIFY SYMBOLIC(F_NOTIFY)
#define F_OFD_GETLK SYMBOLIC(F_OFD_GETLK)
#define F_OFD_SETLK SYMBOLIC(F_OFD_SETLK)
#define F_OFD_SETLKW SYMBOLIC(F_OFD_SETLKW)
#define F_RDLCK SYMBOLIC(F_RDLCK)
#define F_SETLEASE SYMBOLIC(F_SETLEASE)
#define F_SETLK SYMBOLIC(F_SETLK)
#define F_SETLK64 SYMBOLIC(F_SETLK64)
#define F_SETLKW SYMBOLIC(F_SETLKW)
#define F_SETLKW64 SYMBOLIC(F_SETLKW64)
#define F_SETOWN SYMBOLIC(F_SETOWN)
#define F_SETOWN_EX SYMBOLIC(F_SETOWN_EX)
#define F_SETPIPE_SZ SYMBOLIC(F_SETPIPE_SZ)
#define F_SETSIG SYMBOLIC(F_SETSIG)
#define F_TEST SYMBOLIC(F_TEST)
#define F_TLOCK SYMBOLIC(F_TLOCK)
#define F_ULOCK SYMBOLIC(F_ULOCK)
#define F_UNLCK SYMBOLIC(F_UNLCK)
#define F_WRLCK SYMBOLIC(F_WRLCK)



/*!BEGIN libc/sysv/consts/fileno.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FILENO_H_

#define STDIN_FILENO LITERALLY(0)
#define STDOUT_FILENO LITERALLY(1)
#define STDERR_FILENO LITERALLY(2)



/*!BEGIN libc/sysv/consts/fio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FIO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long FIONBIO;
extern const long FIONREAD;
extern const long FIOASYNC;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define FIONBIO SYMBOLIC(FIONBIO)
#define FIONREAD SYMBOLIC(FIONREAD)
#define FIOASYNC SYMBOLIC(FIOASYNC)



/*!BEGIN libc/sysv/consts/ftw.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FTW_H_

#define FTW_CHDIR SYMBOLIC(FTW_CHDIR)
#define FTW_D SYMBOLIC(FTW_D)
#define FTW_DEPTH SYMBOLIC(FTW_DEPTH)
#define FTW_DNR SYMBOLIC(FTW_DNR)
#define FTW_DP SYMBOLIC(FTW_DP)
#define FTW_F SYMBOLIC(FTW_F)
#define FTW_MOUNT SYMBOLIC(FTW_MOUNT)
#define FTW_NS SYMBOLIC(FTW_NS)
#define FTW_PHYS SYMBOLIC(FTW_PHYS)
#define FTW_SL SYMBOLIC(FTW_SL)
#define FTW_SLN SYMBOLIC(FTW_SLN)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long FTW_CHDIR;
extern const long FTW_D;
extern const long FTW_DEPTH;
extern const long FTW_DNR;
extern const long FTW_DP;
extern const long FTW_F;
extern const long FTW_MOUNT;
extern const long FTW_NS;
extern const long FTW_PHYS;
extern const long FTW_SL;
extern const long FTW_SLN;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/futex.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_FUTEX_H_

#define FUTEX_PRIVATE_FLAG    SYMBOLIC(FUTEX_PRIVATE_FLAG)
#define FUTEX_REQUEUE         SYMBOLIC(FUTEX_REQUEUE)
#define FUTEX_REQUEUE_PRIVATE SYMBOLIC(FUTEX_REQUEUE_PRIVATE)
#define FUTEX_WAIT            SYMBOLIC(FUTEX_WAIT)
#define FUTEX_WAIT_PRIVATE    SYMBOLIC(FUTEX_WAIT_PRIVATE)
#define FUTEX_WAKE            SYMBOLIC(FUTEX_WAKE)
#define FUTEX_WAKE_PRIVATE    SYMBOLIC(FUTEX_WAKE_PRIVATE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long FUTEX_PRIVATE_FLAG;
extern const long FUTEX_REQUEUE;
extern const long FUTEX_REQUEUE_PRIVATE;
extern const long FUTEX_WAIT;
extern const long FUTEX_WAIT_PRIVATE;
extern const long FUTEX_WAKE;
extern const long FUTEX_WAKE_PRIVATE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/grnd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_GRND_H_

#define GRND_NONBLOCK LITERALLY(1)
#define GRND_RANDOM LITERALLY(2)



/*!BEGIN libc/sysv/consts/icmp6.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ICMP6_H_

#define ICMP6_DST_UNREACH SYMBOLIC(ICMP6_DST_UNREACH)
#define ICMP6_DST_UNREACH_ADDR SYMBOLIC(ICMP6_DST_UNREACH_ADDR)
#define ICMP6_DST_UNREACH_ADMIN SYMBOLIC(ICMP6_DST_UNREACH_ADMIN)
#define ICMP6_DST_UNREACH_BEYONDSCOPE SYMBOLIC(ICMP6_DST_UNREACH_BEYONDSCOPE)
#define ICMP6_DST_UNREACH_NOPORT SYMBOLIC(ICMP6_DST_UNREACH_NOPORT)
#define ICMP6_DST_UNREACH_NOROUTE SYMBOLIC(ICMP6_DST_UNREACH_NOROUTE)
#define ICMP6_ECHO_REPLY SYMBOLIC(ICMP6_ECHO_REPLY)
#define ICMP6_ECHO_REQUEST SYMBOLIC(ICMP6_ECHO_REQUEST)
#define ICMP6_FILTER SYMBOLIC(ICMP6_FILTER)
#define ICMP6_INFOMSG_MASK SYMBOLIC(ICMP6_INFOMSG_MASK)
#define ICMP6_PACKET_TOO_BIG SYMBOLIC(ICMP6_PACKET_TOO_BIG)
#define ICMP6_PARAMPROB_HEADER SYMBOLIC(ICMP6_PARAMPROB_HEADER)
#define ICMP6_PARAMPROB_NEXTHEADER SYMBOLIC(ICMP6_PARAMPROB_NEXTHEADER)
#define ICMP6_PARAMPROB_OPTION SYMBOLIC(ICMP6_PARAMPROB_OPTION)
#define ICMP6_PARAM_PROB SYMBOLIC(ICMP6_PARAM_PROB)
#define ICMP6_ROUTER_RENUMBERING SYMBOLIC(ICMP6_ROUTER_RENUMBERING)
#define ICMP6_RR_FLAGS_FORCEAPPLY SYMBOLIC(ICMP6_RR_FLAGS_FORCEAPPLY)
#define ICMP6_RR_FLAGS_PREVDONE SYMBOLIC(ICMP6_RR_FLAGS_PREVDONE)
#define ICMP6_RR_FLAGS_REQRESULT SYMBOLIC(ICMP6_RR_FLAGS_REQRESULT)
#define ICMP6_RR_FLAGS_SPECSITE SYMBOLIC(ICMP6_RR_FLAGS_SPECSITE)
#define ICMP6_RR_FLAGS_TEST SYMBOLIC(ICMP6_RR_FLAGS_TEST)
#define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME \
  SYMBOLIC(ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME)
#define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME \
  SYMBOLIC(ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME)
#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO SYMBOLIC(ICMP6_RR_PCOUSE_RAFLAGS_AUTO)
#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK SYMBOLIC(ICMP6_RR_PCOUSE_RAFLAGS_ONLINK)
#define ICMP6_RR_RESULT_FLAGS_FORBIDDEN \
  SYMBOLIC(ICMP6_RR_RESULT_FLAGS_FORBIDDEN)
#define ICMP6_RR_RESULT_FLAGS_OOB SYMBOLIC(ICMP6_RR_RESULT_FLAGS_OOB)
#define ICMP6_TIME_EXCEEDED SYMBOLIC(ICMP6_TIME_EXCEEDED)
#define ICMP6_TIME_EXCEED_REASSEMBLY SYMBOLIC(ICMP6_TIME_EXCEED_REASSEMBLY)
#define ICMP6_TIME_EXCEED_TRANSIT SYMBOLIC(ICMP6_TIME_EXCEED_TRANSIT)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long ICMP6_DST_UNREACH;
extern const long ICMP6_DST_UNREACH_ADDR;
extern const long ICMP6_DST_UNREACH_ADMIN;
extern const long ICMP6_DST_UNREACH_BEYONDSCOPE;
extern const long ICMP6_DST_UNREACH_NOPORT;
extern const long ICMP6_DST_UNREACH_NOROUTE;
extern const long ICMP6_ECHO_REPLY;
extern const long ICMP6_ECHO_REQUEST;
extern const long ICMP6_FILTER;
extern const long ICMP6_INFOMSG_MASK;
extern const long ICMP6_PACKET_TOO_BIG;
extern const long ICMP6_PARAMPROB_HEADER;
extern const long ICMP6_PARAMPROB_NEXTHEADER;
extern const long ICMP6_PARAMPROB_OPTION;
extern const long ICMP6_PARAM_PROB;
extern const long ICMP6_ROUTER_RENUMBERING;
extern const long ICMP6_RR_FLAGS_FORCEAPPLY;
extern const long ICMP6_RR_FLAGS_PREVDONE;
extern const long ICMP6_RR_FLAGS_REQRESULT;
extern const long ICMP6_RR_FLAGS_SPECSITE;
extern const long ICMP6_RR_FLAGS_TEST;
extern const long ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME;
extern const long ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME;
extern const long ICMP6_RR_PCOUSE_RAFLAGS_AUTO;
extern const long ICMP6_RR_PCOUSE_RAFLAGS_ONLINK;
extern const long ICMP6_RR_RESULT_FLAGS_FORBIDDEN;
extern const long ICMP6_RR_RESULT_FLAGS_OOB;
extern const long ICMP6_TIME_EXCEEDED;
extern const long ICMP6_TIME_EXCEED_REASSEMBLY;
extern const long ICMP6_TIME_EXCEED_TRANSIT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/iff.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IFF_H_

#define IFF_ALLMULTI SYMBOLIC(IFF_ALLMULTI)
#define IFF_AUTOMEDIA SYMBOLIC(IFF_AUTOMEDIA)
#define IFF_BROADCAST SYMBOLIC(IFF_BROADCAST)
#define IFF_DEBUG SYMBOLIC(IFF_DEBUG)
#define IFF_DYNAMIC SYMBOLIC(IFF_DYNAMIC)
#define IFF_LOOPBACK SYMBOLIC(IFF_LOOPBACK)
#define IFF_MASTER SYMBOLIC(IFF_MASTER)
#define IFF_MULTICAST SYMBOLIC(IFF_MULTICAST)
#define IFF_NOARP SYMBOLIC(IFF_NOARP)
#define IFF_NOTRAILERS SYMBOLIC(IFF_NOTRAILERS)
#define IFF_POINTOPOINT SYMBOLIC(IFF_POINTOPOINT)
#define IFF_PORTSEL SYMBOLIC(IFF_PORTSEL)
#define IFF_PROMISC SYMBOLIC(IFF_PROMISC)
#define IFF_RUNNING SYMBOLIC(IFF_RUNNING)
#define IFF_SLAVE SYMBOLIC(IFF_SLAVE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long IFF_ALLMULTI;
extern const long IFF_AUTOMEDIA;
extern const long IFF_BROADCAST;
extern const long IFF_DEBUG;
extern const long IFF_DYNAMIC;
extern const long IFF_LOOPBACK;
extern const long IFF_MASTER;
extern const long IFF_MULTICAST;
extern const long IFF_NOARP;
extern const long IFF_NOTRAILERS;
extern const long IFF_POINTOPOINT;
extern const long IFF_PORTSEL;
extern const long IFF_PROMISC;
extern const long IFF_RUNNING;
extern const long IFF_SLAVE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/ill.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ILL_H_

#define ILL_BADSTK SYMBOLIC(ILL_BADSTK)
#define ILL_COPROC SYMBOLIC(ILL_COPROC)
#define ILL_ILLADR SYMBOLIC(ILL_ILLADR)
#define ILL_ILLOPC SYMBOLIC(ILL_ILLOPC)
#define ILL_ILLOPN SYMBOLIC(ILL_ILLOPN)
#define ILL_ILLTRP SYMBOLIC(ILL_ILLTRP)
#define ILL_PRVOPC SYMBOLIC(ILL_PRVOPC)
#define ILL_PRVREG SYMBOLIC(ILL_PRVREG)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long ILL_BADSTK;
extern const long ILL_COPROC;
extern const long ILL_ILLADR;
extern const long ILL_ILLOPC;
extern const long ILL_ILLOPN;
extern const long ILL_ILLTRP;
extern const long ILL_PRVOPC;
extern const long ILL_PRVREG;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/inaddr.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_INADDR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

/**
 * @fileoverview Well-known Internet addresses.
 * These need to be hard-coded as little-endian, so htonl() is needed.
 */

extern const long INADDR_ALLHOSTS_GROUP;
extern const long INADDR_ALLRTRS_GROUP;
extern const long INADDR_ANY;
extern const long INADDR_BROADCAST;
extern const long INADDR_LOOPBACK;
extern const long INADDR_MAX_LOCAL_GROUP;
extern const long INADDR_NONE;
extern const long INADDR_TESTNET1;
extern const long INADDR_TESTNET2;
extern const long INADDR_TESTNET3;
extern const long INADDR_UNSPEC_GROUP;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define INADDR_ANY LITERALLY(0x00000000u)       /* 0.0.0.0 */
#define INADDR_BROADCAST LITERALLY(0xffffffffu) /* 255.255.255.255 */
#define INADDR_NONE LITERALLY(0xffffffffu)      /* 255.255.255.255 */
#define INADDR_LOOPBACK LITERALLY(0x7f000001u)  /* 127.0.0.1 */
#define INADDR_TESTNET1 LITERALLY(0xc0000200u)  /* 192.0.2.0/24 (RFC5737§3) */
#define INADDR_TESTNET2 LITERALLY(0xc6336400u)  /* 198.51.100.0/24 */
#define INADDR_TESTNET3 LITERALLY(0xcb007100u)  /* 203.0.113.0/24 */

#define INADDR_ALLHOSTS_GROUP SYMBOLIC(INADDR_ALLHOSTS_GROUP)
#define INADDR_ALLRTRS_GROUP SYMBOLIC(INADDR_ALLRTRS_GROUP)
#define INADDR_MAX_LOCAL_GROUP SYMBOLIC(INADDR_MAX_LOCAL_GROUP)
#define INADDR_UNSPEC_GROUP SYMBOLIC(INADDR_UNSPEC_GROUP)



/*!BEGIN libc/sysv/consts/in.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IN_H_

#define IN_ACCESS SYMBOLIC(IN_ACCESS)
#define IN_ALL_EVENTS SYMBOLIC(IN_ALL_EVENTS)
#define IN_ATTRIB SYMBOLIC(IN_ATTRIB)
#define IN_CLOEXEC SYMBOLIC(IN_CLOEXEC)
#define IN_CLOSE SYMBOLIC(IN_CLOSE)
#define IN_CLOSE_NOWRITE SYMBOLIC(IN_CLOSE_NOWRITE)
#define IN_CLOSE_WRITE SYMBOLIC(IN_CLOSE_WRITE)
#define IN_CREATE SYMBOLIC(IN_CREATE)
#define IN_DELETE SYMBOLIC(IN_DELETE)
#define IN_DELETE_SELF SYMBOLIC(IN_DELETE_SELF)
#define IN_DONT_FOLLOW SYMBOLIC(IN_DONT_FOLLOW)
#define IN_EXCL_UNLINK SYMBOLIC(IN_EXCL_UNLINK)
#define IN_IGNORED SYMBOLIC(IN_IGNORED)
#define IN_ISDIR SYMBOLIC(IN_ISDIR)
#define IN_LOOPBACKNET SYMBOLIC(IN_LOOPBACKNET)
#define IN_MASK_ADD SYMBOLIC(IN_MASK_ADD)
#define IN_MODIFY SYMBOLIC(IN_MODIFY)
#define IN_MOVE SYMBOLIC(IN_MOVE)
#define IN_MOVED_FROM SYMBOLIC(IN_MOVED_FROM)
#define IN_MOVED_TO SYMBOLIC(IN_MOVED_TO)
#define IN_MOVE_SELF SYMBOLIC(IN_MOVE_SELF)
#define IN_NONBLOCK SYMBOLIC(IN_NONBLOCK)
#define IN_ONESHOT SYMBOLIC(IN_ONESHOT)
#define IN_ONLYDIR SYMBOLIC(IN_ONLYDIR)
#define IN_OPEN SYMBOLIC(IN_OPEN)
#define IN_Q_OVERFLOW SYMBOLIC(IN_Q_OVERFLOW)
#define IN_UNMOUNT SYMBOLIC(IN_UNMOUNT)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long IN_ACCESS;
extern const long IN_ALL_EVENTS;
extern const long IN_ATTRIB;
extern const long IN_CLOEXEC;
extern const long IN_CLOSE;
extern const long IN_CLOSE_NOWRITE;
extern const long IN_CLOSE_WRITE;
extern const long IN_CREATE;
extern const long IN_DELETE;
extern const long IN_DELETE_SELF;
extern const long IN_DONT_FOLLOW;
extern const long IN_EXCL_UNLINK;
extern const long IN_IGNORED;
extern const long IN_ISDIR;
extern const long IN_LOOPBACKNET;
extern const long IN_MASK_ADD;
extern const long IN_MODIFY;
extern const long IN_MOVE;
extern const long IN_MOVED_FROM;
extern const long IN_MOVED_TO;
extern const long IN_MOVE_SELF;
extern const long IN_NONBLOCK;
extern const long IN_ONESHOT;
extern const long IN_ONLYDIR;
extern const long IN_OPEN;
extern const long IN_Q_OVERFLOW;
extern const long IN_UNMOUNT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/iov.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IOV_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long IOV_MAX;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define IOV_MAX SYMBOLIC(IOV_MAX)



/*!BEGIN libc/sysv/consts/ipc.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IPC_H_

#define IPC_CREAT SYMBOLIC(IPC_CREAT)
#define IPC_EXCL SYMBOLIC(IPC_EXCL)
#define IPC_INFO SYMBOLIC(IPC_INFO)
#define IPC_NOWAIT SYMBOLIC(IPC_NOWAIT)
#define IPC_PRIVATE SYMBOLIC(IPC_PRIVATE)
#define IPC_RMID SYMBOLIC(IPC_RMID)
#define IPC_SET SYMBOLIC(IPC_SET)
#define IPC_STAT SYMBOLIC(IPC_STAT)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long IPC_CREAT;
extern const long IPC_EXCL;
extern const long IPC_INFO;
extern const long IPC_NOWAIT;
extern const long IPC_PRIVATE;
extern const long IPC_RMID;
extern const long IPC_SET;
extern const long IPC_STAT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/ip.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IP_H_

#define IP_ADD_MEMBERSHIP SYMBOLIC(IP_ADD_MEMBERSHIP)
#define IP_ADD_SOURCE_MEMBERSHIP SYMBOLIC(IP_ADD_SOURCE_MEMBERSHIP)
#define IP_BIND_ADDRESS_NO_PORT SYMBOLIC(IP_BIND_ADDRESS_NO_PORT)
#define IP_BLOCK_SOURCE SYMBOLIC(IP_BLOCK_SOURCE)
#define IP_CHECKSUM SYMBOLIC(IP_CHECKSUM)
#define IP_DEFAULT_MULTICAST_LOOP SYMBOLIC(IP_DEFAULT_MULTICAST_LOOP)
#define IP_DEFAULT_MULTICAST_TTL SYMBOLIC(IP_DEFAULT_MULTICAST_TTL)
#define IP_DROP_MEMBERSHIP SYMBOLIC(IP_DROP_MEMBERSHIP)
#define IP_DROP_SOURCE_MEMBERSHIP SYMBOLIC(IP_DROP_SOURCE_MEMBERSHIP)
#define IP_FREEBIND SYMBOLIC(IP_FREEBIND)
#define IP_HDRINCL SYMBOLIC(IP_HDRINCL)
#define IP_IPSEC_POLICY SYMBOLIC(IP_IPSEC_POLICY)
#define IP_MAX_MEMBERSHIPS SYMBOLIC(IP_MAX_MEMBERSHIPS)
#define IP_MINTTL SYMBOLIC(IP_MINTTL)
#define IP_MSFILTER SYMBOLIC(IP_MSFILTER)
#define IP_MTU SYMBOLIC(IP_MTU)
#define IP_MTU_DISCOVER SYMBOLIC(IP_MTU_DISCOVER)
#define IP_MULTICAST_ALL SYMBOLIC(IP_MULTICAST_ALL)
#define IP_MULTICAST_IF SYMBOLIC(IP_MULTICAST_IF)
#define IP_MULTICAST_LOOP SYMBOLIC(IP_MULTICAST_LOOP)
#define IP_MULTICAST_TTL SYMBOLIC(IP_MULTICAST_TTL)
#define IP_NODEFRAG SYMBOLIC(IP_NODEFRAG)
#define IP_OPTIONS SYMBOLIC(IP_OPTIONS)
#define IP_ORIGDSTADDR SYMBOLIC(IP_ORIGDSTADDR)
#define IP_PASSSEC SYMBOLIC(IP_PASSSEC)
#define IP_PKTINFO SYMBOLIC(IP_PKTINFO)
#define IP_PKTOPTIONS SYMBOLIC(IP_PKTOPTIONS)
#define IP_PMTUDISC SYMBOLIC(IP_PMTUDISC)
#define IP_PMTUDISC_DO SYMBOLIC(IP_PMTUDISC_DO)
#define IP_PMTUDISC_DONT SYMBOLIC(IP_PMTUDISC_DONT)
#define IP_PMTUDISC_INTERFACE SYMBOLIC(IP_PMTUDISC_INTERFACE)
#define IP_PMTUDISC_OMIT SYMBOLIC(IP_PMTUDISC_OMIT)
#define IP_PMTUDISC_PROBE SYMBOLIC(IP_PMTUDISC_PROBE)
#define IP_PMTUDISC_WANT SYMBOLIC(IP_PMTUDISC_WANT)
#define IP_RECVERR SYMBOLIC(IP_RECVERR)
#define IP_RECVOPTS SYMBOLIC(IP_RECVOPTS)
#define IP_RECVORIGDSTADDR SYMBOLIC(IP_RECVORIGDSTADDR)
#define IP_RECVRETOPTS SYMBOLIC(IP_RECVRETOPTS)
#define IP_RECVTOS SYMBOLIC(IP_RECVTOS)
#define IP_RECVTTL SYMBOLIC(IP_RECVTTL)
#define IP_RETOPTS SYMBOLIC(IP_RETOPTS)
#define IP_ROUTER_ALERT SYMBOLIC(IP_ROUTER_ALERT)
#define IP_TOS SYMBOLIC(IP_TOS)
#define IP_TRANSPARENT SYMBOLIC(IP_TRANSPARENT)
#define IP_TTL SYMBOLIC(IP_TTL)
#define IP_UNBLOCK_SOURCE SYMBOLIC(IP_UNBLOCK_SOURCE)
#define IP_UNICAST_IF SYMBOLIC(IP_UNICAST_IF)
#define IP_XFRM_POLICY SYMBOLIC(IP_XFRM_POLICY)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long IP_ADD_MEMBERSHIP;
extern const long IP_ADD_SOURCE_MEMBERSHIP;
extern const long IP_BIND_ADDRESS_NO_PORT;
extern const long IP_BLOCK_SOURCE;
extern const long IP_CHECKSUM;
extern const long IP_DEFAULT_MULTICAST_LOOP;
extern const long IP_DEFAULT_MULTICAST_TTL;
extern const long IP_DROP_MEMBERSHIP;
extern const long IP_DROP_SOURCE_MEMBERSHIP;
extern const long IP_FREEBIND;
extern const long IP_HDRINCL;
extern const long IP_IPSEC_POLICY;
extern const long IP_MAX_MEMBERSHIPS;
extern const long IP_MINTTL;
extern const long IP_MSFILTER;
extern const long IP_MTU;
extern const long IP_MTU_DISCOVER;
extern const long IP_MULTICAST_ALL;
extern const long IP_MULTICAST_IF;
extern const long IP_MULTICAST_LOOP;
extern const long IP_MULTICAST_TTL;
extern const long IP_NODEFRAG;
extern const long IP_OPTIONS;
extern const long IP_ORIGDSTADDR;
extern const long IP_PASSSEC;
extern const long IP_PKTINFO;
extern const long IP_PKTOPTIONS;
extern const long IP_PMTUDISC;
extern const long IP_PMTUDISC_DO;
extern const long IP_PMTUDISC_DONT;
extern const long IP_PMTUDISC_INTERFACE;
extern const long IP_PMTUDISC_OMIT;
extern const long IP_PMTUDISC_PROBE;
extern const long IP_PMTUDISC_WANT;
extern const long IP_RECVERR;
extern const long IP_RECVOPTS;
extern const long IP_RECVORIGDSTADDR;
extern const long IP_RECVRETOPTS;
extern const long IP_RECVTOS;
extern const long IP_RECVTTL;
extern const long IP_RETOPTS;
extern const long IP_ROUTER_ALERT;
extern const long IP_TOS;
extern const long IP_TRANSPARENT;
extern const long IP_TTL;
extern const long IP_UNBLOCK_SOURCE;
extern const long IP_UNICAST_IF;
extern const long IP_XFRM_POLICY;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/ipport.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IPPORT_H_

/**
 * ARPA network ports.
 */
#define IPPORT_ECHO 7
#define IPPORT_DISCARD 9
#define IPPORT_SYSTAT 11
#define IPPORT_DAYTIME 13
#define IPPORT_NETSTAT 15
#define IPPORT_FTP 21
#define IPPORT_TELNET 23
#define IPPORT_SMTP 25
#define IPPORT_TIMESERVER 37
#define IPPORT_NAMESERVER 42
#define IPPORT_WHOIS 43
#define IPPORT_MTP 57
#define IPPORT_TFTP 69
#define IPPORT_RJE 77
#define IPPORT_FINGER 79
#define IPPORT_TTYLINK 87
#define IPPORT_SUPDUP 95
#define IPPORT_EXECSERVER 512
#define IPPORT_LOGINSERVER 513
#define IPPORT_CMDSERVER 514
#define IPPORT_EFSSERVER 520
#define IPPORT_BIFFUDP 512
#define IPPORT_WHOSERVER 513
#define IPPORT_ROUTESERVER 520
#define IPPORT_RESERVED 1024
#define IPPORT_USERRESERVED 5000

/**
 * Modern network ports.
 */
#define IPPORT_SSH 22
#define IPPORT_DOMAIN 53
#define IPPORT_HTTP 80
#define IPPORT_POP3 110
#define IPPORT_SFTP 115
#define IPPORT_NTP 123
#define IPPORT_IMAP2 143
#define IPPORT_NETBIOS_NS 137
#define IPPORT_NETBIOS_DGM 138
#define IPPORT_NETBIOS_SSN 139
#define IPPORT_BGP 179
#define IPPORT_IRC 194
#define IPPORT_HTTPS 443
#define IPPORT_PRINTER 515
#define IPPORT_NFS 2049
#define IPPORT_DISTCC 3632
#define IPPORT_SIP 5060
#define IPPORT_POSTGRESQL 5432
#define IPPORT_X11 6000
#define IPPORT_GIT 9418
#define IPPORT_IRCD 6667
#define IPPORT_IMAPS 993
#define IPPORT_POP3S 995



/*!BEGIN libc/sysv/consts/ipproto.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IPPROTO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long IPPROTO_AH;
extern const long IPPROTO_BEETPH;
extern const long IPPROTO_COMP;
extern const long IPPROTO_DCCP;
extern const long IPPROTO_DSTOPTS;
extern const long IPPROTO_EGP;
extern const long IPPROTO_ENCAP;
extern const long IPPROTO_ESP;
extern const long IPPROTO_FRAGMENT;
extern const long IPPROTO_GRE;
extern const long IPPROTO_HOPOPTS;
extern const long IPPROTO_ICMP;
extern const long IPPROTO_ICMPV6;
extern const long IPPROTO_IDP;
extern const long IPPROTO_IGMP;
extern const long IPPROTO_IP;
extern const long IPPROTO_IPIP;
extern const long IPPROTO_IPV6;
extern const long IPPROTO_MAX;
extern const long IPPROTO_MH;
extern const long IPPROTO_MPLS;
extern const long IPPROTO_MTP;
extern const long IPPROTO_NONE;
extern const long IPPROTO_PIM;
extern const long IPPROTO_PUP;
extern const long IPPROTO_RAW;
extern const long IPPROTO_ROUTING;
extern const long IPPROTO_RSVP;
extern const long IPPROTO_SCTP;
extern const long IPPROTO_TCP;
extern const long IPPROTO_TP;
extern const long IPPROTO_UDP;
extern const long IPPROTO_UDPLITE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define IPPROTO_IP   LITERALLY(0)
#define IPPROTO_ICMP LITERALLY(1)
#define IPPROTO_TCP  LITERALLY(6)
#define IPPROTO_UDP  LITERALLY(17)
#define IPPROTO_RAW  LITERALLY(255)

#define IPPROTO_AH       SYMBOLIC(IPPROTO_AH)
#define IPPROTO_BEETPH   SYMBOLIC(IPPROTO_BEETPH)
#define IPPROTO_COMP     SYMBOLIC(IPPROTO_COMP)
#define IPPROTO_DCCP     SYMBOLIC(IPPROTO_DCCP)
#define IPPROTO_DSTOPTS  SYMBOLIC(IPPROTO_DSTOPTS)
#define IPPROTO_EGP      SYMBOLIC(IPPROTO_EGP)
#define IPPROTO_ENCAP    SYMBOLIC(IPPROTO_ENCAP)
#define IPPROTO_ESP      SYMBOLIC(IPPROTO_ESP)
#define IPPROTO_FRAGMENT SYMBOLIC(IPPROTO_FRAGMENT)
#define IPPROTO_GRE      SYMBOLIC(IPPROTO_GRE)
#define IPPROTO_HOPOPTS  SYMBOLIC(IPPROTO_HOPOPTS)
#define IPPROTO_ICMPV6   SYMBOLIC(IPPROTO_ICMPV6)
#define IPPROTO_IDP      SYMBOLIC(IPPROTO_IDP)
#define IPPROTO_IGMP     SYMBOLIC(IPPROTO_IGMP)
#define IPPROTO_IPIP     SYMBOLIC(IPPROTO_IPIP)
#define IPPROTO_IPV6     SYMBOLIC(IPPROTO_IPV6)
#define IPPROTO_MAX      SYMBOLIC(IPPROTO_MAX)
#define IPPROTO_MH       SYMBOLIC(IPPROTO_MH)
#define IPPROTO_MPLS     SYMBOLIC(IPPROTO_MPLS)
#define IPPROTO_MTP      SYMBOLIC(IPPROTO_MTP)
#define IPPROTO_NONE     SYMBOLIC(IPPROTO_NONE)
#define IPPROTO_PIM      SYMBOLIC(IPPROTO_PIM)
#define IPPROTO_PUP      SYMBOLIC(IPPROTO_PUP)
#define IPPROTO_ROUTING  SYMBOLIC(IPPROTO_ROUTING)
#define IPPROTO_RSVP     SYMBOLIC(IPPROTO_RSVP)
#define IPPROTO_SCTP     SYMBOLIC(IPPROTO_SCTP)
#define IPPROTO_TP       SYMBOLIC(IPPROTO_TP)
#define IPPROTO_UDPLITE  SYMBOLIC(IPPROTO_UDPLITE)



/*!BEGIN libc/sysv/consts/ipv6.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_IPV6_H_

#define IPV6_2292DSTOPTS SYMBOLIC(IPV6_2292DSTOPTS)
#define IPV6_2292HOPLIMIT SYMBOLIC(IPV6_2292HOPLIMIT)
#define IPV6_2292HOPOPTS SYMBOLIC(IPV6_2292HOPOPTS)
#define IPV6_2292PKTINFO SYMBOLIC(IPV6_2292PKTINFO)
#define IPV6_2292PKTOPTIONS SYMBOLIC(IPV6_2292PKTOPTIONS)
#define IPV6_2292RTHDR SYMBOLIC(IPV6_2292RTHDR)
#define IPV6_ADDRFORM SYMBOLIC(IPV6_ADDRFORM)
#define IPV6_ADD_MEMBERSHIP SYMBOLIC(IPV6_ADD_MEMBERSHIP)
#define IPV6_AUTHHDR SYMBOLIC(IPV6_AUTHHDR)
#define IPV6_AUTOFLOWLABEL SYMBOLIC(IPV6_AUTOFLOWLABEL)
#define IPV6_CHECKSUM SYMBOLIC(IPV6_CHECKSUM)
#define IPV6_DONTFRAG SYMBOLIC(IPV6_DONTFRAG)
#define IPV6_DROP_MEMBERSHIP SYMBOLIC(IPV6_DROP_MEMBERSHIP)
#define IPV6_DSTOPTS SYMBOLIC(IPV6_DSTOPTS)
#define IPV6_HDRINCL SYMBOLIC(IPV6_HDRINCL)
#define IPV6_HOPLIMIT SYMBOLIC(IPV6_HOPLIMIT)
#define IPV6_HOPOPTS SYMBOLIC(IPV6_HOPOPTS)
#define IPV6_IPSEC_POLICY SYMBOLIC(IPV6_IPSEC_POLICY)
#define IPV6_JOIN_ANYCAST SYMBOLIC(IPV6_JOIN_ANYCAST)
#define IPV6_JOIN_GROUP SYMBOLIC(IPV6_JOIN_GROUP)
#define IPV6_LEAVE_ANYCAST SYMBOLIC(IPV6_LEAVE_ANYCAST)
#define IPV6_LEAVE_GROUP SYMBOLIC(IPV6_LEAVE_GROUP)
#define IPV6_MINHOPCOUNT SYMBOLIC(IPV6_MINHOPCOUNT)
#define IPV6_MTU SYMBOLIC(IPV6_MTU)
#define IPV6_MTU_DISCOVER SYMBOLIC(IPV6_MTU_DISCOVER)
#define IPV6_MULTICAST_HOPS SYMBOLIC(IPV6_MULTICAST_HOPS)
#define IPV6_MULTICAST_IF SYMBOLIC(IPV6_MULTICAST_IF)
#define IPV6_MULTICAST_LOOP SYMBOLIC(IPV6_MULTICAST_LOOP)
#define IPV6_NEXTHOP SYMBOLIC(IPV6_NEXTHOP)
#define IPV6_ORIGDSTADDR SYMBOLIC(IPV6_ORIGDSTADDR)
#define IPV6_PATHMTU SYMBOLIC(IPV6_PATHMTU)
#define IPV6_PKTINFO SYMBOLIC(IPV6_PKTINFO)
#define IPV6_PMTUDISC_DO SYMBOLIC(IPV6_PMTUDISC_DO)
#define IPV6_PMTUDISC_DONT SYMBOLIC(IPV6_PMTUDISC_DONT)
#define IPV6_PMTUDISC_INTERFACE SYMBOLIC(IPV6_PMTUDISC_INTERFACE)
#define IPV6_PMTUDISC_OMIT SYMBOLIC(IPV6_PMTUDISC_OMIT)
#define IPV6_PMTUDISC_PROBE SYMBOLIC(IPV6_PMTUDISC_PROBE)
#define IPV6_PMTUDISC_WANT SYMBOLIC(IPV6_PMTUDISC_WANT)
#define IPV6_RECVDSTOPTS SYMBOLIC(IPV6_RECVDSTOPTS)
#define IPV6_RECVERR SYMBOLIC(IPV6_RECVERR)
#define IPV6_RECVHOPLIMIT SYMBOLIC(IPV6_RECVHOPLIMIT)
#define IPV6_RECVHOPOPTS SYMBOLIC(IPV6_RECVHOPOPTS)
#define IPV6_RECVORIGDSTADDR SYMBOLIC(IPV6_RECVORIGDSTADDR)
#define IPV6_RECVPATHMTU SYMBOLIC(IPV6_RECVPATHMTU)
#define IPV6_RECVPKTINFO SYMBOLIC(IPV6_RECVPKTINFO)
#define IPV6_RECVRTHDR SYMBOLIC(IPV6_RECVRTHDR)
#define IPV6_RECVTCLASS SYMBOLIC(IPV6_RECVTCLASS)
#define IPV6_ROUTER_ALERT SYMBOLIC(IPV6_ROUTER_ALERT)
#define IPV6_RTHDR SYMBOLIC(IPV6_RTHDR)
#define IPV6_RTHDRDSTOPTS SYMBOLIC(IPV6_RTHDRDSTOPTS)
#define IPV6_RTHDR_LOOSE SYMBOLIC(IPV6_RTHDR_LOOSE)
#define IPV6_RTHDR_STRICT SYMBOLIC(IPV6_RTHDR_STRICT)
#define IPV6_RTHDR_TYPE_0 SYMBOLIC(IPV6_RTHDR_TYPE_0)
#define IPV6_RXDSTOPTS SYMBOLIC(IPV6_RXDSTOPTS)
#define IPV6_RXHOPOPTS SYMBOLIC(IPV6_RXHOPOPTS)
#define IPV6_TCLASS SYMBOLIC(IPV6_TCLASS)
#define IPV6_UNICAST_HOPS SYMBOLIC(IPV6_UNICAST_HOPS)
#define IPV6_V6ONLY SYMBOLIC(IPV6_V6ONLY)
#define IPV6_XFRM_POLICY SYMBOLIC(IPV6_XFRM_POLICY)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long IPV6_2292DSTOPTS;
extern const long IPV6_2292HOPLIMIT;
extern const long IPV6_2292HOPOPTS;
extern const long IPV6_2292PKTINFO;
extern const long IPV6_2292PKTOPTIONS;
extern const long IPV6_2292RTHDR;
extern const long IPV6_ADDRFORM;
extern const long IPV6_ADD_MEMBERSHIP;
extern const long IPV6_AUTHHDR;
extern const long IPV6_AUTOFLOWLABEL;
extern const long IPV6_CHECKSUM;
extern const long IPV6_DONTFRAG;
extern const long IPV6_DROP_MEMBERSHIP;
extern const long IPV6_DSTOPTS;
extern const long IPV6_HDRINCL;
extern const long IPV6_HOPLIMIT;
extern const long IPV6_HOPOPTS;
extern const long IPV6_IPSEC_POLICY;
extern const long IPV6_JOIN_ANYCAST;
extern const long IPV6_JOIN_GROUP;
extern const long IPV6_LEAVE_ANYCAST;
extern const long IPV6_LEAVE_GROUP;
extern const long IPV6_MINHOPCOUNT;
extern const long IPV6_MTU;
extern const long IPV6_MTU_DISCOVER;
extern const long IPV6_MULTICAST_HOPS;
extern const long IPV6_MULTICAST_IF;
extern const long IPV6_MULTICAST_LOOP;
extern const long IPV6_NEXTHOP;
extern const long IPV6_ORIGDSTADDR;
extern const long IPV6_PATHMTU;
extern const long IPV6_PKTINFO;
extern const long IPV6_PMTUDISC_DO;
extern const long IPV6_PMTUDISC_DONT;
extern const long IPV6_PMTUDISC_INTERFACE;
extern const long IPV6_PMTUDISC_OMIT;
extern const long IPV6_PMTUDISC_PROBE;
extern const long IPV6_PMTUDISC_WANT;
extern const long IPV6_RECVDSTOPTS;
extern const long IPV6_RECVERR;
extern const long IPV6_RECVHOPLIMIT;
extern const long IPV6_RECVHOPOPTS;
extern const long IPV6_RECVORIGDSTADDR;
extern const long IPV6_RECVPATHMTU;
extern const long IPV6_RECVPKTINFO;
extern const long IPV6_RECVRTHDR;
extern const long IPV6_RECVTCLASS;
extern const long IPV6_ROUTER_ALERT;
extern const long IPV6_RTHDR;
extern const long IPV6_RTHDRDSTOPTS;
extern const long IPV6_RTHDR_LOOSE;
extern const long IPV6_RTHDR_STRICT;
extern const long IPV6_RTHDR_TYPE_0;
extern const long IPV6_RXDSTOPTS;
extern const long IPV6_RXHOPOPTS;
extern const long IPV6_TCLASS;
extern const long IPV6_UNICAST_HOPS;
extern const long IPV6_V6ONLY;
extern const long IPV6_XFRM_POLICY;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/itimer.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ITIMER_H_

#define ITIMER_REAL 0
#define ITIMER_VIRTUAL 1
#define ITIMER_PROF 2



/*!BEGIN libc/sysv/consts/lc.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LC_H_

#define LC_ALL SYMBOLIC(LC_ALL)
#define LC_ALL_MASK SYMBOLIC(LC_ALL_MASK)
#define LC_COLLATE SYMBOLIC(LC_COLLATE)
#define LC_COLLATE_MASK SYMBOLIC(LC_COLLATE_MASK)
#define LC_CTYPE SYMBOLIC(LC_CTYPE)
#define LC_CTYPE_MASK SYMBOLIC(LC_CTYPE_MASK)
#define LC_MESSAGES SYMBOLIC(LC_MESSAGES)
#define LC_MESSAGES_MASK SYMBOLIC(LC_MESSAGES_MASK)
#define LC_MONETARY SYMBOLIC(LC_MONETARY)
#define LC_MONETARY_MASK SYMBOLIC(LC_MONETARY_MASK)
#define LC_NUMERIC SYMBOLIC(LC_NUMERIC)
#define LC_NUMERIC_MASK SYMBOLIC(LC_NUMERIC_MASK)
#define LC_TIME SYMBOLIC(LC_TIME)
#define LC_TIME_MASK SYMBOLIC(LC_TIME_MASK)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long LC_ALL;
extern const long LC_ALL_MASK;
extern const long LC_COLLATE;
extern const long LC_COLLATE_MASK;
extern const long LC_CTYPE;
extern const long LC_CTYPE_MASK;
extern const long LC_MESSAGES;
extern const long LC_MESSAGES_MASK;
extern const long LC_MONETARY;
extern const long LC_MONETARY_MASK;
extern const long LC_NUMERIC;
extern const long LC_NUMERIC_MASK;
extern const long LC_TIME;
extern const long LC_TIME_MASK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/limits.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LIMITS_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long PIPE_BUF;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PIPE_BUF SYMBOLIC(PIPE_BUF)



/*!BEGIN libc/sysv/consts/lio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LIO_H_

#define LIO_NOP SYMBOLIC(LIO_NOP)
#define LIO_NOWAIT SYMBOLIC(LIO_NOWAIT)
#define LIO_READ SYMBOLIC(LIO_READ)
#define LIO_WAIT SYMBOLIC(LIO_WAIT)
#define LIO_WRITE SYMBOLIC(LIO_WRITE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long LIO_NOP;
extern const long LIO_NOWAIT;
extern const long LIO_READ;
extern const long LIO_WAIT;
extern const long LIO_WRITE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/lock.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long LOCK_EX;
extern const long LOCK_NB;
extern const long LOCK_SH;
extern const long LOCK_UN;
extern const long LOCK_UNLOCK_CACHE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define LOCK_EX LITERALLY(2)
#define LOCK_NB SYMBOLIC(LOCK_NB)
#define LOCK_SH SYMBOLIC(LOCK_SH)
#define LOCK_UN SYMBOLIC(LOCK_UN)
#define LOCK_UNLOCK_CACHE SYMBOLIC(LOCK_UNLOCK_CACHE)



/*!BEGIN libc/sysv/consts/log.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_LOG_H_

#define LOG_ALERT SYMBOLIC(LOG_ALERT)
#define LOG_AUTH SYMBOLIC(LOG_AUTH)
#define LOG_CONS SYMBOLIC(LOG_CONS)
#define LOG_CRIT SYMBOLIC(LOG_CRIT)
#define LOG_CRON SYMBOLIC(LOG_CRON)
#define LOG_DAEMON SYMBOLIC(LOG_DAEMON)
#define LOG_DEBUG SYMBOLIC(LOG_DEBUG)
#define LOG_EMERG SYMBOLIC(LOG_EMERG)
#define LOG_ERR SYMBOLIC(LOG_ERR)
#define LOG_FACMASK SYMBOLIC(LOG_FACMASK)
#define LOG_INFO SYMBOLIC(LOG_INFO)
#define LOG_KERN SYMBOLIC(LOG_KERN)
#define LOG_LOCAL0 SYMBOLIC(LOG_LOCAL0)
#define LOG_LOCAL1 SYMBOLIC(LOG_LOCAL1)
#define LOG_LOCAL2 SYMBOLIC(LOG_LOCAL2)
#define LOG_LOCAL3 SYMBOLIC(LOG_LOCAL3)
#define LOG_LOCAL4 SYMBOLIC(LOG_LOCAL4)
#define LOG_LOCAL5 SYMBOLIC(LOG_LOCAL5)
#define LOG_LOCAL6 SYMBOLIC(LOG_LOCAL6)
#define LOG_LOCAL7 SYMBOLIC(LOG_LOCAL7)
#define LOG_LPR SYMBOLIC(LOG_LPR)
#define LOG_MAIL SYMBOLIC(LOG_MAIL)
#define LOG_NDELAY SYMBOLIC(LOG_NDELAY)
#define LOG_NEWS SYMBOLIC(LOG_NEWS)
#define LOG_NFACILITIES SYMBOLIC(LOG_NFACILITIES)
#define LOG_NOTICE SYMBOLIC(LOG_NOTICE)
#define LOG_NOWAIT SYMBOLIC(LOG_NOWAIT)
#define LOG_ODELAY SYMBOLIC(LOG_ODELAY)
#define LOG_PERROR SYMBOLIC(LOG_PERROR)
#define LOG_PID SYMBOLIC(LOG_PID)
#define LOG_PRIMASK SYMBOLIC(LOG_PRIMASK)
#define LOG_SELECT SYMBOLIC(LOG_SELECT)
#define LOG_SENSE SYMBOLIC(LOG_SENSE)
#define LOG_SYSLOG SYMBOLIC(LOG_SYSLOG)
#define LOG_USER SYMBOLIC(LOG_USER)
#define LOG_UUCP SYMBOLIC(LOG_UUCP)
#define LOG_WARNING SYMBOLIC(LOG_WARNING)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long LOG_ALERT;
extern const long LOG_AUTH;
extern const long LOG_CONS;
extern const long LOG_CRIT;
extern const long LOG_CRON;
extern const long LOG_DAEMON;
extern const long LOG_DEBUG;
extern const long LOG_EMERG;
extern const long LOG_ERR;
extern const long LOG_FACMASK;
extern const long LOG_INFO;
extern const long LOG_KERN;
extern const long LOG_LOCAL0;
extern const long LOG_LOCAL1;
extern const long LOG_LOCAL2;
extern const long LOG_LOCAL3;
extern const long LOG_LOCAL4;
extern const long LOG_LOCAL5;
extern const long LOG_LOCAL6;
extern const long LOG_LOCAL7;
extern const long LOG_LPR;
extern const long LOG_MAIL;
extern const long LOG_NDELAY;
extern const long LOG_NEWS;
extern const long LOG_NFACILITIES;
extern const long LOG_NOTICE;
extern const long LOG_NOWAIT;
extern const long LOG_ODELAY;
extern const long LOG_PERROR;
extern const long LOG_PID;
extern const long LOG_PRIMASK;
extern const long LOG_SELECT;
extern const long LOG_SENSE;
extern const long LOG_SYSLOG;
extern const long LOG_USER;
extern const long LOG_UUCP;
extern const long LOG_WARNING;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/madv.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MADV_H_

#define MADV_DODUMP SYMBOLIC(MADV_DODUMP)
#define MADV_DOFORK SYMBOLIC(MADV_DOFORK)
#define MADV_DONTDUMP SYMBOLIC(MADV_DONTDUMP)
#define MADV_DONTFORK SYMBOLIC(MADV_DONTFORK)
#define MADV_DONTNEED SYMBOLIC(MADV_DONTNEED)
#define MADV_FREE SYMBOLIC(MADV_FREE)
#define MADV_HUGEPAGE SYMBOLIC(MADV_HUGEPAGE)
#define MADV_HWPOISON SYMBOLIC(MADV_HWPOISON)
#define MADV_MERGEABLE SYMBOLIC(MADV_MERGEABLE)
#define MADV_NOHUGEPAGE SYMBOLIC(MADV_NOHUGEPAGE)
#define MADV_NORMAL SYMBOLIC(MADV_NORMAL)
#define MADV_RANDOM SYMBOLIC(MADV_RANDOM)
#define MADV_REMOVE SYMBOLIC(MADV_REMOVE)
#define MADV_SEQUENTIAL SYMBOLIC(MADV_SEQUENTIAL)
#define MADV_UNMERGEABLE SYMBOLIC(MADV_UNMERGEABLE)
#define MADV_WILLNEED SYMBOLIC(MADV_WILLNEED)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MADV_DODUMP;
extern const long MADV_DOFORK;
extern const long MADV_DONTDUMP;
extern const long MADV_DONTFORK;
extern const long MADV_DONTNEED;
extern const long MADV_FREE;
extern const long MADV_HUGEPAGE;
extern const long MADV_HWPOISON;
extern const long MADV_MERGEABLE;
extern const long MADV_NOHUGEPAGE;
extern const long MADV_NORMAL;
extern const long MADV_RANDOM;
extern const long MADV_REMOVE;
extern const long MADV_SEQUENTIAL;
extern const long MADV_UNMERGEABLE;
extern const long MADV_WILLNEED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/map.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MAP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MAP_32BIT;
extern const long MAP_ANON;
extern const long MAP_ANONYMOUS;
extern const long MAP_DENYWRITE;
extern const long MAP_EXECUTABLE;
extern const long MAP_FILE;
extern const long MAP_FIXED;
extern const long MAP_GROWSDOWN;
extern const long MAP_HUGETLB;
extern const long MAP_HUGE_MASK;
extern const long MAP_HUGE_SHIFT;
extern const long MAP_LOCKED;
extern const long MAP_NONBLOCK;
extern const long MAP_NORESERVE;
extern const long MAP_POPULATE;
extern const long MAP_PRIVATE;
extern const long MAP_SHARED;
extern const long MAP_TYPE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MAP_FILE    0
#define MAP_SHARED  1
#define MAP_PRIVATE 2
#define MAP_FIXED   16

#define MAP_32BIT      SYMBOLIC(MAP_32BIT)
#define MAP_ANONYMOUS  SYMBOLIC(MAP_ANONYMOUS)
#define MAP_CONCEAL    SYMBOLIC(MAP_CONCEAL)
#define MAP_DENYWRITE  SYMBOLIC(MAP_DENYWRITE)
#define MAP_EXECUTABLE SYMBOLIC(MAP_EXECUTABLE)
#define MAP_GROWSDOWN  SYMBOLIC(MAP_GROWSDOWN)
#define MAP_HUGETLB    SYMBOLIC(MAP_HUGETLB)
#define MAP_HUGE_MASK  SYMBOLIC(MAP_HUGE_MASK)
#define MAP_HUGE_SHIFT SYMBOLIC(MAP_HUGE_SHIFT)
#define MAP_LOCKED     SYMBOLIC(MAP_LOCKED)
#define MAP_NONBLOCK   SYMBOLIC(MAP_NONBLOCK)
#define MAP_NORESERVE  SYMBOLIC(MAP_NORESERVE)
#define MAP_POPULATE   SYMBOLIC(MAP_POPULATE)
#define MAP_TYPE       SYMBOLIC(MAP_TYPE)

#define MAP_ANON   MAP_ANONYMOUS
#define MAP_NOCORE MAP_CONCEAL
#define MAP_STACK  MAP_GROWSDOWN



/*!BEGIN libc/sysv/consts/mcast.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MCAST_H_

#define MCAST_BLOCK_SOURCE SYMBOLIC(MCAST_BLOCK_SOURCE)
#define MCAST_EXCLUDE SYMBOLIC(MCAST_EXCLUDE)
#define MCAST_INCLUDE SYMBOLIC(MCAST_INCLUDE)
#define MCAST_JOIN_GROUP SYMBOLIC(MCAST_JOIN_GROUP)
#define MCAST_JOIN_SOURCE_GROUP SYMBOLIC(MCAST_JOIN_SOURCE_GROUP)
#define MCAST_LEAVE_GROUP SYMBOLIC(MCAST_LEAVE_GROUP)
#define MCAST_LEAVE_SOURCE_GROUP SYMBOLIC(MCAST_LEAVE_SOURCE_GROUP)
#define MCAST_MSFILTER SYMBOLIC(MCAST_MSFILTER)
#define MCAST_UNBLOCK_SOURCE SYMBOLIC(MCAST_UNBLOCK_SOURCE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MCAST_BLOCK_SOURCE;
extern const long MCAST_EXCLUDE;
extern const long MCAST_INCLUDE;
extern const long MCAST_JOIN_GROUP;
extern const long MCAST_JOIN_SOURCE_GROUP;
extern const long MCAST_LEAVE_GROUP;
extern const long MCAST_LEAVE_SOURCE_GROUP;
extern const long MCAST_MSFILTER;
extern const long MCAST_UNBLOCK_SOURCE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/mfd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MFD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MFD_CLOEXEC;
extern const long MFD_ALLOW_SEALING;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MFD_CLOEXEC       SYMBOLIC(MFD_CLOEXEC)
#define MFD_ALLOW_SEALING SYMBOLIC(MFD_ALLOW_SEALING)



/*!BEGIN libc/sysv/consts/mlock.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MLOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MCL_CURRENT;
extern const long MCL_FUTURE;
extern const long MCL_ONFAULT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MCL_CURRENT LITERALLY(1)
#define MCL_FUTURE  LITERALLY(2)
#define MCL_ONFAULT SYMBOLIC(MCL_ONFAULT)



/*!BEGIN libc/sysv/consts/mnt.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MNT_H_

#define MNT_DETACH SYMBOLIC(MNT_DETACH)
#define MNT_EXPIRE SYMBOLIC(MNT_EXPIRE)
#define MNT_FORCE SYMBOLIC(MNT_FORCE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MNT_DETACH;
extern const long MNT_EXPIRE;
extern const long MNT_FORCE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/modem.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MODEM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long TIOCMGET;
extern const long TIOCMSET;
extern const long TIOCMBIC;
extern const long TIOCMBIS;

extern const long TIOCM_CAR;
extern const long TIOCM_CD;
extern const long TIOCM_CTS;
extern const long TIOCM_DSR;
extern const long TIOCM_DTR;
extern const long TIOCM_LE;
extern const long TIOCM_RI;
extern const long TIOCM_RNG;
extern const long TIOCM_RTS;
extern const long TIOCM_SR;
extern const long TIOCM_ST;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define TIOCMGET SYMBOLIC(TIOCMGET)
#define TIOCMSET SYMBOLIC(TIOCMSET)
#define TIOCMBIC SYMBOLIC(TIOCMBIC)
#define TIOCMBIS SYMBOLIC(TIOCMBIS)

#define TIOCM_LE  LITERALLY(0x01)
#define TIOCM_DTR LITERALLY(0x02)
#define TIOCM_RTS LITERALLY(0x04)
#define TIOCM_ST  LITERALLY(0x08)
#define TIOCM_SR  LITERALLY(0x10)
#define TIOCM_CTS LITERALLY(0x20)
#define TIOCM_CAR LITERALLY(0x40)
#define TIOCM_CD  LITERALLY(0x40)
#define TIOCM_RI  LITERALLY(0x80)
#define TIOCM_RNG LITERALLY(0x80)
#define TIOCM_DSR LITERALLY(0x0100)



/*!BEGIN libc/sysv/consts/mount.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MOUNT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MS_ACTIVE;
extern const long MS_BIND;
extern const long MS_DIRSYNC;
extern const long MS_I_VERSION;
extern const long MS_KERNMOUNT;
extern const long MS_LAZYTIME;
extern const long MS_MANDLOCK;
extern const long MS_MGC_MSK;
extern const long MS_MGC_VAL;
extern const long MS_MOVE;
extern const long MS_NOATIME;
extern const long MS_NODEV;
extern const long MS_NODIRATIME;
extern const long MS_NOEXEC;
extern const long MS_NOSUID;
extern const long MS_NOUSER;
extern const long MS_POSIXACL;
extern const long MS_PRIVATE;
extern const long MS_RDONLY;
extern const long MS_REC;
extern const long MS_RELATIME;
extern const long MS_REMOUNT;
extern const long MS_RMT_MASK;
extern const long MS_SHARED;
extern const long MS_SILENT;
extern const long MS_SLAVE;
extern const long MS_STRICTATIME;
extern const long MS_SYNCHRONOUS;
extern const long MS_UNBINDABLE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MS_ACTIVE      SYMBOLIC(MS_ACTIVE)
#define MS_BIND        SYMBOLIC(MS_BIND)
#define MS_DIRSYNC     SYMBOLIC(MS_DIRSYNC)
#define MS_I_VERSION   SYMBOLIC(MS_I_VERSION)
#define MS_KERNMOUNT   SYMBOLIC(MS_KERNMOUNT)
#define MS_LAZYTIME    SYMBOLIC(MS_LAZYTIME)
#define MS_MANDLOCK    SYMBOLIC(MS_MANDLOCK)
#define MS_MGC_MSK     SYMBOLIC(MS_MGC_MSK)
#define MS_MGC_VAL     SYMBOLIC(MS_MGC_VAL)
#define MS_MOVE        SYMBOLIC(MS_MOVE)
#define MS_NOATIME     SYMBOLIC(MS_NOATIME)
#define MS_NODEV       SYMBOLIC(MS_NODEV)
#define MS_NODIRATIME  SYMBOLIC(MS_NODIRATIME)
#define MS_NOEXEC      SYMBOLIC(MS_NOEXEC)
#define MS_NOSUID      SYMBOLIC(MS_NOSUID)
#define MS_NOUSER      SYMBOLIC(MS_NOUSER)
#define MS_POSIXACL    SYMBOLIC(MS_POSIXACL)
#define MS_PRIVATE     SYMBOLIC(MS_PRIVATE)
#define MS_RDONLY      SYMBOLIC(MS_RDONLY)
#define MS_REC         SYMBOLIC(MS_REC)
#define MS_RELATIME    SYMBOLIC(MS_RELATIME)
#define MS_REMOUNT     SYMBOLIC(MS_REMOUNT)
#define MS_RMT_MASK    SYMBOLIC(MS_RMT_MASK)
#define MS_SHARED      SYMBOLIC(MS_SHARED)
#define MS_SILENT      SYMBOLIC(MS_SILENT)
#define MS_SLAVE       SYMBOLIC(MS_SLAVE)
#define MS_STRICTATIME SYMBOLIC(MS_STRICTATIME)
#define MS_SYNCHRONOUS SYMBOLIC(MS_SYNCHRONOUS)
#define MS_UNBINDABLE  SYMBOLIC(MS_UNBINDABLE)



/*!BEGIN libc/sysv/consts/mremap.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MREMAP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MREMAP_FIXED;
extern const long MREMAP_MAYMOVE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MREMAP_MAYMOVE LITERALLY(1)
#define MREMAP_FIXED   LITERALLY(2)



/*!BEGIN libc/sysv/consts/msg.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MSG_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MSG_BATCH;
extern const long MSG_CMSG_CLOEXEC;
extern const long MSG_CONFIRM;
extern const long MSG_CTRUNC;
extern const long MSG_DONTROUTE;
extern const long MSG_DONTWAIT;
extern const long MSG_EOR;
extern const long MSG_ERRQUEUE;
extern const long MSG_EXCEPT;
extern const long MSG_FASTOPEN;
extern const long MSG_FIN;
extern const long MSG_INFO;
extern const long MSG_MORE;
extern const long MSG_NOERROR;
extern const long MSG_NOSIGNAL;
extern const long MSG_OOB;
extern const long MSG_PARITY_ERROR;
extern const long MSG_PEEK;
extern const long MSG_PROXY;
extern const long MSG_RST;
extern const long MSG_STAT;
extern const long MSG_SYN;
extern const long MSG_TRUNC;
extern const long MSG_WAITALL;
extern const long MSG_WAITFORONE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MSG_BATCH SYMBOLIC(MSG_BATCH)
#define MSG_CMSG_CLOEXEC SYMBOLIC(MSG_CMSG_CLOEXEC)
#define MSG_CONFIRM SYMBOLIC(MSG_CONFIRM)
#define MSG_CTRUNC SYMBOLIC(MSG_CTRUNC)
#define MSG_DONTROUTE LITERALLY(4)
#define MSG_DONTWAIT SYMBOLIC(MSG_DONTWAIT)
#define MSG_EOR SYMBOLIC(MSG_EOR)
#define MSG_ERRQUEUE SYMBOLIC(MSG_ERRQUEUE)
#define MSG_EXCEPT SYMBOLIC(MSG_EXCEPT)
#define MSG_FASTOPEN SYMBOLIC(MSG_FASTOPEN)
#define MSG_FIN SYMBOLIC(MSG_FIN)
#define MSG_INFO SYMBOLIC(MSG_INFO)
#define MSG_MORE SYMBOLIC(MSG_MORE)
#define MSG_NOERROR SYMBOLIC(MSG_NOERROR)
#define MSG_NOSIGNAL SYMBOLIC(MSG_NOSIGNAL)
#define MSG_OOB LITERALLY(1)
#define MSG_PARITY_ERROR SYMBOLIC(MSG_PARITY_ERROR)
#define MSG_PEEK LITERALLY(2)
#define MSG_PROXY SYMBOLIC(MSG_PROXY)
#define MSG_RST SYMBOLIC(MSG_RST)
#define MSG_STAT SYMBOLIC(MSG_STAT)
#define MSG_SYN SYMBOLIC(MSG_SYN)
#define MSG_TRUNC SYMBOLIC(MSG_TRUNC)
#define MSG_WAITALL SYMBOLIC(MSG_WAITALL)
#define MSG_WAITFORONE SYMBOLIC(MSG_WAITFORONE)



/*!BEGIN libc/sysv/consts/msync.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_MSYNC_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long MS_SYNC;
extern const long MS_ASYNC;
extern const long MS_INVALIDATE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define MS_SYNC       SYMBOLIC(MS_SYNC)
#define MS_ASYNC      LITERALLY(1)
#define MS_INVALIDATE SYMBOLIC(MS_INVALIDATE)



/*!BEGIN libc/sysv/consts/nd.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ND_H_

#define ND_NA_FLAG_OVERRIDE SYMBOLIC(ND_NA_FLAG_OVERRIDE)
#define ND_NA_FLAG_ROUTER SYMBOLIC(ND_NA_FLAG_ROUTER)
#define ND_NA_FLAG_SOLICITED SYMBOLIC(ND_NA_FLAG_SOLICITED)
#define ND_NEIGHBOR_ADVERT SYMBOLIC(ND_NEIGHBOR_ADVERT)
#define ND_NEIGHBOR_SOLICIT SYMBOLIC(ND_NEIGHBOR_SOLICIT)
#define ND_RA_FLAG_HOME_AGENT SYMBOLIC(ND_RA_FLAG_HOME_AGENT)
#define ND_RA_FLAG_MANAGED SYMBOLIC(ND_RA_FLAG_MANAGED)
#define ND_RA_FLAG_OTHER SYMBOLIC(ND_RA_FLAG_OTHER)
#define ND_REDIRECT SYMBOLIC(ND_REDIRECT)
#define ND_ROUTER_ADVERT SYMBOLIC(ND_ROUTER_ADVERT)
#define ND_ROUTER_SOLICIT SYMBOLIC(ND_ROUTER_SOLICIT)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long ND_NA_FLAG_OVERRIDE;
extern const long ND_NA_FLAG_ROUTER;
extern const long ND_NA_FLAG_SOLICITED;
extern const long ND_NEIGHBOR_ADVERT;
extern const long ND_NEIGHBOR_SOLICIT;
extern const long ND_RA_FLAG_HOME_AGENT;
extern const long ND_RA_FLAG_MANAGED;
extern const long ND_RA_FLAG_OTHER;
extern const long ND_REDIRECT;
extern const long ND_ROUTER_ADVERT;
extern const long ND_ROUTER_SOLICIT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/n.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_N_H_

#define N_6PACK SYMBOLIC(N_6PACK)
#define N_AX25 SYMBOLIC(N_AX25)
#define N_HCI SYMBOLIC(N_HCI)
#define N_HDLC SYMBOLIC(N_HDLC)
#define N_IRDA SYMBOLIC(N_IRDA)
#define N_MASC SYMBOLIC(N_MASC)
#define N_MOUSE SYMBOLIC(N_MOUSE)
#define N_PPP SYMBOLIC(N_PPP)
#define N_PROFIBUS_FDL SYMBOLIC(N_PROFIBUS_FDL)
#define N_R3964 SYMBOLIC(N_R3964)
#define N_SLIP SYMBOLIC(N_SLIP)
#define N_SMSBLOCK SYMBOLIC(N_SMSBLOCK)
#define N_STRIP SYMBOLIC(N_STRIP)
#define N_SYNC_PPP SYMBOLIC(N_SYNC_PPP)
#define N_TTY SYMBOLIC(N_TTY)
#define N_X25 SYMBOLIC(N_X25)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long N_6PACK;
extern const long N_AX25;
extern const long N_HCI;
extern const long N_HDLC;
extern const long N_IRDA;
extern const long N_MASC;
extern const long N_MOUSE;
extern const long N_PPP;
extern const long N_PROFIBUS_FDL;
extern const long N_R3964;
extern const long N_SLIP;
extern const long N_SMSBLOCK;
extern const long N_STRIP;
extern const long N_SYNC_PPP;
extern const long N_TTY;
extern const long N_X25;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/ok.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_OK_H_

#define F_OK SYMBOLIC(F_OK)
#define R_OK SYMBOLIC(R_OK)
#define W_OK SYMBOLIC(W_OK)
#define X_OK SYMBOLIC(X_OK)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long F_OK;
extern const long R_OK;
extern const long W_OK;
extern const long X_OK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/personality.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PERSONALITY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long ADDR_COMPAT_LAYOUT;
extern const long READ_IMPLIES_EXEC;
extern const long ADDR_LIMIT_3GB;
extern const long FDPIC_FUNCPTRS;
extern const long STICKY_TIMEOUTS;
extern const long MMAP_PAGE_ZERO;
extern const long ADDR_LIMIT_32BIT;
extern const long WHOLE_SECONDS;
extern const long ADDR_NO_RANDOMIZE;
extern const long SHORT_INODE;
extern const long UNAME26;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define ADDR_COMPAT_LAYOUT SYMBOLIC(ADDR_COMPAT_LAYOUT)
#define READ_IMPLIES_EXEC SYMBOLIC(READ_IMPLIES_EXEC)
#define ADDR_LIMIT_3GB SYMBOLIC(ADDR_LIMIT_3GB)
#define FDPIC_FUNCPTRS SYMBOLIC(FDPIC_FUNCPTRS)
#define STICKY_TIMEOUTS SYMBOLIC(STICKY_TIMEOUTS)
#define MMAP_PAGE_ZERO SYMBOLIC(MMAP_PAGE_ZERO)
#define ADDR_LIMIT_32BIT SYMBOLIC(ADDR_LIMIT_32BIT)
#define WHOLE_SECONDS SYMBOLIC(WHOLE_SECONDS)
#define ADDR_NO_RANDOMIZE SYMBOLIC(ADDR_NO_RANDOMIZE)
#define SHORT_INODE SYMBOLIC(SHORT_INODE)
#define UNAME26 SYMBOLIC(UNAME26)



/*!BEGIN libc/sysv/consts/pf.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PF_H_

#define PF_ALG SYMBOLIC(PF_ALG)
#define PF_APPLETALK SYMBOLIC(PF_APPLETALK)
#define PF_ASH SYMBOLIC(PF_ASH)
#define PF_ATMPVC SYMBOLIC(PF_ATMPVC)
#define PF_ATMSVC SYMBOLIC(PF_ATMSVC)
#define PF_AX25 SYMBOLIC(PF_AX25)
#define PF_BLUETOOTH SYMBOLIC(PF_BLUETOOTH)
#define PF_BRIDGE SYMBOLIC(PF_BRIDGE)
#define PF_CAIF SYMBOLIC(PF_CAIF)
#define PF_CAN SYMBOLIC(PF_CAN)
#define PF_ECONET SYMBOLIC(PF_ECONET)
#define PF_FILE SYMBOLIC(PF_FILE)
#define PF_IB SYMBOLIC(PF_IB)
#define PF_IEEE802154 SYMBOLIC(PF_IEEE802154)
#define PF_INET SYMBOLIC(PF_INET)
#define PF_INET6 SYMBOLIC(PF_INET6)
#define PF_IPX SYMBOLIC(PF_IPX)
#define PF_IRDA SYMBOLIC(PF_IRDA)
#define PF_ISDN SYMBOLIC(PF_ISDN)
#define PF_IUCV SYMBOLIC(PF_IUCV)
#define PF_KCM SYMBOLIC(PF_KCM)
#define PF_KEY SYMBOLIC(PF_KEY)
#define PF_LLC SYMBOLIC(PF_LLC)
#define PF_LOCAL SYMBOLIC(PF_LOCAL)
#define PF_MAX SYMBOLIC(PF_MAX)
#define PF_MPLS SYMBOLIC(PF_MPLS)
#define PF_NETBEUI SYMBOLIC(PF_NETBEUI)
#define PF_NETLINK SYMBOLIC(PF_NETLINK)
#define PF_NETROM SYMBOLIC(PF_NETROM)
#define PF_NFC SYMBOLIC(PF_NFC)
#define PF_PACKET SYMBOLIC(PF_PACKET)
#define PF_PHONET SYMBOLIC(PF_PHONET)
#define PF_PPPOX SYMBOLIC(PF_PPPOX)
#define PF_RDS SYMBOLIC(PF_RDS)
#define PF_ROSE SYMBOLIC(PF_ROSE)
#define PF_ROUTE SYMBOLIC(PF_ROUTE)
#define PF_RXRPC SYMBOLIC(PF_RXRPC)
#define PF_SECURITY SYMBOLIC(PF_SECURITY)
#define PF_SNA SYMBOLIC(PF_SNA)
#define PF_TIPC SYMBOLIC(PF_TIPC)
#define PF_UNIX SYMBOLIC(PF_UNIX)
#define PF_UNSPEC SYMBOLIC(PF_UNSPEC)
#define PF_VSOCK SYMBOLIC(PF_VSOCK)
#define PF_WANPIPE SYMBOLIC(PF_WANPIPE)
#define PF_X25 SYMBOLIC(PF_X25)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long PF_ALG;
extern const long PF_APPLETALK;
extern const long PF_ASH;
extern const long PF_ATMPVC;
extern const long PF_ATMSVC;
extern const long PF_AX25;
extern const long PF_BLUETOOTH;
extern const long PF_BRIDGE;
extern const long PF_CAIF;
extern const long PF_CAN;
extern const long PF_ECONET;
extern const long PF_FILE;
extern const long PF_IB;
extern const long PF_IEEE802154;
extern const long PF_INET6;
extern const long PF_INET;
extern const long PF_IPX;
extern const long PF_IRDA;
extern const long PF_ISDN;
extern const long PF_IUCV;
extern const long PF_KCM;
extern const long PF_KEY;
extern const long PF_LLC;
extern const long PF_LOCAL;
extern const long PF_MAX;
extern const long PF_MPLS;
extern const long PF_NETBEUI;
extern const long PF_NETLINK;
extern const long PF_NETROM;
extern const long PF_NFC;
extern const long PF_PACKET;
extern const long PF_PHONET;
extern const long PF_PPPOX;
extern const long PF_RDS;
extern const long PF_ROSE;
extern const long PF_ROUTE;
extern const long PF_RXRPC;
extern const long PF_SECURITY;
extern const long PF_SNA;
extern const long PF_TIPC;
extern const long PF_UNIX;
extern const long PF_UNSPEC;
extern const long PF_VSOCK;
extern const long PF_WANPIPE;
extern const long PF_X25;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/poll.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_POLL_H_

#define POLLERR    SYMBOLIC(POLLERR)
#define POLLHUP    SYMBOLIC(POLLHUP)
#define POLLIN     SYMBOLIC(POLLIN)
#define POLLNVAL   SYMBOLIC(POLLNVAL)
#define POLLOUT    SYMBOLIC(POLLOUT)
#define POLLPRI    SYMBOLIC(POLLPRI)
#define POLLRDBAND SYMBOLIC(POLLRDBAND)
#define POLLRDHUP  SYMBOLIC(POLLRDHUP)
#define POLLRDNORM SYMBOLIC(POLLRDNORM)
#define POLLWRBAND SYMBOLIC(POLLWRBAND)
#define POLLWRNORM SYMBOLIC(POLLWRNORM)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int16_t POLLERR;
extern const int16_t POLLHUP;
extern const int16_t POLLIN;
extern const int16_t POLLNVAL;
extern const int16_t POLLOUT;
extern const int16_t POLLPRI;
extern const int16_t POLLRDBAND;
extern const int16_t POLLRDHUP;
extern const int16_t POLLRDNORM;
extern const int16_t POLLWRBAND;
extern const int16_t POLLWRNORM;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/_posix2.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS__POSIX2_H_

#define _POSIX2_BC_BASE_MAX SYMBOLIC(_POSIX2_BC_BASE_MAX)
#define _POSIX2_BC_DIM_MAX SYMBOLIC(_POSIX2_BC_DIM_MAX)
#define _POSIX2_BC_SCALE_MAX SYMBOLIC(_POSIX2_BC_SCALE_MAX)
#define _POSIX2_BC_STRING_MAX SYMBOLIC(_POSIX2_BC_STRING_MAX)
#define _POSIX2_CHARCLASS_NAME_MAX SYMBOLIC(_POSIX2_CHARCLASS_NAME_MAX)
#define _POSIX2_COLL_WEIGHTS_MAX SYMBOLIC(_POSIX2_COLL_WEIGHTS_MAX)
#define _POSIX2_C_BIND SYMBOLIC(_POSIX2_C_BIND)
#define _POSIX2_EXPR_NEST_MAX SYMBOLIC(_POSIX2_EXPR_NEST_MAX)
#define _POSIX2_LINE_MAX SYMBOLIC(_POSIX2_LINE_MAX)
#define _POSIX2_RE_DUP_MAX SYMBOLIC(_POSIX2_RE_DUP_MAX)
#define _POSIX2_VERSION SYMBOLIC(_POSIX2_VERSION)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long _POSIX2_BC_BASE_MAX;
extern const long _POSIX2_BC_DIM_MAX;
extern const long _POSIX2_BC_SCALE_MAX;
extern const long _POSIX2_BC_STRING_MAX;
extern const long _POSIX2_CHARCLASS_NAME_MAX;
extern const long _POSIX2_COLL_WEIGHTS_MAX;
extern const long _POSIX2_C_BIND;
extern const long _POSIX2_EXPR_NEST_MAX;
extern const long _POSIX2_LINE_MAX;
extern const long _POSIX2_RE_DUP_MAX;
extern const long _POSIX2_VERSION;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/_posix.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS__POSIX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long _POSIX_ADVISORY_INFO;
extern const long _POSIX_AIO_LISTIO_MAX;
extern const long _POSIX_AIO_MAX;
extern const long _POSIX_ARG_MAX;
extern const long _POSIX_ASYNCHRONOUS_IO;
extern const long _POSIX_BARRIERS;
extern const long _POSIX_CHILD_MAX;
extern const long _POSIX_CHOWN_RESTRICTED;
extern const long _POSIX_CLOCKRES_MIN;
extern const long _POSIX_CLOCK_SELECTION;
extern const long _POSIX_CPUTIME;
extern const long _POSIX_DELAYTIMER_MAX;
extern const long _POSIX_FSYNC;
extern const long _POSIX_HOST_NAME_MAX;
extern const long _POSIX_IPV6;
extern const long _POSIX_JOB_CONTROL;
extern const long _POSIX_LINK_MAX;
extern const long _POSIX_LOGIN_NAME_MAX;
extern const long _POSIX_MAPPED_FILES;
extern const long _POSIX_MAX_CANON;
extern const long _POSIX_MAX_INPUT;
extern const long _POSIX_MEMLOCK;
extern const long _POSIX_MEMLOCK_RANGE;
extern const long _POSIX_MEMORY_PROTECTION;
extern const long _POSIX_MESSAGE_PASSING;
extern const long _POSIX_MONOTONIC_CLOCK;
extern const long _POSIX_MQ_OPEN_MAX;
extern const long _POSIX_MQ_PRIO_MAX;
extern const long _POSIX_NAME_MAX;
extern const long _POSIX_NGROUPS_MAX;
extern const long _POSIX_NO_TRUNC;
extern const long _POSIX_OPEN_MAX;
extern const long _POSIX_PATH_MAX;
extern const long _POSIX_PIPE_BUF;
extern const long _POSIX_RAW_SOCKETS;
extern const long _POSIX_READER_WRITER_LOCKS;
extern const long _POSIX_REALTIME_SIGNALS;
extern const long _POSIX_REGEXP;
extern const long _POSIX_RE_DUP_MAX;
extern const long _POSIX_RTSIG_MAX;
extern const long _POSIX_SAVED_IDS;
extern const long _POSIX_SEMAPHORES;
extern const long _POSIX_SEM_NSEMS_MAX;
extern const long _POSIX_SEM_VALUE_MAX;
extern const long _POSIX_SHARED_MEMORY_OBJECTS;
extern const long _POSIX_SHELL;
extern const long _POSIX_SIGQUEUE_MAX;
extern const long _POSIX_SPAWN;
extern const long _POSIX_SPIN_LOCKS;
extern const long _POSIX_SSIZE_MAX;
extern const long _POSIX_SS_REPL_MAX;
extern const long _POSIX_STREAM_MAX;
extern const long _POSIX_SYMLINK_MAX;
extern const long _POSIX_SYMLOOP_MAX;
extern const long _POSIX_THREADS;
extern const long _POSIX_THREAD_ATTR_STACKADDR;
extern const long _POSIX_THREAD_ATTR_STACKSIZE;
extern const long _POSIX_THREAD_CPUTIME;
extern const long _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
extern const long _POSIX_THREAD_KEYS_MAX;
extern const long _POSIX_THREAD_PRIORITY_SCHEDULING;
extern const long _POSIX_THREAD_PROCESS_SHARED;
extern const long _POSIX_THREAD_SAFE_FUNCTIONS;
extern const long _POSIX_THREAD_THREADS_MAX;
extern const long _POSIX_TIMEOUTS;
extern const long _POSIX_TIMERS;
extern const long _POSIX_TIMER_MAX;
extern const long _POSIX_TRACE_EVENT_NAME_MAX;
extern const long _POSIX_TRACE_NAME_MAX;
extern const long _POSIX_TRACE_SYS_MAX;
extern const long _POSIX_TRACE_USER_EVENT_MAX;
extern const long _POSIX_TTY_NAME_MAX;
extern const long _POSIX_TZNAME_MAX;
extern const long _POSIX_V6_LP64_OFF64;
extern const long _POSIX_V7_LP64_OFF64;
extern const long _POSIX_VDISABLE;
extern const long _POSIX_VERSION;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define _POSIX_ADVISORY_INFO         SYMBOLIC(_POSIX_ADVISORY_INFO)
#define _POSIX_AIO_LISTIO_MAX        SYMBOLIC(_POSIX_AIO_LISTIO_MAX)
#define _POSIX_AIO_MAX               SYMBOLIC(_POSIX_AIO_MAX)
#define _POSIX_ARG_MAX               SYMBOLIC(_POSIX_ARG_MAX)
#define _POSIX_ASYNCHRONOUS_IO       SYMBOLIC(_POSIX_ASYNCHRONOUS_IO)
#define _POSIX_BARRIERS              SYMBOLIC(_POSIX_BARRIERS)
#define _POSIX_CHILD_MAX             SYMBOLIC(_POSIX_CHILD_MAX)
#define _POSIX_CHOWN_RESTRICTED      SYMBOLIC(_POSIX_CHOWN_RESTRICTED)
#define _POSIX_CLOCKRES_MIN          SYMBOLIC(_POSIX_CLOCKRES_MIN)
#define _POSIX_CLOCK_SELECTION       SYMBOLIC(_POSIX_CLOCK_SELECTION)
#define _POSIX_CPUTIME               SYMBOLIC(_POSIX_CPUTIME)
#define _POSIX_DELAYTIMER_MAX        SYMBOLIC(_POSIX_DELAYTIMER_MAX)
#define _POSIX_FSYNC                 SYMBOLIC(_POSIX_FSYNC)
#define _POSIX_HOST_NAME_MAX         SYMBOLIC(_POSIX_HOST_NAME_MAX)
#define _POSIX_IPV6                  SYMBOLIC(_POSIX_IPV6)
#define _POSIX_JOB_CONTROL           SYMBOLIC(_POSIX_JOB_CONTROL)
#define _POSIX_LINK_MAX              SYMBOLIC(_POSIX_LINK_MAX)
#define _POSIX_LOGIN_NAME_MAX        SYMBOLIC(_POSIX_LOGIN_NAME_MAX)
#define _POSIX_MAPPED_FILES          SYMBOLIC(_POSIX_MAPPED_FILES)
#define _POSIX_MAX_CANON             SYMBOLIC(_POSIX_MAX_CANON)
#define _POSIX_MAX_INPUT             SYMBOLIC(_POSIX_MAX_INPUT)
#define _POSIX_MEMLOCK               SYMBOLIC(_POSIX_MEMLOCK)
#define _POSIX_MEMLOCK_RANGE         SYMBOLIC(_POSIX_MEMLOCK_RANGE)
#define _POSIX_MEMORY_PROTECTION     SYMBOLIC(_POSIX_MEMORY_PROTECTION)
#define _POSIX_MESSAGE_PASSING       SYMBOLIC(_POSIX_MESSAGE_PASSING)
#define _POSIX_MONOTONIC_CLOCK       SYMBOLIC(_POSIX_MONOTONIC_CLOCK)
#define _POSIX_MQ_OPEN_MAX           SYMBOLIC(_POSIX_MQ_OPEN_MAX)
#define _POSIX_MQ_PRIO_MAX           SYMBOLIC(_POSIX_MQ_PRIO_MAX)
#define _POSIX_NAME_MAX              SYMBOLIC(_POSIX_NAME_MAX)
#define _POSIX_NGROUPS_MAX           SYMBOLIC(_POSIX_NGROUPS_MAX)
#define _POSIX_NO_TRUNC              SYMBOLIC(_POSIX_NO_TRUNC)
#define _POSIX_OPEN_MAX              SYMBOLIC(_POSIX_OPEN_MAX)
#define _POSIX_PATH_MAX              SYMBOLIC(_POSIX_PATH_MAX)
#define _POSIX_PIPE_BUF              SYMBOLIC(_POSIX_PIPE_BUF)
#define _POSIX_RAW_SOCKETS           SYMBOLIC(_POSIX_RAW_SOCKETS)
#define _POSIX_READER_WRITER_LOCKS   SYMBOLIC(_POSIX_READER_WRITER_LOCKS)
#define _POSIX_REALTIME_SIGNALS      SYMBOLIC(_POSIX_REALTIME_SIGNALS)
#define _POSIX_REGEXP                SYMBOLIC(_POSIX_REGEXP)
#define _POSIX_RE_DUP_MAX            SYMBOLIC(_POSIX_RE_DUP_MAX)
#define _POSIX_RTSIG_MAX             SYMBOLIC(_POSIX_RTSIG_MAX)
#define _POSIX_SAVED_IDS             SYMBOLIC(_POSIX_SAVED_IDS)
#define _POSIX_SEMAPHORES            SYMBOLIC(_POSIX_SEMAPHORES)
#define _POSIX_SEM_NSEMS_MAX         SYMBOLIC(_POSIX_SEM_NSEMS_MAX)
#define _POSIX_SEM_VALUE_MAX         SYMBOLIC(_POSIX_SEM_VALUE_MAX)
#define _POSIX_SHARED_MEMORY_OBJECTS SYMBOLIC(_POSIX_SHARED_MEMORY_OBJECTS)
#define _POSIX_SHELL                 SYMBOLIC(_POSIX_SHELL)
#define _POSIX_SIGQUEUE_MAX          SYMBOLIC(_POSIX_SIGQUEUE_MAX)
#define _POSIX_SPAWN                 SYMBOLIC(_POSIX_SPAWN)
#define _POSIX_SPIN_LOCKS            SYMBOLIC(_POSIX_SPIN_LOCKS)
#define _POSIX_SSIZE_MAX             SYMBOLIC(_POSIX_SSIZE_MAX)
#define _POSIX_SS_REPL_MAX           SYMBOLIC(_POSIX_SS_REPL_MAX)
#define _POSIX_STREAM_MAX            SYMBOLIC(_POSIX_STREAM_MAX)
#define _POSIX_SYMLINK_MAX           SYMBOLIC(_POSIX_SYMLINK_MAX)
#define _POSIX_SYMLOOP_MAX           SYMBOLIC(_POSIX_SYMLOOP_MAX)
#define _POSIX_THREADS               SYMBOLIC(_POSIX_THREADS)
#define _POSIX_THREAD_ATTR_STACKADDR SYMBOLIC(_POSIX_THREAD_ATTR_STACKADDR)
#define _POSIX_THREAD_ATTR_STACKSIZE SYMBOLIC(_POSIX_THREAD_ATTR_STACKSIZE)
#define _POSIX_THREAD_CPUTIME        SYMBOLIC(_POSIX_THREAD_CPUTIME)
#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS \
  SYMBOLIC(_POSIX_THREAD_DESTRUCTOR_ITERATIONS)
#define _POSIX_THREAD_KEYS_MAX SYMBOLIC(_POSIX_THREAD_KEYS_MAX)
#define _POSIX_THREAD_PRIORITY_SCHEDULING \
  SYMBOLIC(_POSIX_THREAD_PRIORITY_SCHEDULING)
#define _POSIX_THREAD_PROCESS_SHARED SYMBOLIC(_POSIX_THREAD_PROCESS_SHARED)
#define _POSIX_THREAD_SAFE_FUNCTIONS SYMBOLIC(_POSIX_THREAD_SAFE_FUNCTIONS)
#define _POSIX_THREAD_THREADS_MAX    SYMBOLIC(_POSIX_THREAD_THREADS_MAX)
#define _POSIX_TIMEOUTS              SYMBOLIC(_POSIX_TIMEOUTS)
#define _POSIX_TIMERS                SYMBOLIC(_POSIX_TIMERS)
#define _POSIX_TIMER_MAX             SYMBOLIC(_POSIX_TIMER_MAX)
#define _POSIX_TRACE_EVENT_NAME_MAX  SYMBOLIC(_POSIX_TRACE_EVENT_NAME_MAX)
#define _POSIX_TRACE_NAME_MAX        SYMBOLIC(_POSIX_TRACE_NAME_MAX)
#define _POSIX_TRACE_SYS_MAX         SYMBOLIC(_POSIX_TRACE_SYS_MAX)
#define _POSIX_TRACE_USER_EVENT_MAX  SYMBOLIC(_POSIX_TRACE_USER_EVENT_MAX)
#define _POSIX_TTY_NAME_MAX          SYMBOLIC(_POSIX_TTY_NAME_MAX)
#define _POSIX_TZNAME_MAX            SYMBOLIC(_POSIX_TZNAME_MAX)
#define _POSIX_V6_LP64_OFF64         SYMBOLIC(_POSIX_V6_LP64_OFF64)
#define _POSIX_V7_LP64_OFF64         SYMBOLIC(_POSIX_V7_LP64_OFF64)
#define _POSIX_VDISABLE              SYMBOLIC(_POSIX_VDISABLE)
#define _POSIX_VERSION               SYMBOLIC(_POSIX_VERSION)



/*!BEGIN libc/sysv/consts/posix.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_POSIX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long POSIX_FADV_DONTNEED;
extern const long POSIX_FADV_NOREUSE;
extern const long POSIX_FADV_NORMAL;
extern const long POSIX_FADV_RANDOM;
extern const long POSIX_FADV_SEQUENTIAL;
extern const long POSIX_FADV_WILLNEED;
extern const long POSIX_MADV_DONTNEED;
extern const long POSIX_MADV_NORMAL;
extern const long POSIX_MADV_RANDOM;
extern const long POSIX_MADV_SEQUENTIAL;
extern const long POSIX_MADV_WILLNEED;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define POSIX_FADV_DONTNEED   SYMBOLIC(POSIX_FADV_DONTNEED)
#define POSIX_FADV_NOREUSE    SYMBOLIC(POSIX_FADV_NOREUSE)
#define POSIX_FADV_NORMAL     SYMBOLIC(POSIX_FADV_NORMAL)
#define POSIX_FADV_RANDOM     SYMBOLIC(POSIX_FADV_RANDOM)
#define POSIX_FADV_SEQUENTIAL SYMBOLIC(POSIX_FADV_SEQUENTIAL)
#define POSIX_FADV_WILLNEED   SYMBOLIC(POSIX_FADV_WILLNEED)
#define POSIX_MADV_DONTNEED   SYMBOLIC(POSIX_MADV_DONTNEED)
#define POSIX_MADV_NORMAL     SYMBOLIC(POSIX_MADV_NORMAL)
#define POSIX_MADV_RANDOM     SYMBOLIC(POSIX_MADV_RANDOM)
#define POSIX_MADV_SEQUENTIAL SYMBOLIC(POSIX_MADV_SEQUENTIAL)
#define POSIX_MADV_WILLNEED   SYMBOLIC(POSIX_MADV_WILLNEED)



/*!BEGIN libc/sysv/consts/pr.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PR_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long PR_CAPBSET_DROP;
extern const long PR_CAPBSET_READ;
extern const long PR_CAP_AMBIENT;
extern const long PR_CAP_AMBIENT_CLEAR_ALL;
extern const long PR_CAP_AMBIENT_IS_SET;
extern const long PR_CAP_AMBIENT_LOWER;
extern const long PR_CAP_AMBIENT_RAISE;
extern const long PR_ENDIAN_BIG;
extern const long PR_ENDIAN_LITTLE;
extern const long PR_ENDIAN_PPC_LITTLE;
extern const long PR_FPEMU_NOPRINT;
extern const long PR_FPEMU_SIGFPE;
extern const long PR_FP_EXC_ASYNC;
extern const long PR_FP_EXC_DISABLED;
extern const long PR_FP_EXC_DIV;
extern const long PR_FP_EXC_INV;
extern const long PR_FP_EXC_NONRECOV;
extern const long PR_FP_EXC_OVF;
extern const long PR_FP_EXC_PRECISE;
extern const long PR_FP_EXC_RES;
extern const long PR_FP_EXC_SW_ENABLE;
extern const long PR_FP_EXC_UND;
extern const long PR_FP_MODE_FR;
extern const long PR_FP_MODE_FRE;
extern const long PR_GET_CHILD_SUBREAPER;
extern const long PR_GET_DUMPABLE;
extern const long PR_GET_ENDIAN;
extern const long PR_GET_FPEMU;
extern const long PR_GET_FPEXC;
extern const long PR_GET_FP_MODE;
extern const long PR_GET_KEEPCAPS;
extern const long PR_GET_NAME;
extern const long PR_GET_NO_NEW_PRIVS;
extern const long PR_GET_PDEATHSIG;
extern const long PR_GET_SECCOMP;
extern const long PR_GET_SECUREBITS;
extern const long PR_GET_SPECULATION_CTRL;
extern const long PR_GET_THP_DISABLE;
extern const long PR_GET_TID_ADDRESS;
extern const long PR_GET_TIMERSLACK;
extern const long PR_GET_TIMING;
extern const long PR_GET_TSC;
extern const long PR_GET_UNALIGN;
extern const long PR_MCE_KILL;
extern const long PR_MCE_KILL_CLEAR;
extern const long PR_MCE_KILL_DEFAULT;
extern const long PR_MCE_KILL_EARLY;
extern const long PR_MCE_KILL_GET;
extern const long PR_MCE_KILL_LATE;
extern const long PR_MCE_KILL_SET;
extern const long PR_MPX_DISABLE_MANAGEMENT;
extern const long PR_MPX_ENABLE_MANAGEMENT;
extern const long PR_SET_CHILD_SUBREAPER;
extern const long PR_SET_DUMPABLE;
extern const long PR_SET_ENDIAN;
extern const long PR_SET_FPEMU;
extern const long PR_SET_FPEXC;
extern const long PR_SET_FP_MODE;
extern const long PR_SET_KEEPCAPS;
extern const long PR_SET_MM;
extern const long PR_SET_MM_ARG_END;
extern const long PR_SET_MM_ARG_START;
extern const long PR_SET_MM_AUXV;
extern const long PR_SET_MM_BRK;
extern const long PR_SET_MM_END_CODE;
extern const long PR_SET_MM_END_DATA;
extern const long PR_SET_MM_ENV_END;
extern const long PR_SET_MM_ENV_START;
extern const long PR_SET_MM_EXE_FILE;
extern const long PR_SET_MM_MAP;
extern const long PR_SET_MM_MAP_SIZE;
extern const long PR_SET_MM_START_BRK;
extern const long PR_SET_MM_START_CODE;
extern const long PR_SET_MM_START_DATA;
extern const long PR_SET_MM_START_STACK;
extern const long PR_SET_NAME;
extern const long PR_SET_NO_NEW_PRIVS;
extern const long PR_SET_PDEATHSIG;
extern const long PR_SET_PTRACER;
extern const long PR_SET_PTRACER_ANY;
extern const long PR_SET_SECCOMP;
extern const long PR_SET_SECUREBITS;
extern const long PR_SET_SPECULATION_CTRL;
extern const long PR_SET_THP_DISABLE;
extern const long PR_SET_TIMERSLACK;
extern const long PR_SET_TIMING;
extern const long PR_SET_TSC;
extern const long PR_SET_UNALIGN;
extern const long PR_SPEC_DISABLE;
extern const long PR_SPEC_ENABLE;
extern const long PR_SPEC_FORCE_DISABLE;
extern const long PR_SPEC_NOT_AFFECTED;
extern const long PR_SPEC_PRCTL;
extern const long PR_SPEC_STORE_BYPASS;
extern const long PR_TASK_PERF_EVENTS_DISABLE;
extern const long PR_TASK_PERF_EVENTS_ENABLE;
extern const long PR_TIMING_STATISTICAL;
extern const long PR_TIMING_TIMESTAMP;
extern const long PR_TSC_ENABLE;
extern const long PR_TSC_SIGSEGV;
extern const long PR_UNALIGN_NOPRINT;
extern const long PR_UNALIGN_SIGBUS;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PR_CAPBSET_DROP             SYMBOLIC(PR_CAPBSET_DROP)
#define PR_CAPBSET_READ             SYMBOLIC(PR_CAPBSET_READ)
#define PR_CAP_AMBIENT              SYMBOLIC(PR_CAP_AMBIENT)
#define PR_CAP_AMBIENT_CLEAR_ALL    SYMBOLIC(PR_CAP_AMBIENT_CLEAR_ALL)
#define PR_CAP_AMBIENT_IS_SET       SYMBOLIC(PR_CAP_AMBIENT_IS_SET)
#define PR_CAP_AMBIENT_LOWER        SYMBOLIC(PR_CAP_AMBIENT_LOWER)
#define PR_CAP_AMBIENT_RAISE        SYMBOLIC(PR_CAP_AMBIENT_RAISE)
#define PR_ENDIAN_BIG               SYMBOLIC(PR_ENDIAN_BIG)
#define PR_ENDIAN_LITTLE            SYMBOLIC(PR_ENDIAN_LITTLE)
#define PR_ENDIAN_PPC_LITTLE        SYMBOLIC(PR_ENDIAN_PPC_LITTLE)
#define PR_FPEMU_NOPRINT            SYMBOLIC(PR_FPEMU_NOPRINT)
#define PR_FPEMU_SIGFPE             SYMBOLIC(PR_FPEMU_SIGFPE)
#define PR_FP_EXC_ASYNC             SYMBOLIC(PR_FP_EXC_ASYNC)
#define PR_FP_EXC_DISABLED          SYMBOLIC(PR_FP_EXC_DISABLED)
#define PR_FP_EXC_DIV               SYMBOLIC(PR_FP_EXC_DIV)
#define PR_FP_EXC_INV               SYMBOLIC(PR_FP_EXC_INV)
#define PR_FP_EXC_NONRECOV          SYMBOLIC(PR_FP_EXC_NONRECOV)
#define PR_FP_EXC_OVF               SYMBOLIC(PR_FP_EXC_OVF)
#define PR_FP_EXC_PRECISE           SYMBOLIC(PR_FP_EXC_PRECISE)
#define PR_FP_EXC_RES               SYMBOLIC(PR_FP_EXC_RES)
#define PR_FP_EXC_SW_ENABLE         SYMBOLIC(PR_FP_EXC_SW_ENABLE)
#define PR_FP_EXC_UND               SYMBOLIC(PR_FP_EXC_UND)
#define PR_FP_MODE_FR               SYMBOLIC(PR_FP_MODE_FR)
#define PR_FP_MODE_FRE              SYMBOLIC(PR_FP_MODE_FRE)
#define PR_GET_CHILD_SUBREAPER      SYMBOLIC(PR_GET_CHILD_SUBREAPER)
#define PR_GET_DUMPABLE             SYMBOLIC(PR_GET_DUMPABLE)
#define PR_GET_ENDIAN               SYMBOLIC(PR_GET_ENDIAN)
#define PR_GET_FPEMU                SYMBOLIC(PR_GET_FPEMU)
#define PR_GET_FPEXC                SYMBOLIC(PR_GET_FPEXC)
#define PR_GET_FP_MODE              SYMBOLIC(PR_GET_FP_MODE)
#define PR_GET_KEEPCAPS             SYMBOLIC(PR_GET_KEEPCAPS)
#define PR_GET_NAME                 SYMBOLIC(PR_GET_NAME)
#define PR_GET_NO_NEW_PRIVS         SYMBOLIC(PR_GET_NO_NEW_PRIVS)
#define PR_GET_PDEATHSIG            SYMBOLIC(PR_GET_PDEATHSIG)
#define PR_GET_SECCOMP              SYMBOLIC(PR_GET_SECCOMP)
#define PR_GET_SECUREBITS           SYMBOLIC(PR_GET_SECUREBITS)
#define PR_GET_SPECULATION_CTRL     SYMBOLIC(PR_GET_SPECULATION_CTRL)
#define PR_GET_THP_DISABLE          SYMBOLIC(PR_GET_THP_DISABLE)
#define PR_GET_TID_ADDRESS          SYMBOLIC(PR_GET_TID_ADDRESS)
#define PR_GET_TIMERSLACK           SYMBOLIC(PR_GET_TIMERSLACK)
#define PR_GET_TIMING               SYMBOLIC(PR_GET_TIMING)
#define PR_GET_TSC                  SYMBOLIC(PR_GET_TSC)
#define PR_GET_UNALIGN              SYMBOLIC(PR_GET_UNALIGN)
#define PR_MCE_KILL                 SYMBOLIC(PR_MCE_KILL)
#define PR_MCE_KILL_CLEAR           SYMBOLIC(PR_MCE_KILL_CLEAR)
#define PR_MCE_KILL_DEFAULT         SYMBOLIC(PR_MCE_KILL_DEFAULT)
#define PR_MCE_KILL_EARLY           SYMBOLIC(PR_MCE_KILL_EARLY)
#define PR_MCE_KILL_GET             SYMBOLIC(PR_MCE_KILL_GET)
#define PR_MCE_KILL_LATE            SYMBOLIC(PR_MCE_KILL_LATE)
#define PR_MCE_KILL_SET             SYMBOLIC(PR_MCE_KILL_SET)
#define PR_MPX_DISABLE_MANAGEMENT   SYMBOLIC(PR_MPX_DISABLE_MANAGEMENT)
#define PR_MPX_ENABLE_MANAGEMENT    SYMBOLIC(PR_MPX_ENABLE_MANAGEMENT)
#define PR_SET_CHILD_SUBREAPER      SYMBOLIC(PR_SET_CHILD_SUBREAPER)
#define PR_SET_DUMPABLE             SYMBOLIC(PR_SET_DUMPABLE)
#define PR_SET_ENDIAN               SYMBOLIC(PR_SET_ENDIAN)
#define PR_SET_FPEMU                SYMBOLIC(PR_SET_FPEMU)
#define PR_SET_FPEXC                SYMBOLIC(PR_SET_FPEXC)
#define PR_SET_FP_MODE              SYMBOLIC(PR_SET_FP_MODE)
#define PR_SET_KEEPCAPS             SYMBOLIC(PR_SET_KEEPCAPS)
#define PR_SET_MM                   SYMBOLIC(PR_SET_MM)
#define PR_SET_MM_ARG_END           SYMBOLIC(PR_SET_MM_ARG_END)
#define PR_SET_MM_ARG_START         SYMBOLIC(PR_SET_MM_ARG_START)
#define PR_SET_MM_AUXV              SYMBOLIC(PR_SET_MM_AUXV)
#define PR_SET_MM_BRK               SYMBOLIC(PR_SET_MM_BRK)
#define PR_SET_MM_END_CODE          SYMBOLIC(PR_SET_MM_END_CODE)
#define PR_SET_MM_END_DATA          SYMBOLIC(PR_SET_MM_END_DATA)
#define PR_SET_MM_ENV_END           SYMBOLIC(PR_SET_MM_ENV_END)
#define PR_SET_MM_ENV_START         SYMBOLIC(PR_SET_MM_ENV_START)
#define PR_SET_MM_EXE_FILE          SYMBOLIC(PR_SET_MM_EXE_FILE)
#define PR_SET_MM_MAP               SYMBOLIC(PR_SET_MM_MAP)
#define PR_SET_MM_MAP_SIZE          SYMBOLIC(PR_SET_MM_MAP_SIZE)
#define PR_SET_MM_START_BRK         SYMBOLIC(PR_SET_MM_START_BRK)
#define PR_SET_MM_START_CODE        SYMBOLIC(PR_SET_MM_START_CODE)
#define PR_SET_MM_START_DATA        SYMBOLIC(PR_SET_MM_START_DATA)
#define PR_SET_MM_START_STACK       SYMBOLIC(PR_SET_MM_START_STACK)
#define PR_SET_NAME                 SYMBOLIC(PR_SET_NAME)
#define PR_SET_NO_NEW_PRIVS         SYMBOLIC(PR_SET_NO_NEW_PRIVS)
#define PR_SET_PDEATHSIG            SYMBOLIC(PR_SET_PDEATHSIG)
#define PR_SET_PTRACER              SYMBOLIC(PR_SET_PTRACER)
#define PR_SET_PTRACER_ANY          SYMBOLIC(PR_SET_PTRACER_ANY)
#define PR_SET_SECCOMP              SYMBOLIC(PR_SET_SECCOMP)
#define PR_SET_SECUREBITS           SYMBOLIC(PR_SET_SECUREBITS)
#define PR_SET_SPECULATION_CTRL     SYMBOLIC(PR_SET_SPECULATION_CTRL)
#define PR_SET_THP_DISABLE          SYMBOLIC(PR_SET_THP_DISABLE)
#define PR_SET_TIMERSLACK           SYMBOLIC(PR_SET_TIMERSLACK)
#define PR_SET_TIMING               SYMBOLIC(PR_SET_TIMING)
#define PR_SET_TSC                  SYMBOLIC(PR_SET_TSC)
#define PR_SET_UNALIGN              SYMBOLIC(PR_SET_UNALIGN)
#define PR_SPEC_DISABLE             SYMBOLIC(PR_SPEC_DISABLE)
#define PR_SPEC_ENABLE              SYMBOLIC(PR_SPEC_ENABLE)
#define PR_SPEC_FORCE_DISABLE       SYMBOLIC(PR_SPEC_FORCE_DISABLE)
#define PR_SPEC_NOT_AFFECTED        SYMBOLIC(PR_SPEC_NOT_AFFECTED)
#define PR_SPEC_PRCTL               SYMBOLIC(PR_SPEC_PRCTL)
#define PR_SPEC_STORE_BYPASS        SYMBOLIC(PR_SPEC_STORE_BYPASS)
#define PR_TASK_PERF_EVENTS_DISABLE SYMBOLIC(PR_TASK_PERF_EVENTS_DISABLE)
#define PR_TASK_PERF_EVENTS_ENABLE  SYMBOLIC(PR_TASK_PERF_EVENTS_ENABLE)
#define PR_TIMING_STATISTICAL       SYMBOLIC(PR_TIMING_STATISTICAL)
#define PR_TIMING_TIMESTAMP         SYMBOLIC(PR_TIMING_TIMESTAMP)
#define PR_TSC_ENABLE               SYMBOLIC(PR_TSC_ENABLE)
#define PR_TSC_SIGSEGV              SYMBOLIC(PR_TSC_SIGSEGV)
#define PR_UNALIGN_NOPRINT          SYMBOLIC(PR_UNALIGN_NOPRINT)
#define PR_UNALIGN_SIGBUS           SYMBOLIC(PR_UNALIGN_SIGBUS)



/*!BEGIN libc/sysv/consts/prio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PRIO_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long PRIO_MAX;
extern const long PRIO_MIN;
extern const long PRIO_PGRP;
extern const long PRIO_PROCESS;
extern const long PRIO_USER;
extern const long NZERO;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PRIO_PROCESS LITERALLY(0)
#define PRIO_PGRP    LITERALLY(1)
#define PRIO_USER    LITERALLY(2)
#define PRIO_MIN     LITERALLY(-20)
#define PRIO_MAX     LITERALLY(20)
#define NZERO        LITERALLY(20)



/*!BEGIN libc/sysv/consts/prot.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PROT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long PROT_NONE;
extern const long PROT_READ;
extern const long PROT_WRITE;
extern const long PROT_EXEC;
extern const long PROT_GROWSDOWN;
extern const long PROT_GROWSUP;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PROT_NONE 0
#define PROT_READ 1
#define PROT_WRITE 2
#define PROT_EXEC 4
#define PROT_GROWSDOWN SYMBOLIC(PROT_GROWSDOWN)
#define PROT_GROWSUP SYMBOLIC(PROT_GROWSUP)



/*!BEGIN libc/sysv/consts/pt.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PT_H_


/*!BEGIN libc/sysv/consts/ptrace.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PTRACE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long PTRACE_TRACEME;
extern const long PTRACE_PEEKTEXT;
extern const long PTRACE_PEEKDATA;
extern const long PTRACE_PEEKUSER;
extern const long PTRACE_POKETEXT;
extern const long PTRACE_POKEDATA;
extern const long PTRACE_POKEUSER;
extern const long PTRACE_CONT;
extern const long PTRACE_KILL;
extern const long PTRACE_SINGLESTEP;
extern const long PTRACE_GETREGS;
extern const long PTRACE_SETREGS;
extern const long PTRACE_GETFPREGS;
extern const long PTRACE_SETFPREGS;
extern const long PTRACE_ATTACH;
extern const long PTRACE_DETACH;
extern const long PTRACE_GETFPXREGS;
extern const long PTRACE_SETFPXREGS;
extern const long PTRACE_SYSCALL;
extern const long PTRACE_GETEVENTMSG;
extern const long PTRACE_GETSIGINFO;
extern const long PTRACE_SETOPTIONS;
extern const long PTRACE_SETSIGINFO;
extern const long PTRACE_GETREGSET;
extern const long PTRACE_GETSIGMASK;
extern const long PTRACE_INTERRUPT;
extern const long PTRACE_LISTEN;
extern const long PTRACE_PEEKSIGINFO;
extern const long PTRACE_SECCOMP_GET_FILTER;
extern const long PTRACE_SEIZE;
extern const long PTRACE_SETREGSET;
extern const long PTRACE_SETSIGMASK;
extern const long PTRACE_O_TRACESYSGOOD;
extern const long PTRACE_O_TRACEFORK;
extern const long PTRACE_O_TRACEVFORK;
extern const long PTRACE_O_TRACECLONE;
extern const long PTRACE_O_TRACEEXEC;
extern const long PTRACE_O_TRACEVFORKDONE;
extern const long PTRACE_O_TRACEEXIT;
extern const long PTRACE_O_MASK;
extern const long PTRACE_EVENT_FORK;
extern const long PTRACE_EVENT_VFORK;
extern const long PTRACE_EVENT_CLONE;
extern const long PTRACE_EVENT_EXEC;
extern const long PTRACE_EVENT_VFORK_DONE;
extern const long PTRACE_EVENT_EXIT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define PTRACE_TRACEME            SYMBOLIC(PTRACE_TRACEME)
#define PTRACE_PEEKTEXT           SYMBOLIC(PTRACE_PEEKTEXT)
#define PTRACE_PEEKDATA           SYMBOLIC(PTRACE_PEEKDATA)
#define PTRACE_PEEKUSER           SYMBOLIC(PTRACE_PEEKUSER)
#define PTRACE_POKETEXT           SYMBOLIC(PTRACE_POKETEXT)
#define PTRACE_POKEDATA           SYMBOLIC(PTRACE_POKEDATA)
#define PTRACE_POKEUSER           SYMBOLIC(PTRACE_POKEUSER)
#define PTRACE_CONT               SYMBOLIC(PTRACE_CONT)
#define PTRACE_KILL               SYMBOLIC(PTRACE_KILL)
#define PTRACE_SINGLESTEP         SYMBOLIC(PTRACE_SINGLESTEP)
#define PTRACE_GETREGS            SYMBOLIC(PTRACE_GETREGS)
#define PTRACE_SETREGS            SYMBOLIC(PTRACE_SETREGS)
#define PTRACE_GETFPREGS          SYMBOLIC(PTRACE_GETFPREGS)
#define PTRACE_SETFPREGS          SYMBOLIC(PTRACE_SETFPREGS)
#define PTRACE_ATTACH             SYMBOLIC(PTRACE_ATTACH)
#define PTRACE_DETACH             SYMBOLIC(PTRACE_DETACH)
#define PTRACE_GETFPXREGS         SYMBOLIC(PTRACE_GETFPXREGS)
#define PTRACE_SETFPXREGS         SYMBOLIC(PTRACE_SETFPXREGS)
#define PTRACE_SYSCALL            SYMBOLIC(PTRACE_SYSCALL)
#define PTRACE_GETEVENTMSG        SYMBOLIC(PTRACE_GETEVENTMSG)
#define PTRACE_GETSIGINFO         SYMBOLIC(PTRACE_GETSIGINFO)
#define PTRACE_SETOPTIONS         SYMBOLIC(PTRACE_SETOPTIONS)
#define PTRACE_SETSIGINFO         SYMBOLIC(PTRACE_SETSIGINFO)
#define PTRACE_GETREGSET          SYMBOLIC(PTRACE_GETREGSET)
#define PTRACE_GETSIGMASK         SYMBOLIC(PTRACE_GETSIGMASK)
#define PTRACE_INTERRUPT          SYMBOLIC(PTRACE_INTERRUPT)
#define PTRACE_LISTEN             SYMBOLIC(PTRACE_LISTEN)
#define PTRACE_PEEKSIGINFO        SYMBOLIC(PTRACE_PEEKSIGINFO)
#define PTRACE_SECCOMP_GET_FILTER SYMBOLIC(PTRACE_SECCOMP_GET_FILTER)
#define PTRACE_SEIZE              SYMBOLIC(PTRACE_SEIZE)
#define PTRACE_SETREGSET          SYMBOLIC(PTRACE_SETREGSET)
#define PTRACE_SETSIGMASK         SYMBOLIC(PTRACE_SETSIGMASK)
#define PTRACE_O_TRACESYSGOOD     SYMBOLIC(PTRACE_O_TRACESYSGOOD)
#define PTRACE_O_TRACEFORK        SYMBOLIC(PTRACE_O_TRACEFORK)
#define PTRACE_O_TRACEVFORK       SYMBOLIC(PTRACE_O_TRACEVFORK)
#define PTRACE_O_TRACECLONE       SYMBOLIC(PTRACE_O_TRACECLONE)
#define PTRACE_O_TRACEEXEC        SYMBOLIC(PTRACE_O_TRACEEXEC)
#define PTRACE_O_TRACEVFORKDONE   SYMBOLIC(PTRACE_O_TRACEVFORKDONE)
#define PTRACE_O_TRACEEXIT        SYMBOLIC(PTRACE_O_TRACEEXIT)
#define PTRACE_O_MASK             SYMBOLIC(PTRACE_O_MASK)
#define PTRACE_EVENT_FORK         SYMBOLIC(PTRACE_EVENT_FORK)
#define PTRACE_EVENT_VFORK        SYMBOLIC(PTRACE_EVENT_VFORK)
#define PTRACE_EVENT_CLONE        SYMBOLIC(PTRACE_EVENT_CLONE)
#define PTRACE_EVENT_EXEC         SYMBOLIC(PTRACE_EVENT_EXEC)
#define PTRACE_EVENT_VFORK_DONE   SYMBOLIC(PTRACE_EVENT_VFORK_DONE)
#define PTRACE_EVENT_EXIT         SYMBOLIC(PTRACE_EVENT_EXIT)


#define PT_ATTACH      PTRACE_ATTACH
#define PT_CONTINUE    PTRACE_CONT
#define PT_DETACH      PTRACE_DETACH
#define PT_GETEVENTMSG PTRACE_GETEVENTMSG
#define PT_GETFPREGS   PTRACE_GETFPREGS
#define PT_GETFPXREGS  PTRACE_GETFPXREGS
#define PT_GETREGS     PTRACE_GETREGS
#define PT_GETSIGINFO  PTRACE_GETSIGINFO
#define PT_KILL        PTRACE_KILL
#define PT_READ_D      PTRACE_PEEKDATA
#define PT_READ_I      PTRACE_PEEKTEXT
#define PT_READ_U      PTRACE_PEEKUSER
#define PT_SETFPREGS   PTRACE_SETFPREGS
#define PT_SETFPXREGS  PTRACE_SETFPXREGS
#define PT_SETOPTIONS  PTRACE_SETOPTIONS
#define PT_SETREGS     PTRACE_SETREGS
#define PT_SETSIGINFO  PTRACE_SETSIGINFO
#define PT_STEP        PTRACE_SINGLESTEP
#define PT_SYSCALL     PTRACE_SYSCALL
#define PT_WRITE_D     PTRACE_POKEDATA
#define PT_WRITE_I     PTRACE_POKETEXT
#define PT_WRITE_U     PTRACE_POKEUSER



/*!BEGIN libc/sysv/consts/pty.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_PTY_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long TIOCPKT;
extern const long TIOCPKT_DATA;
extern const long TIOCPKT_DOSTOP;
extern const long TIOCPKT_FLUSHREAD;
extern const long TIOCPKT_FLUSHWRITE;
extern const long TIOCPKT_IOCTL;
extern const long TIOCPKT_NOSTOP;
extern const long TIOCPKT_START;
extern const long TIOCPKT_STOP;
extern const long TIOCSPTLCK;
extern const long PTMGET;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define TIOCPKT            SYMBOLIC(TIOCPKT)
#define TIOCSPTLCK         SYMBOLIC(TIOCSPTLCK)
#define PTMGET             SYMBOLIC(PTMGET)
#define TIOCPKT_DATA       LITERALLY(0x00)
#define TIOCPKT_DOSTOP     LITERALLY(0x01)
#define TIOCPKT_FLUSHREAD  LITERALLY(0x02)
#define TIOCPKT_FLUSHWRITE LITERALLY(0x04)
#define TIOCPKT_IOCTL      LITERALLY(0x08)
#define TIOCPKT_NOSTOP     LITERALLY(0x10)
#define TIOCPKT_START      LITERALLY(0x20)
#define TIOCPKT_STOP       LITERALLY(0x40)



/*!BEGIN libc/sysv/consts/read.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_READ_H_

#define READ_10 SYMBOLIC(READ_10)
#define READ_12 SYMBOLIC(READ_12)
#define READ_6 SYMBOLIC(READ_6)
#define READ_BLOCK_LIMITS SYMBOLIC(READ_BLOCK_LIMITS)
#define READ_BUFFER SYMBOLIC(READ_BUFFER)
#define READ_CAPACITY SYMBOLIC(READ_CAPACITY)
#define READ_DEFECT_DATA SYMBOLIC(READ_DEFECT_DATA)
#define READ_ELEMENT_STATUS SYMBOLIC(READ_ELEMENT_STATUS)
#define READ_LONG SYMBOLIC(READ_LONG)
#define READ_POSITION SYMBOLIC(READ_POSITION)
#define READ_REVERSE SYMBOLIC(READ_REVERSE)
#define READ_TOC SYMBOLIC(READ_TOC)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long READ_10;
extern const long READ_12;
extern const long READ_6;
extern const long READ_BLOCK_LIMITS;
extern const long READ_BUFFER;
extern const long READ_CAPACITY;
extern const long READ_DEFECT_DATA;
extern const long READ_ELEMENT_STATUS;
extern const long READ_LONG;
extern const long READ_POSITION;
extern const long READ_REVERSE;
extern const long READ_TOC;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/rlim.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_RLIM_H_

#define RLIM_INFINITY SYMBOLIC(RLIM_INFINITY)
#define RLIM_NLIMITS SYMBOLIC(RLIM_NLIMITS)
#define RLIM_SAVED_CUR SYMBOLIC(RLIM_SAVED_CUR)
#define RLIM_SAVED_MAX SYMBOLIC(RLIM_SAVED_MAX)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long RLIM_INFINITY;
extern const long RLIM_NLIMITS;
extern const long RLIM_SAVED_CUR;
extern const long RLIM_SAVED_MAX;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/rlimit.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_RLIMIT_H_

#define RLIMIT_AS SYMBOLIC(RLIMIT_AS)
#define RLIMIT_CORE SYMBOLIC(RLIMIT_CORE)
#define RLIMIT_CPU SYMBOLIC(RLIMIT_CPU)
#define RLIMIT_DATA SYMBOLIC(RLIMIT_DATA)
#define RLIMIT_FSIZE SYMBOLIC(RLIMIT_FSIZE)
#define RLIMIT_LOCKS SYMBOLIC(RLIMIT_LOCKS)
#define RLIMIT_MEMLOCK SYMBOLIC(RLIMIT_MEMLOCK)
#define RLIMIT_MSGQUEUE SYMBOLIC(RLIMIT_MSGQUEUE)
#define RLIMIT_NICE SYMBOLIC(RLIMIT_NICE)
#define RLIMIT_NLIMITS SYMBOLIC(RLIMIT_NLIMITS)
#define RLIMIT_NOFILE SYMBOLIC(RLIMIT_NOFILE)
#define RLIMIT_NPROC SYMBOLIC(RLIMIT_NPROC)
#define RLIMIT_RSS SYMBOLIC(RLIMIT_RSS)
#define RLIMIT_RTPRIO SYMBOLIC(RLIMIT_RTPRIO)
#define RLIMIT_SIGPENDING SYMBOLIC(RLIMIT_SIGPENDING)
#define RLIMIT_STACK SYMBOLIC(RLIMIT_STACK)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long RLIMIT_AS;
extern const long RLIMIT_CORE;
extern const long RLIMIT_CPU;
extern const long RLIMIT_DATA;
extern const long RLIMIT_FSIZE;
extern const long RLIMIT_LOCKS;
extern const long RLIMIT_MEMLOCK;
extern const long RLIMIT_MSGQUEUE;
extern const long RLIMIT_NICE;
extern const long RLIMIT_NLIMITS;
extern const long RLIMIT_NOFILE;
extern const long RLIMIT_NPROC;
extern const long RLIMIT_RSS;
extern const long RLIMIT_RTPRIO;
extern const long RLIMIT_SIGPENDING;
extern const long RLIMIT_STACK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/rtld.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_RTLD_H_

#define RTLD_DI_LINKMAP SYMBOLIC(RTLD_DI_LINKMAP)
#define RTLD_GLOBAL SYMBOLIC(RTLD_GLOBAL)
#define RTLD_LAZY SYMBOLIC(RTLD_LAZY)
#define RTLD_LOCAL SYMBOLIC(RTLD_LOCAL)
#define RTLD_NODELETE SYMBOLIC(RTLD_NODELETE)
#define RTLD_NOLOAD SYMBOLIC(RTLD_NOLOAD)
#define RTLD_NOW SYMBOLIC(RTLD_NOW)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long RTLD_DI_LINKMAP;
extern const long RTLD_GLOBAL;
extern const long RTLD_LAZY;
extern const long RTLD_LOCAL;
extern const long RTLD_NODELETE;
extern const long RTLD_NOLOAD;
extern const long RTLD_NOW;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/rusage.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_RUSAGE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long RUSAGE_CHILDREN;
extern const long RUSAGE_SELF;
extern const long RUSAGE_THREAD;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define RUSAGE_SELF LITERALLY(0)
#define RUSAGE_CHILDREN SYMBOLIC(RUSAGE_CHILDREN)
#define RUSAGE_THREAD SYMBOLIC(RUSAGE_THREAD)



/*!BEGIN libc/sysv/consts/sa.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SA_H_

#define SA_NOCLDSTOP SYMBOLIC(SA_NOCLDSTOP)
#define SA_NOCLDWAIT SYMBOLIC(SA_NOCLDWAIT)
#define SA_NODEFER SYMBOLIC(SA_NODEFER)
#define SA_NOMASK SYMBOLIC(SA_NOMASK)
#define SA_ONESHOT SYMBOLIC(SA_ONESHOT)
#define SA_ONSTACK SYMBOLIC(SA_ONSTACK)
#define SA_RESETHAND SYMBOLIC(SA_RESETHAND)
#define SA_RESTART SYMBOLIC(SA_RESTART)
#define SA_RESTORER SYMBOLIC(SA_RESTORER)
#define SA_SIGINFO SYMBOLIC(SA_SIGINFO)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SA_NOCLDSTOP;
extern const long SA_NOCLDWAIT;
extern const long SA_NODEFER;
extern const long SA_NOMASK;
extern const long SA_ONESHOT;
extern const long SA_ONSTACK;
extern const long SA_RESETHAND;
extern const long SA_RESTART;
extern const long SA_RESTORER;
extern const long SA_SIGINFO;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/sched.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SCHED_H_

#define SCHED_BATCH SYMBOLIC(SCHED_BATCH)
#define SCHED_FIFO SYMBOLIC(SCHED_FIFO)
#define SCHED_IDLE SYMBOLIC(SCHED_IDLE)
#define SCHED_OTHER SYMBOLIC(SCHED_OTHER)
#define SCHED_RESET_ON_FORK SYMBOLIC(SCHED_RESET_ON_FORK)
#define SCHED_RR SYMBOLIC(SCHED_RR)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SCHED_BATCH;
extern const long SCHED_FIFO;
extern const long SCHED_IDLE;
extern const long SCHED_OTHER;
extern const long SCHED_RESET_ON_FORK;
extern const long SCHED_RR;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/scsi.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SCSI_H_

#define SCSI_IOCTL_BENCHMARK_COMMAND SYMBOLIC(SCSI_IOCTL_BENCHMARK_COMMAND)
#define SCSI_IOCTL_DOORLOCK SYMBOLIC(SCSI_IOCTL_DOORLOCK)
#define SCSI_IOCTL_DOORUNLOCK SYMBOLIC(SCSI_IOCTL_DOORUNLOCK)
#define SCSI_IOCTL_GET_BUS_NUMBER SYMBOLIC(SCSI_IOCTL_GET_BUS_NUMBER)
#define SCSI_IOCTL_GET_IDLUN SYMBOLIC(SCSI_IOCTL_GET_IDLUN)
#define SCSI_IOCTL_PROBE_HOST SYMBOLIC(SCSI_IOCTL_PROBE_HOST)
#define SCSI_IOCTL_SEND_COMMAND SYMBOLIC(SCSI_IOCTL_SEND_COMMAND)
#define SCSI_IOCTL_START_UNIT SYMBOLIC(SCSI_IOCTL_START_UNIT)
#define SCSI_IOCTL_STOP_UNIT SYMBOLIC(SCSI_IOCTL_STOP_UNIT)
#define SCSI_IOCTL_SYNC SYMBOLIC(SCSI_IOCTL_SYNC)
#define SCSI_IOCTL_TAGGED_DISABLE SYMBOLIC(SCSI_IOCTL_TAGGED_DISABLE)
#define SCSI_IOCTL_TAGGED_ENABLE SYMBOLIC(SCSI_IOCTL_TAGGED_ENABLE)
#define SCSI_IOCTL_TEST_UNIT_READY SYMBOLIC(SCSI_IOCTL_TEST_UNIT_READY)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SCSI_IOCTL_BENCHMARK_COMMAND;
extern const long SCSI_IOCTL_DOORLOCK;
extern const long SCSI_IOCTL_DOORUNLOCK;
extern const long SCSI_IOCTL_GET_BUS_NUMBER;
extern const long SCSI_IOCTL_GET_IDLUN;
extern const long SCSI_IOCTL_PROBE_HOST;
extern const long SCSI_IOCTL_SEND_COMMAND;
extern const long SCSI_IOCTL_START_UNIT;
extern const long SCSI_IOCTL_STOP_UNIT;
extern const long SCSI_IOCTL_SYNC;
extern const long SCSI_IOCTL_TAGGED_DISABLE;
extern const long SCSI_IOCTL_TAGGED_ENABLE;
extern const long SCSI_IOCTL_TEST_UNIT_READY;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/segv.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SEGV_H_

#define SEGV_ACCERR SYMBOLIC(SEGV_ACCERR)
#define SEGV_MAPERR SYMBOLIC(SEGV_MAPERR)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SEGV_ACCERR;
extern const long SEGV_MAPERR;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/sg.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SG_H_

#define SG_BIG_BUFF SYMBOLIC(SG_BIG_BUFF)
#define SG_DEFAULT_RETRIES SYMBOLIC(SG_DEFAULT_RETRIES)
#define SG_DEFAULT_TIMEOUT SYMBOLIC(SG_DEFAULT_TIMEOUT)
#define SG_DEF_COMMAND_Q SYMBOLIC(SG_DEF_COMMAND_Q)
#define SG_DEF_FORCE_LOW_DMA SYMBOLIC(SG_DEF_FORCE_LOW_DMA)
#define SG_DEF_FORCE_PACK_ID SYMBOLIC(SG_DEF_FORCE_PACK_ID)
#define SG_DEF_KEEP_ORPHAN SYMBOLIC(SG_DEF_KEEP_ORPHAN)
#define SG_DEF_RESERVED_SIZE SYMBOLIC(SG_DEF_RESERVED_SIZE)
#define SG_DEF_UNDERRUN_FLAG SYMBOLIC(SG_DEF_UNDERRUN_FLAG)
#define SG_DXFER_FROM_DEV SYMBOLIC(SG_DXFER_FROM_DEV)
#define SG_DXFER_NONE SYMBOLIC(SG_DXFER_NONE)
#define SG_DXFER_TO_DEV SYMBOLIC(SG_DXFER_TO_DEV)
#define SG_DXFER_TO_FROM_DEV SYMBOLIC(SG_DXFER_TO_FROM_DEV)
#define SG_EMULATED_HOST SYMBOLIC(SG_EMULATED_HOST)
#define SG_FLAG_DIRECT_IO SYMBOLIC(SG_FLAG_DIRECT_IO)
#define SG_FLAG_LUN_INHIBIT SYMBOLIC(SG_FLAG_LUN_INHIBIT)
#define SG_FLAG_NO_DXFER SYMBOLIC(SG_FLAG_NO_DXFER)
#define SG_GET_COMMAND_Q SYMBOLIC(SG_GET_COMMAND_Q)
#define SG_GET_KEEP_ORPHAN SYMBOLIC(SG_GET_KEEP_ORPHAN)
#define SG_GET_LOW_DMA SYMBOLIC(SG_GET_LOW_DMA)
#define SG_GET_NUM_WAITING SYMBOLIC(SG_GET_NUM_WAITING)
#define SG_GET_PACK_ID SYMBOLIC(SG_GET_PACK_ID)
#define SG_GET_REQUEST_TABLE SYMBOLIC(SG_GET_REQUEST_TABLE)
#define SG_GET_RESERVED_SIZE SYMBOLIC(SG_GET_RESERVED_SIZE)
#define SG_GET_SCSI_ID SYMBOLIC(SG_GET_SCSI_ID)
#define SG_GET_SG_TABLESIZE SYMBOLIC(SG_GET_SG_TABLESIZE)
#define SG_GET_TIMEOUT SYMBOLIC(SG_GET_TIMEOUT)
#define SG_GET_TRANSFORM SYMBOLIC(SG_GET_TRANSFORM)
#define SG_GET_VERSION_NUM SYMBOLIC(SG_GET_VERSION_NUM)
#define SG_INFO_CHECK SYMBOLIC(SG_INFO_CHECK)
#define SG_INFO_DIRECT_IO SYMBOLIC(SG_INFO_DIRECT_IO)
#define SG_INFO_DIRECT_IO_MASK SYMBOLIC(SG_INFO_DIRECT_IO_MASK)
#define SG_INFO_INDIRECT_IO SYMBOLIC(SG_INFO_INDIRECT_IO)
#define SG_INFO_MIXED_IO SYMBOLIC(SG_INFO_MIXED_IO)
#define SG_INFO_OK SYMBOLIC(SG_INFO_OK)
#define SG_INFO_OK_MASK SYMBOLIC(SG_INFO_OK_MASK)
#define SG_IO SYMBOLIC(SG_IO)
#define SG_MAX_QUEUE SYMBOLIC(SG_MAX_QUEUE)
#define SG_MAX_SENSE SYMBOLIC(SG_MAX_SENSE)
#define SG_NEXT_CMD_LEN SYMBOLIC(SG_NEXT_CMD_LEN)
#define SG_SCATTER_SZ SYMBOLIC(SG_SCATTER_SZ)
#define SG_SCSI_RESET SYMBOLIC(SG_SCSI_RESET)
#define SG_SCSI_RESET_BUS SYMBOLIC(SG_SCSI_RESET_BUS)
#define SG_SCSI_RESET_DEVICE SYMBOLIC(SG_SCSI_RESET_DEVICE)
#define SG_SCSI_RESET_HOST SYMBOLIC(SG_SCSI_RESET_HOST)
#define SG_SCSI_RESET_NOTHING SYMBOLIC(SG_SCSI_RESET_NOTHING)
#define SG_SET_COMMAND_Q SYMBOLIC(SG_SET_COMMAND_Q)
#define SG_SET_DEBUG SYMBOLIC(SG_SET_DEBUG)
#define SG_SET_FORCE_LOW_DMA SYMBOLIC(SG_SET_FORCE_LOW_DMA)
#define SG_SET_FORCE_PACK_ID SYMBOLIC(SG_SET_FORCE_PACK_ID)
#define SG_SET_KEEP_ORPHAN SYMBOLIC(SG_SET_KEEP_ORPHAN)
#define SG_SET_RESERVED_SIZE SYMBOLIC(SG_SET_RESERVED_SIZE)
#define SG_SET_TIMEOUT SYMBOLIC(SG_SET_TIMEOUT)
#define SG_SET_TRANSFORM SYMBOLIC(SG_SET_TRANSFORM)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SG_BIG_BUFF;
extern const long SG_DEFAULT_RETRIES;
extern const long SG_DEFAULT_TIMEOUT;
extern const long SG_DEF_COMMAND_Q;
extern const long SG_DEF_FORCE_LOW_DMA;
extern const long SG_DEF_FORCE_PACK_ID;
extern const long SG_DEF_KEEP_ORPHAN;
extern const long SG_DEF_RESERVED_SIZE;
extern const long SG_DEF_UNDERRUN_FLAG;
extern const long SG_DXFER_FROM_DEV;
extern const long SG_DXFER_NONE;
extern const long SG_DXFER_TO_DEV;
extern const long SG_DXFER_TO_FROM_DEV;
extern const long SG_EMULATED_HOST;
extern const long SG_FLAG_DIRECT_IO;
extern const long SG_FLAG_LUN_INHIBIT;
extern const long SG_FLAG_NO_DXFER;
extern const long SG_GET_COMMAND_Q;
extern const long SG_GET_KEEP_ORPHAN;
extern const long SG_GET_LOW_DMA;
extern const long SG_GET_NUM_WAITING;
extern const long SG_GET_PACK_ID;
extern const long SG_GET_REQUEST_TABLE;
extern const long SG_GET_RESERVED_SIZE;
extern const long SG_GET_SCSI_ID;
extern const long SG_GET_SG_TABLESIZE;
extern const long SG_GET_TIMEOUT;
extern const long SG_GET_TRANSFORM;
extern const long SG_GET_VERSION_NUM;
extern const long SG_INFO_CHECK;
extern const long SG_INFO_DIRECT_IO;
extern const long SG_INFO_DIRECT_IO_MASK;
extern const long SG_INFO_INDIRECT_IO;
extern const long SG_INFO_MIXED_IO;
extern const long SG_INFO_OK;
extern const long SG_INFO_OK_MASK;
extern const long SG_IO;
extern const long SG_MAX_QUEUE;
extern const long SG_MAX_SENSE;
extern const long SG_NEXT_CMD_LEN;
extern const long SG_SCATTER_SZ;
extern const long SG_SCSI_RESET;
extern const long SG_SCSI_RESET_BUS;
extern const long SG_SCSI_RESET_DEVICE;
extern const long SG_SCSI_RESET_HOST;
extern const long SG_SCSI_RESET_NOTHING;
extern const long SG_SET_COMMAND_Q;
extern const long SG_SET_DEBUG;
extern const long SG_SET_FORCE_LOW_DMA;
extern const long SG_SET_FORCE_PACK_ID;
extern const long SG_SET_KEEP_ORPHAN;
extern const long SG_SET_RESERVED_SIZE;
extern const long SG_SET_TIMEOUT;
extern const long SG_SET_TRANSFORM;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/shm.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SHM_H_

#define SHM_DEST SYMBOLIC(SHM_DEST)
#define SHM_EXEC SYMBOLIC(SHM_EXEC)
#define SHM_HUGETLB SYMBOLIC(SHM_HUGETLB)
#define SHM_INFO SYMBOLIC(SHM_INFO)
#define SHM_LOCK SYMBOLIC(SHM_LOCK)
#define SHM_LOCKED SYMBOLIC(SHM_LOCKED)
#define SHM_NORESERVE SYMBOLIC(SHM_NORESERVE)
#define SHM_R SYMBOLIC(SHM_R)
#define SHM_RDONLY SYMBOLIC(SHM_RDONLY)
#define SHM_REMAP SYMBOLIC(SHM_REMAP)
#define SHM_RND SYMBOLIC(SHM_RND)
#define SHM_STAT SYMBOLIC(SHM_STAT)
#define SHM_UNLOCK SYMBOLIC(SHM_UNLOCK)
#define SHM_W SYMBOLIC(SHM_W)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SHM_DEST;
extern const long SHM_EXEC;
extern const long SHM_HUGETLB;
extern const long SHM_INFO;
extern const long SHM_LOCK;
extern const long SHM_LOCKED;
extern const long SHM_NORESERVE;
extern const long SHM_R;
extern const long SHM_RDONLY;
extern const long SHM_REMAP;
extern const long SHM_RND;
extern const long SHM_STAT;
extern const long SHM_UNLOCK;
extern const long SHM_W;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/shut.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SHUT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SHUT_RD;
extern const long SHUT_RDWR;
extern const long SHUT_WR;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SHUT_RD LITERALLY(0)
#define SHUT_RDWR LITERALLY(2)
#define SHUT_WR LITERALLY(1)



/*!BEGIN libc/sysv/consts/sigpoll.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_POLL_H_

#define POLL_ERR SYMBOLIC(POLL_ERR)
#define POLL_HUP SYMBOLIC(POLL_HUP)
#define POLL_IN SYMBOLIC(POLL_IN)
#define POLL_MSG SYMBOLIC(POLL_MSG)
#define POLL_OUT SYMBOLIC(POLL_OUT)
#define POLL_PRI SYMBOLIC(POLL_PRI)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long POLL_ERR;
extern const long POLL_HUP;
extern const long POLL_IN;
extern const long POLL_MSG;
extern const long POLL_OUT;
extern const long POLL_PRI;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/sio.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SIO_H_

#define SIOCADDDLCI SYMBOLIC(SIOCADDDLCI)
#define SIOCADDMULTI SYMBOLIC(SIOCADDMULTI)
#define SIOCADDRT SYMBOLIC(SIOCADDRT)
#define SIOCATMARK SYMBOLIC(SIOCATMARK)
#define SIOCDARP SYMBOLIC(SIOCDARP)
#define SIOCDELDLCI SYMBOLIC(SIOCDELDLCI)
#define SIOCDELMULTI SYMBOLIC(SIOCDELMULTI)
#define SIOCDELRT SYMBOLIC(SIOCDELRT)
#define SIOCDEVPRIVATE SYMBOLIC(SIOCDEVPRIVATE)
#define SIOCDIFADDR SYMBOLIC(SIOCDIFADDR)
#define SIOCDRARP SYMBOLIC(SIOCDRARP)
#define SIOCGARP SYMBOLIC(SIOCGARP)
#define SIOCGIFADDR SYMBOLIC(SIOCGIFADDR)
#define SIOCGIFBR SYMBOLIC(SIOCGIFBR)
#define SIOCGIFBRDADDR SYMBOLIC(SIOCGIFBRDADDR)
#define SIOCGIFCONF SYMBOLIC(SIOCGIFCONF)
#define SIOCGIFCOUNT SYMBOLIC(SIOCGIFCOUNT)
#define SIOCGIFDSTADDR SYMBOLIC(SIOCGIFDSTADDR)
#define SIOCGIFENCAP SYMBOLIC(SIOCGIFENCAP)
#define SIOCGIFFLAGS SYMBOLIC(SIOCGIFFLAGS)
#define SIOCGIFHWADDR SYMBOLIC(SIOCGIFHWADDR)
#define SIOCGIFINDEX SYMBOLIC(SIOCGIFINDEX)
#define SIOCGIFMAP SYMBOLIC(SIOCGIFMAP)
#define SIOCGIFMEM SYMBOLIC(SIOCGIFMEM)
#define SIOCGIFMETRIC SYMBOLIC(SIOCGIFMETRIC)
#define SIOCGIFMTU SYMBOLIC(SIOCGIFMTU)
#define SIOCGIFNAME SYMBOLIC(SIOCGIFNAME)
#define SIOCGIFNETMASK SYMBOLIC(SIOCGIFNETMASK)
#define SIOCGIFPFLAGS SYMBOLIC(SIOCGIFPFLAGS)
#define SIOCGIFSLAVE SYMBOLIC(SIOCGIFSLAVE)
#define SIOCGIFTXQLEN SYMBOLIC(SIOCGIFTXQLEN)
#define SIOCGPGRP SYMBOLIC(SIOCGPGRP)
#define SIOCGRARP SYMBOLIC(SIOCGRARP)
#define SIOCGSTAMP SYMBOLIC(SIOCGSTAMP)
#define SIOCGSTAMPNS SYMBOLIC(SIOCGSTAMPNS)
#define SIOCPROTOPRIVATE SYMBOLIC(SIOCPROTOPRIVATE)
#define SIOCRTMSG SYMBOLIC(SIOCRTMSG)
#define SIOCSARP SYMBOLIC(SIOCSARP)
#define SIOCSIFADDR SYMBOLIC(SIOCSIFADDR)
#define SIOCSIFBR SYMBOLIC(SIOCSIFBR)
#define SIOCSIFBRDADDR SYMBOLIC(SIOCSIFBRDADDR)
#define SIOCSIFDSTADDR SYMBOLIC(SIOCSIFDSTADDR)
#define SIOCSIFENCAP SYMBOLIC(SIOCSIFENCAP)
#define SIOCSIFFLAGS SYMBOLIC(SIOCSIFFLAGS)
#define SIOCSIFHWADDR SYMBOLIC(SIOCSIFHWADDR)
#define SIOCSIFHWBROADCAST SYMBOLIC(SIOCSIFHWBROADCAST)
#define SIOCSIFLINK SYMBOLIC(SIOCSIFLINK)
#define SIOCSIFMAP SYMBOLIC(SIOCSIFMAP)
#define SIOCSIFMEM SYMBOLIC(SIOCSIFMEM)
#define SIOCSIFMETRIC SYMBOLIC(SIOCSIFMETRIC)
#define SIOCSIFMTU SYMBOLIC(SIOCSIFMTU)
#define SIOCSIFNAME SYMBOLIC(SIOCSIFNAME)
#define SIOCSIFNETMASK SYMBOLIC(SIOCSIFNETMASK)
#define SIOCSIFPFLAGS SYMBOLIC(SIOCSIFPFLAGS)
#define SIOCSIFSLAVE SYMBOLIC(SIOCSIFSLAVE)
#define SIOCSIFTXQLEN SYMBOLIC(SIOCSIFTXQLEN)
#define SIOCSPGRP SYMBOLIC(SIOCSPGRP)
#define SIOCSRARP SYMBOLIC(SIOCSRARP)
#define SIOGIFINDEX SYMBOLIC(SIOGIFINDEX)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SIOCADDDLCI;
extern const long SIOCADDMULTI;
extern const long SIOCADDRT;
extern const long SIOCATMARK;
extern const long SIOCDARP;
extern const long SIOCDELDLCI;
extern const long SIOCDELMULTI;
extern const long SIOCDELRT;
extern const long SIOCDEVPRIVATE;
extern const long SIOCDIFADDR;
extern const long SIOCDRARP;
extern const long SIOCGARP;
extern const long SIOCGIFADDR;
extern const long SIOCGIFBR;
extern const long SIOCGIFBRDADDR;
extern const long SIOCGIFCONF;
extern const long SIOCGIFCOUNT;
extern const long SIOCGIFDSTADDR;
extern const long SIOCGIFENCAP;
extern const long SIOCGIFFLAGS;
extern const long SIOCGIFHWADDR;
extern const long SIOCGIFINDEX;
extern const long SIOCGIFMAP;
extern const long SIOCGIFMEM;
extern const long SIOCGIFMETRIC;
extern const long SIOCGIFMTU;
extern const long SIOCGIFNAME;
extern const long SIOCGIFNETMASK;
extern const long SIOCGIFPFLAGS;
extern const long SIOCGIFSLAVE;
extern const long SIOCGIFTXQLEN;
extern const long SIOCGPGRP;
extern const long SIOCGRARP;
extern const long SIOCGSTAMP;
extern const long SIOCGSTAMPNS;
extern const long SIOCPROTOPRIVATE;
extern const long SIOCRTMSG;
extern const long SIOCSARP;
extern const long SIOCSIFADDR;
extern const long SIOCSIFBR;
extern const long SIOCSIFBRDADDR;
extern const long SIOCSIFDSTADDR;
extern const long SIOCSIFENCAP;
extern const long SIOCSIFFLAGS;
extern const long SIOCSIFHWADDR;
extern const long SIOCSIFHWBROADCAST;
extern const long SIOCSIFLINK;
extern const long SIOCSIFMAP;
extern const long SIOCSIFMEM;
extern const long SIOCSIFMETRIC;
extern const long SIOCSIFMTU;
extern const long SIOCSIFNAME;
extern const long SIOCSIFNETMASK;
extern const long SIOCSIFPFLAGS;
extern const long SIOCSIFSLAVE;
extern const long SIOCSIFTXQLEN;
extern const long SIOCSPGRP;
extern const long SIOCSRARP;
extern const long SIOGIFINDEX;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/sock.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SOCK_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SOCK_CLOEXEC;
extern const long SOCK_DCCP;
extern const long SOCK_DGRAM;
extern const long SOCK_NONBLOCK;
extern const long SOCK_PACKET;
extern const long SOCK_RAW;
extern const long SOCK_RDM;
extern const long SOCK_SEQPACKET;
extern const long SOCK_STREAM;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SOCK_CLOEXEC SYMBOLIC(SOCK_CLOEXEC)
#define SOCK_DCCP SYMBOLIC(SOCK_DCCP)
#define SOCK_DGRAM LITERALLY(2)
#define SOCK_NONBLOCK SYMBOLIC(SOCK_NONBLOCK)
#define SOCK_PACKET SYMBOLIC(SOCK_PACKET)
#define SOCK_RAW LITERALLY(3)
#define SOCK_RDM LITERALLY(4)
#define SOCK_SEQPACKET LITERALLY(5)
#define SOCK_STREAM LITERALLY(1)



/*!BEGIN libc/sysv/consts/so.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SO_H_

#define SO_ACCEPTCONN SYMBOLIC(SO_ACCEPTCONN)
#define SO_ATTACH_BPF SYMBOLIC(SO_ATTACH_BPF)
#define SO_ATTACH_FILTER SYMBOLIC(SO_ATTACH_FILTER)
#define SO_ATTACH_REUSEPORT_CBPF SYMBOLIC(SO_ATTACH_REUSEPORT_CBPF)
#define SO_ATTACH_REUSEPORT_EBPF SYMBOLIC(SO_ATTACH_REUSEPORT_EBPF)
#define SO_BINDTODEVICE SYMBOLIC(SO_BINDTODEVICE)
#define SO_BPF_EXTENSIONS SYMBOLIC(SO_BPF_EXTENSIONS)
#define SO_BROADCAST SYMBOLIC(SO_BROADCAST)
#define SO_BSDCOMPAT SYMBOLIC(SO_BSDCOMPAT)
#define SO_BUSY_POLL SYMBOLIC(SO_BUSY_POLL)
#define SO_CNX_ADVICE SYMBOLIC(SO_CNX_ADVICE)
#define SO_DEBUG SYMBOLIC(SO_DEBUG)
#define SO_DETACH_BPF SYMBOLIC(SO_DETACH_BPF)
#define SO_DETACH_FILTER SYMBOLIC(SO_DETACH_FILTER)
#define SO_DOMAIN SYMBOLIC(SO_DOMAIN)
#define SO_DONTROUTE SYMBOLIC(SO_DONTROUTE)
#define SO_ERROR SYMBOLIC(SO_ERROR)
#define SO_EXCLUSIVEADDRUSE SYMBOLIC(SO_EXCLUSIVEADDRUSE)
#define SO_GET_FILTER SYMBOLIC(SO_GET_FILTER)
#define SO_INCOMING_CPU SYMBOLIC(SO_INCOMING_CPU)
#define SO_KEEPALIVE SYMBOLIC(SO_KEEPALIVE)
#define SO_LINGER SYMBOLIC(SO_LINGER)
#define SO_LOCK_FILTER SYMBOLIC(SO_LOCK_FILTER)
#define SO_MARK SYMBOLIC(SO_MARK)
#define SO_MAX_PACING_RATE SYMBOLIC(SO_MAX_PACING_RATE)
#define SO_NOFCS SYMBOLIC(SO_NOFCS)
#define SO_NO_CHECK SYMBOLIC(SO_NO_CHECK)
#define SO_OOBINLINE SYMBOLIC(SO_OOBINLINE)
#define SO_PASSCRED SYMBOLIC(SO_PASSCRED)
#define SO_PASSSEC SYMBOLIC(SO_PASSSEC)
#define SO_PEEK_OFF SYMBOLIC(SO_PEEK_OFF)
#define SO_PEERCRED SYMBOLIC(SO_PEERCRED)
#define SO_PEERNAME SYMBOLIC(SO_PEERNAME)
#define SO_PEERSEC SYMBOLIC(SO_PEERSEC)
#define SO_PRIORITY SYMBOLIC(SO_PRIORITY)
#define SO_PROTOCOL SYMBOLIC(SO_PROTOCOL)
#define SO_RCVBUF SYMBOLIC(SO_RCVBUF)
#define SO_RCVBUFFORCE SYMBOLIC(SO_RCVBUFFORCE)
#define SO_RCVLOWAT SYMBOLIC(SO_RCVLOWAT)
#define SO_RCVTIMEO SYMBOLIC(SO_RCVTIMEO)
#define SO_REUSEADDR SYMBOLIC(SO_REUSEADDR)
#define SO_REUSEPORT SYMBOLIC(SO_REUSEPORT)
#define SO_RXQ_OVFL SYMBOLIC(SO_RXQ_OVFL)
#define SO_SECURITY_AUTHENTICATION SYMBOLIC(SO_SECURITY_AUTHENTICATION)
#define SO_SECURITY_ENCRYPTION_NETWORK SYMBOLIC(SO_SECURITY_ENCRYPTION_NETWORK)
#define SO_SECURITY_ENCRYPTION_TRANSPORT SYMBOLIC(SO_SECURITY_ENCRYPTION_TRANSPORT)
#define SO_SELECT_ERR_QUEUE SYMBOLIC(SO_SELECT_ERR_QUEUE)
#define SO_SNDBUF SYMBOLIC(SO_SNDBUF)
#define SO_SNDBUFFORCE SYMBOLIC(SO_SNDBUFFORCE)
#define SO_SNDLOWAT SYMBOLIC(SO_SNDLOWAT)
#define SO_SNDTIMEO SYMBOLIC(SO_SNDTIMEO)
#define SO_TIMESTAMP SYMBOLIC(SO_TIMESTAMP)
#define SO_TIMESTAMPING SYMBOLIC(SO_TIMESTAMPING)
#define SO_TIMESTAMPNS SYMBOLIC(SO_TIMESTAMPNS)
#define SO_TYPE SYMBOLIC(SO_TYPE)
#define SO_WIFI_STATUS SYMBOLIC(SO_WIFI_STATUS)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SO_ACCEPTCONN;
extern const long SO_ATTACH_BPF;
extern const long SO_ATTACH_FILTER;
extern const long SO_ATTACH_REUSEPORT_CBPF;
extern const long SO_ATTACH_REUSEPORT_EBPF;
extern const long SO_BINDTODEVICE;
extern const long SO_BPF_EXTENSIONS;
extern const long SO_BROADCAST;
extern const long SO_BSDCOMPAT;
extern const long SO_BUSY_POLL;
extern const long SO_CNX_ADVICE;
extern const long SO_DEBUG;
extern const long SO_DETACH_BPF;
extern const long SO_DETACH_FILTER;
extern const long SO_DOMAIN;
extern const long SO_DONTROUTE;
extern const long SO_ERROR;
extern const long SO_EXCLUSIVEADDRUSE;
extern const long SO_GET_FILTER;
extern const long SO_INCOMING_CPU;
extern const long SO_KEEPALIVE;
extern const long SO_LINGER;
extern const long SO_LOCK_FILTER;
extern const long SO_MARK;
extern const long SO_MAX_PACING_RATE;
extern const long SO_NOFCS;
extern const long SO_NO_CHECK;
extern const long SO_OOBINLINE;
extern const long SO_PASSCRED;
extern const long SO_PASSSEC;
extern const long SO_PEEK_OFF;
extern const long SO_PEERCRED;
extern const long SO_PEERNAME;
extern const long SO_PEERSEC;
extern const long SO_PRIORITY;
extern const long SO_PROTOCOL;
extern const long SO_RCVBUF;
extern const long SO_RCVBUFFORCE;
extern const long SO_RCVLOWAT;
extern const long SO_RCVTIMEO;
extern const long SO_REUSEADDR;
extern const long SO_REUSEPORT;
extern const long SO_RXQ_OVFL;
extern const long SO_SECURITY_AUTHENTICATION;
extern const long SO_SECURITY_ENCRYPTION_NETWORK;
extern const long SO_SECURITY_ENCRYPTION_TRANSPORT;
extern const long SO_SELECT_ERR_QUEUE;
extern const long SO_SNDBUF;
extern const long SO_SNDBUFFORCE;
extern const long SO_SNDLOWAT;
extern const long SO_SNDTIMEO;
extern const long SO_TIMESTAMP;
extern const long SO_TIMESTAMPING;
extern const long SO_TIMESTAMPNS;
extern const long SO_TYPE;
extern const long SO_WIFI_STATUS;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/sol.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SOL_H_

#define SOL_AAL SYMBOLIC(SOL_AAL)
#define SOL_ALG SYMBOLIC(SOL_ALG)
#define SOL_ATM SYMBOLIC(SOL_ATM)
#define SOL_BLUETOOTH SYMBOLIC(SOL_BLUETOOTH)
#define SOL_CAIF SYMBOLIC(SOL_CAIF)
#define SOL_DCCP SYMBOLIC(SOL_DCCP)
#define SOL_DECNET SYMBOLIC(SOL_DECNET)
#define SOL_ICMPV6 SYMBOLIC(SOL_ICMPV6)
#define SOL_IP SYMBOLIC(SOL_IP)
#define SOL_IPV6 SYMBOLIC(SOL_IPV6)
#define SOL_IRDA SYMBOLIC(SOL_IRDA)
#define SOL_IUCV SYMBOLIC(SOL_IUCV)
#define SOL_KCM SYMBOLIC(SOL_KCM)
#define SOL_LLC SYMBOLIC(SOL_LLC)
#define SOL_NETBEUI SYMBOLIC(SOL_NETBEUI)
#define SOL_NETLINK SYMBOLIC(SOL_NETLINK)
#define SOL_NFC SYMBOLIC(SOL_NFC)
#define SOL_PACKET SYMBOLIC(SOL_PACKET)
#define SOL_PNPIPE SYMBOLIC(SOL_PNPIPE)
#define SOL_PPPOL2TP SYMBOLIC(SOL_PPPOL2TP)
#define SOL_RAW SYMBOLIC(SOL_RAW)
#define SOL_RDS SYMBOLIC(SOL_RDS)
#define SOL_RXRPC SYMBOLIC(SOL_RXRPC)
#define SOL_SOCKET SYMBOLIC(SOL_SOCKET)
#define SOL_TCP SYMBOLIC(SOL_TCP)
#define SOL_TIPC SYMBOLIC(SOL_TIPC)
#define SOL_UDP SYMBOLIC(SOL_UDP)
#define SOL_X25 SYMBOLIC(SOL_X25)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SOL_AAL;
extern const long SOL_ALG;
extern const long SOL_ATM;
extern const long SOL_BLUETOOTH;
extern const long SOL_CAIF;
extern const long SOL_DCCP;
extern const long SOL_DECNET;
extern const long SOL_ICMPV6;
extern const long SOL_IP;
extern const long SOL_IPV6;
extern const long SOL_IRDA;
extern const long SOL_IUCV;
extern const long SOL_KCM;
extern const long SOL_LLC;
extern const long SOL_NETBEUI;
extern const long SOL_NETLINK;
extern const long SOL_NFC;
extern const long SOL_PACKET;
extern const long SOL_PNPIPE;
extern const long SOL_PPPOL2TP;
extern const long SOL_RAW;
extern const long SOL_RDS;
extern const long SOL_RXRPC;
extern const long SOL_SOCKET;
extern const long SOL_TCP;
extern const long SOL_TIPC;
extern const long SOL_UDP;
extern const long SOL_X25;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/splice.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_SPLICE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long SPLICE_F_GIFT;
extern const long SPLICE_F_MORE;
extern const long SPLICE_F_MOVE;
extern const long SPLICE_F_NONBLOCK;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define SPLICE_F_GIFT SYMBOLIC(SPLICE_F_GIFT)
#define SPLICE_F_MORE SYMBOLIC(SPLICE_F_MORE)
#define SPLICE_F_MOVE SYMBOLIC(SPLICE_F_MOVE)
#define SPLICE_F_NONBLOCK SYMBOLIC(SPLICE_F_NONBLOCK)



/*!BEGIN libc/sysv/consts/st.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_ST_H_

#define ST_APPEND SYMBOLIC(ST_APPEND)
#define ST_IMMUTABLE SYMBOLIC(ST_IMMUTABLE)
#define ST_MANDLOCK SYMBOLIC(ST_MANDLOCK)
#define ST_NOATIME SYMBOLIC(ST_NOATIME)
#define ST_NODEV SYMBOLIC(ST_NODEV)
#define ST_NODIRATIME SYMBOLIC(ST_NODIRATIME)
#define ST_NOEXEC SYMBOLIC(ST_NOEXEC)
#define ST_NOSUID SYMBOLIC(ST_NOSUID)
#define ST_RDONLY SYMBOLIC(ST_RDONLY)
#define ST_RELATIME SYMBOLIC(ST_RELATIME)
#define ST_SYNCHRONOUS SYMBOLIC(ST_SYNCHRONOUS)
#define ST_WRITE SYMBOLIC(ST_WRITE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long ST_APPEND;
extern const long ST_IMMUTABLE;
extern const long ST_MANDLOCK;
extern const long ST_NOATIME;
extern const long ST_NODEV;
extern const long ST_NODIRATIME;
extern const long ST_NOEXEC;
extern const long ST_NOSUID;
extern const long ST_RDONLY;
extern const long ST_RELATIME;
extern const long ST_SYNCHRONOUS;
extern const long ST_WRITE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/tcp.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TCP_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long TCP_CC_INFO;
extern const long TCP_CONGESTION;
extern const long TCP_COOKIE_TRANSACTIONS;
extern const long TCP_CORK;
extern const long TCP_DEFER_ACCEPT;
extern const long TCP_FASTOPEN;
extern const long TCP_INFO;
extern const long TCP_KEEPCNT;
extern const long TCP_KEEPIDLE;
extern const long TCP_KEEPINTVL;
extern const long TCP_LINGER2;
extern const long TCP_MAXSEG;
extern const long TCP_MD5SIG;
extern const long TCP_MD5SIG_MAXKEYLEN;
extern const long TCP_NODELAY;
extern const long TCP_NOTSENT_LOWAT;
extern const long TCP_QUEUE_SEQ;
extern const long TCP_QUICKACK;
extern const long TCP_REPAIR;
extern const long TCP_REPAIR_OPTIONS;
extern const long TCP_REPAIR_QUEUE;
extern const long TCP_SAVED_SYN;
extern const long TCP_SAVE_SYN;
extern const long TCP_SYNCNT;
extern const long TCP_THIN_DUPACK;
extern const long TCP_THIN_LINEAR_TIMEOUTS;
extern const long TCP_TIMESTAMP;
extern const long TCP_USER_TIMEOUT;
extern const long TCP_WINDOW_CLAMP;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define TCP_CC_INFO SYMBOLIC(TCP_CC_INFO)
#define TCP_CONGESTION SYMBOLIC(TCP_CONGESTION)
#define TCP_COOKIE_TRANSACTIONS SYMBOLIC(TCP_COOKIE_TRANSACTIONS)
#define TCP_CORK SYMBOLIC(TCP_CORK)
#define TCP_DEFER_ACCEPT SYMBOLIC(TCP_DEFER_ACCEPT)
#define TCP_FASTOPEN SYMBOLIC(TCP_FASTOPEN)
#define TCP_INFO SYMBOLIC(TCP_INFO)
#define TCP_KEEPCNT SYMBOLIC(TCP_KEEPCNT)
#define TCP_KEEPIDLE SYMBOLIC(TCP_KEEPIDLE)
#define TCP_KEEPINTVL SYMBOLIC(TCP_KEEPINTVL)
#define TCP_LINGER2 SYMBOLIC(TCP_LINGER2)
#define TCP_MAXSEG SYMBOLIC(TCP_MAXSEG)
#define TCP_MD5SIG SYMBOLIC(TCP_MD5SIG)
#define TCP_MD5SIG_MAXKEYLEN SYMBOLIC(TCP_MD5SIG_MAXKEYLEN)
#define TCP_NODELAY LITERALLY(1)
#define TCP_NOTSENT_LOWAT SYMBOLIC(TCP_NOTSENT_LOWAT)
#define TCP_QUEUE_SEQ SYMBOLIC(TCP_QUEUE_SEQ)
#define TCP_QUICKACK SYMBOLIC(TCP_QUICKACK)
#define TCP_REPAIR SYMBOLIC(TCP_REPAIR)
#define TCP_REPAIR_OPTIONS SYMBOLIC(TCP_REPAIR_OPTIONS)
#define TCP_REPAIR_QUEUE SYMBOLIC(TCP_REPAIR_QUEUE)
#define TCP_SAVED_SYN SYMBOLIC(TCP_SAVED_SYN)
#define TCP_SAVE_SYN SYMBOLIC(TCP_SAVE_SYN)
#define TCP_SYNCNT SYMBOLIC(TCP_SYNCNT)
#define TCP_THIN_DUPACK SYMBOLIC(TCP_THIN_DUPACK)
#define TCP_THIN_LINEAR_TIMEOUTS SYMBOLIC(TCP_THIN_LINEAR_TIMEOUTS)
#define TCP_TIMESTAMP SYMBOLIC(TCP_TIMESTAMP)
#define TCP_USER_TIMEOUT SYMBOLIC(TCP_USER_TIMEOUT)
#define TCP_WINDOW_CLAMP SYMBOLIC(TCP_WINDOW_CLAMP)



/*!BEGIN libc/sysv/consts/tcpopt.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TCPOPT_H_

#define TCPOPT_EOL SYMBOLIC(TCPOPT_EOL)
#define TCPOPT_MAXSEG SYMBOLIC(TCPOPT_MAXSEG)
#define TCPOPT_NOP SYMBOLIC(TCPOPT_NOP)
#define TCPOPT_SACK SYMBOLIC(TCPOPT_SACK)
#define TCPOPT_SACK_PERMITTED SYMBOLIC(TCPOPT_SACK_PERMITTED)
#define TCPOPT_TIMESTAMP SYMBOLIC(TCPOPT_TIMESTAMP)
#define TCPOPT_WINDOW SYMBOLIC(TCPOPT_WINDOW)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long TCPOPT_EOL;
extern const long TCPOPT_MAXSEG;
extern const long TCPOPT_NOP;
extern const long TCPOPT_SACK;
extern const long TCPOPT_SACK_PERMITTED;
extern const long TCPOPT_TIMESTAMP;
extern const long TCPOPT_WINDOW;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/th.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TH_H_

#define TH_ACK SYMBOLIC(TH_ACK)
#define TH_FIN SYMBOLIC(TH_FIN)
#define TH_PUSH SYMBOLIC(TH_PUSH)
#define TH_RST SYMBOLIC(TH_RST)
#define TH_SYN SYMBOLIC(TH_SYN)
#define TH_URG SYMBOLIC(TH_URG)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long TH_ACK;
extern const long TH_FIN;
extern const long TH_PUSH;
extern const long TH_RST;
extern const long TH_SYN;
extern const long TH_URG;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/trap.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TRAP_H_

#define TRAP_BRKPT SYMBOLIC(TRAP_BRKPT)
#define TRAP_TRACE SYMBOLIC(TRAP_TRACE)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long TRAP_BRKPT;
extern const long TRAP_TRACE;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/type.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_TYPE_H_

#define TYPE_A SYMBOLIC(TYPE_A)
#define TYPE_DISK SYMBOLIC(TYPE_DISK)
#define TYPE_E SYMBOLIC(TYPE_E)
#define TYPE_ENCLOSURE SYMBOLIC(TYPE_ENCLOSURE)
#define TYPE_I SYMBOLIC(TYPE_I)
#define TYPE_L SYMBOLIC(TYPE_L)
#define TYPE_MEDIUM_CHANGER SYMBOLIC(TYPE_MEDIUM_CHANGER)
#define TYPE_MOD SYMBOLIC(TYPE_MOD)
#define TYPE_NO_LUN SYMBOLIC(TYPE_NO_LUN)
#define TYPE_PROCESSOR SYMBOLIC(TYPE_PROCESSOR)
#define TYPE_ROM SYMBOLIC(TYPE_ROM)
#define TYPE_SCANNER SYMBOLIC(TYPE_SCANNER)
#define TYPE_TAPE SYMBOLIC(TYPE_TAPE)
#define TYPE_WORM SYMBOLIC(TYPE_WORM)

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const long TYPE_A;
extern const long TYPE_DISK;
extern const long TYPE_E;
extern const long TYPE_ENCLOSURE;
extern const long TYPE_I;
extern const long TYPE_L;
extern const long TYPE_MEDIUM_CHANGER;
extern const long TYPE_MOD;
extern const long TYPE_NO_LUN;
extern const long TYPE_PROCESSOR;
extern const long TYPE_ROM;
extern const long TYPE_SCANNER;
extern const long TYPE_TAPE;
extern const long TYPE_WORM;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/sysv/consts/utime.h */

#define COSMOPOLITAN_LIBC_SYSV_CONSTS_UTIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern const int UTIME_NOW;
extern const int UTIME_OMIT;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#define UTIME_NOW  SYMBOLIC(UTIME_NOW)
#define UTIME_OMIT SYMBOLIC(UTIME_OMIT)



/*!BEGIN libc/time/struct/timezone.h */

#define COSMOPOLITAN_LIBC_TIME_STRUCT_TIMEZONE_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct timezone {
  int32_t tz_minuteswest;
  int32_t tz_dsttime;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/time/struct/tm.h */

#define COSMOPOLITAN_LIBC_TIME_STRUCT_TM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct tm {
  int32_t tm_sec;
  int32_t tm_min;
  int32_t tm_hour;
  int32_t tm_mday; /* 1-indexed */
  int32_t tm_mon;  /* 0-indexed */
  int32_t tm_year; /* minus 1900 */
  int32_t tm_wday;
  int32_t tm_yday;
  int32_t tm_isdst;
  int64_t tm_gmtoff;
  const char *tm_zone;
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/time/struct/utimbuf.h */

#define COSMOPOLITAN_LIBC_TIME_STRUCT_UTIMBUF_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

struct utimbuf {
  int64_t actime;  /* access time */
  int64_t modtime; /* modified time */
};

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/time/time.h */

#define COSMOPOLITAN_LIBC_TIME_TIME_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

hidden extern const char kWeekdayNameShort[7][4];
hidden extern const char kWeekdayName[7][10];
hidden extern const char kMonthNameShort[12][4];
hidden extern const char kMonthName[12][10];
hidden extern const unsigned short kMonthYearDay[2][12];

extern char *tzname[2];
extern long CLOCKS_PER_SEC;

int64_t clock(void);
int64_t time(int64_t *);
int gettimeofday(struct timeval *, struct timezone *);
int clock_gettime(int, struct timespec *);
int clock_getres(int, struct timespec *);

int sleep(uint32_t);
int usleep(uint32_t);
int nanosleep(const struct timespec *, struct timespec *);
unsigned alarm(unsigned);
int getitimer(int, struct itimerval *);
int setitimer(int, const struct itimerval *, struct itimerval *);

void tzset(void);
struct tm *gmtime(const int64_t *);
struct tm *gmtime_r(const int64_t *, struct tm *);
struct tm *localtime(const int64_t *);
struct tm *localtime_r(const int64_t *, struct tm *);
int64_t timegm(struct tm *);
int64_t mktime(struct tm *);
int64_t timelocal(struct tm *);
int64_t timeoff(struct tm *, long);
int64_t time2posix(int64_t) pureconst;
int64_t posix2time(int64_t) pureconst;

char *strptime(const char *, const char *, struct tm *);
size_t strftime(char *, size_t, const char *, const struct tm *)
    strftimeesque(3);
char *asctime(const struct tm *);
char *ctime(const int64_t *);
char *ctime_r(const int64_t *, char[hasatleast 64]);
char *asctime_r(const struct tm *, char[hasatleast 64]);

int futimens(int, const struct timespec[2]);
int utimensat(int, const char *, const struct timespec[2], int);
int utimes(const char *, const struct timeval[2]);
int utime(const char *, const struct utimbuf *);
int futimes(int, const struct timeval[2]);
int futimesat(int, const char *, const struct timeval[2]);

long double dtime(int);
long double dsleep(long double);
extern long double (*nowl)(void);
long double ConvertTicksToNanos(uint64_t);

double difftime(int64_t, int64_t) nothrow pureconst;

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/tinymath/emod.h */

#define COSMOPOLITAN_LIBC_TINYMATH_EMOD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Returns Euclidean floating-point division remainder.
 *
 * @return (𝑥 mod 𝑦) ∈ [0.,𝑦)
 * @see fmod()
 */
static inline double emod(double x, double y) {
  return x - fabs(y) * floor(x / fabs(y));
}

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/tinymath/emodl.h */

#define COSMOPOLITAN_LIBC_TINYMATH_EMODL_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)

/**
 * Returns Euclidean floating-point division remainder.
 *
 * @return (𝑥 mod 𝑦) ∈ [0.,𝑦)
 * @see fmodl()
 */
static inline long double emodl(long double x, long double y) {
  return x - fabsl(y) * floorl(x / fabsl(y));
}

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN libc/x/x.h */

#define COSMOPOLITAN_LIBC_X_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis                                             ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  Standard Library veneers for folks not building embedded RTOS */

#define _XPNN   paramsnonnull()
#define _XRET   nothrow nocallback nodiscard returnsnonnull
#define _XMAL   returnspointerwithnoaliases _XRET
#define _XMALPG returnsaligned((PAGESIZE)) _XMAL

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » system calls                              ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int xsigaction(int, void *, uint64_t, uint64_t, struct sigaction *);
int xwrite(int, const void *, uint64_t);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » memory                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

void xdie(void) wontreturn;
char *xdtoa(long double) _XMAL;
char *xasprintf(const char *, ...) printfesque(1) paramsnonnull((1)) _XMAL;
char *xvasprintf(const char *, va_list) _XPNN _XMAL;
char *xgetline(struct FILE *) _XPNN mallocesque;
void *xmalloc(size_t) attributeallocsize((1)) _XMAL;
void *xrealloc(void *, size_t) attributeallocsize((2)) _XRET;
void *xcalloc(size_t, size_t) attributeallocsize((1, 2)) _XMAL;
void *xvalloc(size_t) attributeallocsize((1)) _XMALPG;
void *xmemalign(size_t, size_t) attributeallocalign((1))
    attributeallocsize((2)) _XMAL;
void *xmemalignzero(size_t, size_t) attributeallocalign((1))
    attributeallocsize((2)) _XMAL;
char *xstrdup(const char *) _XPNN _XMAL;
char *xstrndup(const char *, size_t) _XPNN _XMAL;
char *xstrcat(const char *, ...) paramsnonnull((1)) nullterminated() _XMAL;
char *xstrmul(const char *, size_t) paramsnonnull((1)) _XMAL;
char *xinet_ntop(int, const void *) _XPNN _XMAL;
void *xunbinga(size_t, const char16_t *) attributeallocalign((1)) _XMAL _XRET;
void *xunbing(const char16_t *) _XMAL _XRET;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » files                                     ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

int rmrf(const char *);
int makedirs(const char *, unsigned);
char *xdirname(const char *) paramsnonnull() _XMAL;
char *xjoinpaths(const char *, const char *) paramsnonnull() _XMAL;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » time                                      ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

char *xiso8601i(int) mallocesque;
char *xiso8601tv(struct timeval *) mallocesque;
char *xiso8601ts(struct timespec *) mallocesque;

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » input / output                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

char *xslurp(const char *, size_t *) paramsnonnull((1)) _XMALPG nodiscard;
int xbarf(const char *, const void *, size_t);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » safety                                    ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#define xstrcat(...) (xstrcat)(__VA_ARGS__, NULL)

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » generic typing                            ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if __STDC_VERSION__ + 0 >= 201112

#define xiso8601(TS) \
  _Generic(*(TS), struct timeval : xiso8601tv, default : xiso8601ts)(TS)

#endif /* C11 */

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § eXtended apis » link-time optimizations                   ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
#define xasprintf(FMT, ...) (xasprintf)(PFLINK(FMT), ##__VA_ARGS__)
#define xvasprintf(FMT, VA) (xvasprintf)(PFLINK(FMT), VA)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/gdtoa/gdtoa.h */

#define COSMOPOLITAN_THIRD_PARTY_GDTOA_GDTOA_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

enum {
  /* return values from strtodg */
  STRTOG_Zero = 0,
  STRTOG_Normal = 1,
  STRTOG_Denormal = 2,
  STRTOG_Infinite = 3,
  STRTOG_NaN = 4,
  STRTOG_NaNbits = 5,
  STRTOG_NoNumber = 6,
  STRTOG_Retmask = 7,

  /* The following may be or-ed into one of the above values. */
  STRTOG_Neg = 0x08,    /* does not affect STRTOG_Inexlo or STRTOG_Inexhi */
  STRTOG_Inexlo = 0x10, /* returned result rounded toward zero */
  STRTOG_Inexhi = 0x20, /* returned result rounded away from zero */
  STRTOG_Inexact = 0x30,
  STRTOG_Underflow = 0x40,
  STRTOG_Overflow = 0x80
};

typedef struct FPI {
  int nbits;
  int emin;
  int emax;
  int rounding;
  int sudden_underflow;
  int int_max;
} FPI;

enum {
  /* FPI.rounding values: same as FLT_ROUNDS */
  FPI_Round_zero = 0,
  FPI_Round_near = 1,
  FPI_Round_up = 2,
  FPI_Round_down = 3
};

char *dtoa(double d, int mode, int ndigits, int *decpt, int *sign, char **rve);
char *gdtoa(const FPI *fpi, int be, unsigned *bits, int *kindp, int mode,
            int ndigits, int *decpt, char **rve);
void freedtoa(char *);

float strtof(const char *, char **);
double strtod(const char *, char **);
int strtodg(const char *, char **, const FPI *, int *, unsigned *);
long double strtold(const char *, char **);

char *g_ddfmt(char *, double *, int, size_t);
char *g_ddfmt_p(char *, double *, int, size_t, int);
char *g_dfmt(char *, double *, int, size_t);
char *g_dfmt_p(char *, double *, int, size_t, int);
char *g_ffmt(char *, float *, int, size_t);
char *g_ffmt_p(char *, float *, int, size_t, int);
char *g_Qfmt(char *, void *, int, size_t);
char *g_Qfmt_p(char *, void *, int, size_t, int);
char *g_xfmt(char *, void *, int, size_t);
char *g_xfmt_p(char *, void *, int, size_t, int);
char *g_xLfmt(char *, void *, int, size_t);
char *g_xLfmt_p(char *, void *, int, size_t, int);

int strtoId(const char *, char **, double *, double *);
int strtoIdd(const char *, char **, double *, double *);
int strtoIf(const char *, char **, float *, float *);
int strtoIQ(const char *, char **, void *, void *);
int strtoIx(const char *, char **, void *, void *);
int strtoIxL(const char *, char **, void *, void *);
int strtord(const char *, char **, int, double *);
int strtordd(const char *, char **, int, double *);
int strtorf(const char *, char **, int, float *);
int strtorQ(const char *, char **, int, void *);
int strtorx(const char *, char **, int, void *);
int strtorxL(const char *, char **, int, void *);

#if 1
int strtodI(const char *, char **, double *);
int strtopd(const char *, char **, double *);
int strtopdd(const char *, char **, double *);
int strtopf(const char *, char **, float *);
int strtopQ(const char *, char **, void *);
int strtopx(const char *, char **, void *);
int strtopxL(const char *, char **, void *);
#else
#define strtopd(s, se, x)  strtord(s, se, 1, x)
#define strtopdd(s, se, x) strtordd(s, se, 1, x)
#define strtopf(s, se, x)  strtorf(s, se, 1, x)
#define strtopQ(s, se, x)  strtorQ(s, se, 1, x)
#define strtopx(s, se, x)  strtorx(s, se, 1, x)
#define strtopxL(s, se, x) strtorxL(s, se, 1, x)
#endif

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/getopt/getopt.h */

#define COSMOPOLITAN_THIRD_PARTY_GETOPT_GETOPT_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

extern char *optarg;
extern int optind, opterr, optopt, optreset;
int getopt(int nargc, char *const nargv[], const char *ostr);

#define no_argument 0
#define required_argument 1
#define optional_argument 2
struct option {
  const char *name;
  int has_arg;
  int *flag;
  int val;
};
int getopt_long(int nargc, char *const *nargv, const char *options,
                const struct option *long_options, int *idx);
int getopt_long_only(int nargc, char *const *nargv, const char *options,
                     const struct option *long_options, int *idx);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/fnmatch.h */

#define COSMOPOLITAN_THIRD_PARTY_REGEX_FNMATCH_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define FNM_PATHNAME    0x1
#define FNM_NOESCAPE    0x2
#define FNM_PERIOD      0x4
#define FNM_LEADING_DIR 0x8
#define FNM_CASEFOLD    0x10
#define FNM_FILE_NAME   FNM_PATHNAME

#define FNM_NOMATCH 1
#define FNM_NOSYS   (-1)

int fnmatch(const char *, const char *, int);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/glob.h */

#define COSMOPOLITAN_THIRD_PARTY_MUSL_GLOB_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#define GLOB_ERR      0x01
#define GLOB_MARK     0x02
#define GLOB_NOSORT   0x04
#define GLOB_DOOFFS   0x08 /* reserves null slots at start of gl_pathv */
#define GLOB_NOCHECK  0x10 /* just yield pattern if GLOB_NOMATCH happens */
#define GLOB_APPEND   0x20 /* enables us to call glob() multiple times */
#define GLOB_NOESCAPE 0x40 /* don't allow things like \*\?\[\] escaping */
#define GLOB_PERIOD   0x80

#define GLOB_TILDE       0x1000
#define GLOB_TILDE_CHECK 0x4000

#define GLOB_NOSPACE 1
#define GLOB_ABORTED 2
#define GLOB_NOMATCH 3
#define GLOB_NOSYS   4

typedef struct {
  size_t gl_pathc;
  char **gl_pathv;
  size_t gl_offs;
  int __dummy1;
  void *__dummy2[5];
} glob_t;

int glob(const char *, int, int (*)(const char *, int), glob_t *);
void globfree(glob_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/passwd.h */

#define COSMOPOLITAN_LIBC_PASSWD_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

struct FILE;

struct passwd {
  char *pw_name;
  char *pw_passwd;
  uint32_t pw_uid;
  uint32_t pw_gid;
  char *pw_gecos;
  char *pw_dir;
  char *pw_shell;
};

void setpwent(void);
void endpwent(void);
struct passwd *getpwent(void);
struct passwd *getpwuid(uint32_t);
struct passwd *getpwnam(const char *);
int getpwuid_r(uint32_t, struct passwd *, char *, size_t, struct passwd **);
int getpwnam_r(const char *, struct passwd *, char *, size_t, struct passwd **);
struct passwd *fgetpwent(struct FILE *);
int putpwent(const struct passwd *, struct FILE *);

struct group {
  char *gr_name;
  char *gr_passwd;
  int32_t gr_gid;
  char **gr_mem;
};

struct group *getgrgid(gid_t);
struct group *getgrnam(const char *);
int getgrgid_r(gid_t, struct group *, char *, size_t, struct group **);
int getgrnam_r(const char *, struct group *, char *, size_t, struct group **);
struct group *getgrent(void);
void endgrent(void);
void setgrent(void);
struct group *fgetgrent(struct FILE *);
int putgrent(const struct group *, struct FILE *);
int getgrouplist(const char *, gid_t, gid_t *, int *);
int setgroups(size_t, const int32_t *);
int initgroups(const char *, int32_t);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/musl/tempnam.h */

#define COSMOPOLITAN_THIRD_PARTY_MUSL_TEMPNAM_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

char *tempnam(const char *, const char *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/zlib/zlib.h */

#define COSMOPOLITAN_THIRD_PARTY_ZLIB_ZLIB_H_


/*!BEGIN third_party/zlib/zconf.h */

#define COSMOPOLITAN_THIRD_PARTY_ZLIB_ZCONF_H_

#define STDC
#define STDC99
#define MAX_MEM_LEVEL 9
#define DEF_MEM_LEVEL 8
#define MAX_WBITS 15 /* 32K LZ77 window */

#if !(__ASSEMBLER__ + __LINKER__ + 0)

typedef unsigned char Byte;
typedef unsigned int uInt;   /* 16 bits or more */
typedef unsigned long uLong; /* 32 bits or more */
typedef Byte Bytef;
typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;
typedef void const *voidpc;
typedef void *voidpf;
typedef void *voidp;

#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

/**
 * @fileoverview zlib
 *
 * The 'zlib' compression library provides in-memory
 * compression and decompression functions, including integrity checks
 * of the uncompressed data. This version of the library supports only
 * one compression method (deflation) but other algorithms will be added
 * later and will have the same stream interface.
 *
 * Compression can be done in a single step if the buffers are large enough,
 * or can be done by repeated calls of the compression function.  In the latter
 * case, the application must provide more input and/or consume the output
 * (providing more output space) before each call.
 *
 * The compressed data format used by default by the in-memory functions is
 * the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
 * around a deflate stream, which is itself documented in RFC 1951.
 *
 * The library also supports reading and writing files in gzip (.gz) format
 * with an interface similar to that of stdio using the functions that start
 * with "gz".  The gzip format is different from the zlib format.  gzip is a
 * gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
 *
 * This library can optionally read and write gzip and raw deflate streams in
 * memory as well.
 *
 * The zlib format was designed to be compact and fast for use in memory
 * and on communications channels.  The gzip format was designed for single-
 * file compression on file systems, has a larger header than zlib to maintain
 * directory information, and uses a different, slower check method than zlib.
 *
 * The library does not install any signal handler.  The decoder checks
 * the consistency of the compressed data, so the library should never crash
 * even in the case of corrupted input.
 */

#define ZLIB_VERSION         "1.2.11"
#define ZLIB_VERNUM          0x12b0
#define ZLIB_VER_MAJOR       1
#define ZLIB_VER_MINOR       2
#define ZLIB_VER_REVISION    11
#define ZLIB_VER_SUBREVISION 0

/**
 * The application must update next_in and avail_in when avail_in has
 * dropped to zero. It must update next_out and avail_out when avail_out
 * has dropped to zero. The application must initialize zalloc, zfree
 * and opaque before calling the init function. All other fields are set
 * by the compression library and must not be updated by the
 * application.
 *
 * The opaque value provided by the application will be passed as the
 * first parameter for calls of zalloc and zfree. This can be useful for
 * custom memory management. The compression library attaches no meaning
 * to the opaque value.
 *
 * zalloc must return Z_NULL if there is not enough memory for the
 * object. If zlib is used in a multi-threaded application, zalloc and
 * zfree must be thread safe. In that case, zlib is thread-safe. When
 * zalloc and zfree are Z_NULL on entry to the initialization function,
 * they are set to internal routines that use the standard library
 * functions malloc() and free().
 *
 * On 16-bit systems, the functions zalloc and zfree must be able to
 * allocate exactly 65536 bytes, but will not be required to allocate
 * more than this if the symbol MAXSEG_64K is defined (see zconf.h).
 * WARNING: On MSDOS, pointers returned by zalloc for objects of exactly
 * 65536 bytes *must* have their offset normalized to zero. The default
 * allocation function provided by this library ensures this (see
 * zutil.c). To reduce memory requirements and avoid any allocation of
 * 64K objects, at the expense of compression ratio, compile the library
 * with -DMAX_WBITS=14 (see zconf.h).
 *
 * The fields total_in and total_out can be used for statistics or
 * progress reports. After compression, total_in holds the total size of
 * the uncompressed data and may be saved for use by the decompressor
 * (particularly if the decompressor wants to decompress everything in a
 * single step).
 */
#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
#define Z_BLOCK         5
#define Z_TREES         6

/**
 * Allowed flush values; see deflate() and inflate() below for details.
 */
#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO         (-1)
#define Z_STREAM_ERROR  (-2)
#define Z_DATA_ERROR    (-3)
#define Z_MEM_ERROR     (-4)
#define Z_BUF_ERROR     (-5)
#define Z_VERSION_ERROR (-6)

/**
 * Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal
 * events.
 */
#define Z_NO_COMPRESSION      0
#define Z_BEST_SPEED          1
#define Z_BEST_COMPRESSION    9
#define Z_DEFAULT_COMPRESSION (-1)

/**
 * Compression levels.
 */
#define Z_FILTERED         1
#define Z_HUFFMAN_ONLY     2
#define Z_RLE              3
#define Z_FIXED            4
#define Z_DEFAULT_STRATEGY 0

/**
 * Compression strategy; see deflateInit2() below for details
 */
#define Z_BINARY  0
#define Z_TEXT    1
#define Z_ASCII   Z_TEXT /* for compatibility with 1.2.2 and earlier */
#define Z_UNKNOWN 2

/**
 * Possible values of the data_type field for deflate()
 */
#define Z_DEFLATED 8

/* The deflate compression method (the only one supported in this version) */
#define Z_NULL 0 /* for initializing zalloc, zfree, opaque */

#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);
typedef void (*free_func)(voidpf opaque, voidpf address);

struct DeflateState;

typedef struct z_stream_s {
  const Bytef *next_in;       /* next input byte */
  uInt avail_in;              /* number of bytes available at next_in */
  uLong total_in;             /* total number of input bytes read so far */
  Bytef *next_out;            /* next output byte will go here */
  uInt avail_out;             /* remaining free space at next_out */
  uLong total_out;            /* total number of bytes output so far */
  const char *msg;            /* last error message, NULL if no error */
  struct DeflateState *state; /* not visible by applications */
  alloc_func zalloc;          /* used to allocate the internal state */
  free_func zfree;            /* used to free the internal state */
  voidpf opaque;  /* private data object passed to zalloc and zfree */
  int data_type;  /* best guess about the data type: binary or text
                     for deflate, or the decoding state for inflate */
  uLong adler;    /* Adler-32 or CRC-32 value of the uncompressed data */
  uLong reserved; /* reserved for future use */
} z_stream;

typedef z_stream *z_streamp;

/**
 * gzip header information passed to and from zlib routines. See RFC
 * 1952 for more details on the meanings of these fields.
 */
typedef struct gz_header_s {
  int text;       /* true if compressed data believed to be text */
  uLong time;     /* modification time */
  int xflags;     /* extra flags (not used when writing a gzip file) */
  int os;         /* operating system */
  Bytef *extra;   /* pointer to extra field or Z_NULL if none */
  uInt extra_len; /* extra field length (valid if extra != Z_NULL) */
  uInt extra_max; /* space at extra (only when reading header) */
  Bytef *name;    /* pointer to zero-terminated file name or Z_NULL */
  uInt name_max;  /* space at name (only when reading header) */
  Bytef *comment; /* pointer to zero-terminated comment or Z_NULL */
  uInt comm_max;  /* space at comment (only when reading header) */
  int hcrc;       /* true if there was or will be a header crc */
  int done;       /* true when done reading gzip header (not used
                     when writing a gzip file) */
} gz_header;

typedef gz_header *gz_headerp;

#define zlib_version zlibVersion()

/**
 * The application can compare zlibVersion and ZLIB_VERSION for consistency.
 * If the first character differs, the library code actually used is not
 * compatible with the zlib.h header file used by the application.  This check
 * is automatically made by deflateInit and inflateInit.
 */
const char *zlibVersion(void);

/**
 * Initializes the internal stream state for compression.  The fields
 * zalloc, zfree and opaque must be initialized before by the caller.  If
 * zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
 * allocation functions.
 *
 * The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
 * 1 gives best speed, 9 gives best compression, 0 gives no compression at all
 * (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
 * requests a default compromise between speed and compression (currently
 * equivalent to level 6).
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     or Z_STREAM_ERROR if level is not a valid compression level. msg
 *     is set to null if there is no error message. deflateInit does not
 *     perform any compression: this will be done by deflate().
 */
int deflateInit(z_streamp strm, int level);

/**
 * deflate compresses as much data as possible, and stops when the input
 * buffer becomes empty or the output buffer becomes full. It may
 * introduce some output latency (reading input without producing any
 * output) except when forced to flush.
 *
 * The detailed semantics are as follows. deflate performs one or both
 * of the following actions:
 *
 * - Compress more input starting at next_in and update next_in and
 *  avail_in accordingly. If not all input can be processed (because
 *  there is not enough room in the output buffer), next_in and avail_in
 *  are updated and processing will resume at this point for the next
 *  call of deflate().
 *
 * - Generate more output starting at next_out and update next_out and
 *  avail_out accordingly. This action is forced if the parameter flush
 *  is non zero. Forcing flush frequently degrades the compression
 *  ratio, so this parameter should be set only when necessary. Some
 *  output may be provided even if flush is zero.
 *
 * Before the call of deflate(), the application should ensure that at
 * least one of the actions is possible, by providing more input and/or
 * consuming more output, and updating avail_in or avail_out
 * accordingly; avail_out should never be zero before the call. The
 * application can consume the compressed output when it wants, for
 * example when the output buffer is full (avail_out == 0), or after
 * each call of deflate(). If deflate returns Z_OK and with zero
 * avail_out, it must be called again after making room in the output
 * buffer because there might be more output pending. See
 * deflatePending(), which can be used if desired to determine whether
 * or not there is more ouput in that case.
 *
 * Normally the parameter flush is set to Z_NO_FLUSH, which allows
 * deflate to decide how much data to accumulate before producing
 * output, in order to maximize compression.
 *
 * If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
 * flushed to the output buffer and the output is aligned on a byte
 * boundary, so that the decompressor can get all input data available
 * so far. (In particular avail_in is zero after the call if enough
 * output space has been provided before the call.) Flushing may degrade
 * compression for some compression algorithms and so it should be used
 * only when necessary. This completes the current deflate block and
 * follows it with an empty stored block that is three bits plus filler
 * bits to the next byte, followed by four bytes (00 00 ff ff).
 *
 * If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to
 * the output buffer, but the output is not aligned to a byte boundary.
 * All of the input data so far will be available to the decompressor,
 * as for Z_SYNC_FLUSH. This completes the current deflate block and
 * follows it with an empty fixed codes block that is 10 bits long. This
 * assures that enough bytes are output in order for the decompressor to
 * finish the block before the empty fixed codes block.
 *
 * If flush is set to Z_BLOCK, a deflate block is completed and emitted,
 * as for Z_SYNC_FLUSH, but the output is not aligned on a byte
 * boundary, and up to seven bits of the current block are held to be
 * written as the next byte after the next deflate block is completed.
 * In this case, the decompressor may not be provided enough bits at
 * this point in order to complete decompression of the data provided so
 * far to the compressor. It may need to wait for the next block to be
 * emitted. This is for advanced applications that need to control the
 * emission of deflate blocks.
 *
 * If flush is set to Z_FULL_FLUSH, all output is flushed as with
 * Z_SYNC_FLUSH, and the compression state is reset so that
 * decompression can restart from this point if previous compressed data
 * has been damaged or if random access is desired. Using Z_FULL_FLUSH
 * too often can seriously degrade compression.
 *
 * If deflate returns with avail_out == 0, this function must be called
 * again with the same value of the flush parameter and more output
 * space (updated avail_out), until the flush is complete (deflate
 * returns with non-zero avail_out). In the case of a Z_FULL_FLUSH or
 * Z_SYNC_FLUSH, make sure that avail_out is greater than six to avoid
 * repeated flush markers due to avail_out == 0 on return.
 *
 * If the parameter flush is set to Z_FINISH, pending input is
 * processed, pending output is flushed and deflate returns with
 * Z_STREAM_END if there was enough output space. If deflate returns
 * with Z_OK or Z_BUF_ERROR, this function must be called again with
 * Z_FINISH and more output space (updated avail_out) but no more input
 * data, until it returns with Z_STREAM_END or an error. After deflate
 * has returned Z_STREAM_END, the only possible operations on the stream
 * are deflateReset or deflateEnd.
 *
 * Z_FINISH can be used in the first deflate call after deflateInit if
 * all the compression is to be done in a single step. In order to
 * complete in one call, avail_out must be at least the value returned
 * by deflateBound (see below). Then deflate is guaranteed to return
 * Z_STREAM_END. If not enough output space is provided, deflate will
 * not return Z_STREAM_END, and it must be called again as described
 * above.
 *
 * deflate() sets strm->adler to the Adler-32 checksum of all input read
 * so far (that is, total_in bytes). If a gzip stream is being
 * generated, then strm->adler will be the CRC-32 checksum of the input
 * read so far. (See deflateInit2 below.)
 *
 * deflate() may update strm->data_type if it can make a good guess about
 * the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
 * considered binary.  This field is only for information purposes and does not
 * affect the compression algorithm in any manner.
 *
 * @return Z_OK if some progress has been made (more input processed or
 *     more output produced), Z_STREAM_END if all input has been
 *     consumed and all output has been produced (only when flush is set
 *     to Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent
 *     (for example if next_in or next_out was Z_NULL or the state was
 *     inadvertently written over by the application), or Z_BUF_ERROR if
 *     no progress is possible (for example avail_in or avail_out was
 *     zero). Note that Z_BUF_ERROR is not fatal, and deflate() can be
 *     called again with more input and more output space to continue
 *     compressing.
 */
int deflate(z_streamp strm, int flush);

/**
 * All dynamically allocated data structures for this stream are freed.
 * This function discards any unprocessed input and does not flush any
 * pending output.
 *
 * @return Z_OK if success, Z_STREAM_ERROR if the stream state was
 *     inconsistent, Z_DATA_ERROR if the stream was freed prematurely
 *     (some input or output was discarded). In the error case, msg may
 *     be set but then points to a static string (which must not be
 *     deallocated).
 */
int deflateEnd(z_streamp strm);

/**
 * Initializes the internal stream state for decompression. The fields
 * next_in, avail_in, zalloc, zfree and opaque must be initialized
 * before by the caller. In the current version of inflate, the provided
 * input is not read or consumed. The allocation of a sliding window
 * will be deferred to the first call of inflate (if the decompression
 * does not complete on the first call). If zalloc and zfree are set to
 * Z_NULL, inflateInit updates them to use default allocation functions.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     or Z_STREAM_ERROR if the parameters are invalid, such as a null
 *     pointer to the structure. msg is set to null if there is no error
 *     message. inflateInit does not perform any decompression. Actual
 *     decompression will be done by inflate(). So next_in, and
 *     avail_in, next_out, and avail_out are unused and unchanged. The
 *     current implementation of inflateInit() does not process any
 *     header information -- that is deferred until inflate() is called.
 */
int inflateInit(z_streamp strm);

/**
 * inflate decompresses as much data as possible, and stops when the input
 * buffer becomes empty or the output buffer becomes full.  It may introduce
 * some output latency (reading input without producing any output) except when
 * forced to flush.
 *
 * The detailed semantics are as follows.  inflate performs one or both of the
 * following actions:
 *
 * - Decompress more input starting at next_in and update next_in and
 *   avail_in accordingly. If not all input can be processed (because
 *   there is not enough room in the output buffer), then next_in and
 *   avail_in are updated accordingly, and processing will resume at
 *   this point for the next call of inflate().
 *
 * - Generate more output starting at next_out and update next_out and
 *   avail_out accordingly. inflate() provides as much output as
 *   possible, until there is no more input data or no more space in the
 *   output buffer (see below about the flush parameter).
 *
 * Before the call of inflate(), the application should ensure that at
 * least one of the actions is possible, by providing more input and/or
 * consuming more output, and updating the next_* and avail_* values
 * accordingly. If the caller of inflate() does not provide both
 * available input and available output space, it is possible that there
 * will be no progress made. The application can consume the
 * uncompressed output when it wants, for example when the output buffer
 * is full (avail_out == 0), or after each call of inflate(). If inflate
 * returns Z_OK and with zero avail_out, it must be called again after
 * making room in the output buffer because there might be more output
 * pending.
 *
 * The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH,
 * Z_FINISH, Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate()
 * flush as much output as possible to the output buffer. Z_BLOCK
 * requests that inflate() stop if and when it gets to the next deflate
 * block boundary. When decoding the zlib or gzip format, this will
 * cause inflate() to return immediately after the header and before the
 * first block. When doing a raw inflate, inflate() will go ahead and
 * process the first block, and will return when it gets to the end of
 * that block, or when it runs out of data.
 *
 * The Z_BLOCK option assists in appending to or combining deflate
 * streams. To assist in this, on return inflate() always sets
 * strm->data_type to the number of unused bits in the last byte taken
 * from strm->next_in, plus 64 if inflate() is currently decoding the
 * last block in the deflate stream, plus 128 if inflate() returned
 * immediately after decoding an end-of-block code or decoding the
 * complete header up to just before the first byte of the deflate
 * stream. The end-of-block will not be indicated until all of the
 * uncompressed data from that block has been written to strm->next_out.
 * The number of unused bits may in general be greater than seven,
 * except when bit 7 of data_type is set, in which case the number of
 * unused bits will be less than eight. data_type is set as noted here
 * every time inflate() returns for all flush options, and so can be
 * used to determine the amount of currently consumed input in bits.
 *
 * The Z_TREES option behaves as Z_BLOCK does, but it also returns when
 * the end of each deflate block header is reached, before any actual
 * data in that block is decoded. This allows the caller to determine
 * the length of the deflate block header for later use in random access
 * within a deflate block. 256 is added to the value of strm->data_type
 * when inflate() returns immediately after reaching the end of the
 * deflate block header.
 *
 * inflate() should normally be called until it returns Z_STREAM_END or
 * an error. However if all decompression is to be performed in a single
 * step (a single call of inflate), the parameter flush should be set to
 * Z_FINISH. In this case all pending input is processed and all pending
 * output is flushed; avail_out must be large enough to hold all of the
 * uncompressed data for the operation to complete. (The size of the
 * uncompressed data may have been saved by the compressor for this
 * purpose.) The use of Z_FINISH is not required to perform an inflation
 * in one step. However it may be used to inform inflate that a faster
 * approach can be used for the single inflate() call. Z_FINISH also
 * informs inflate to not maintain a sliding window if the stream
 * completes, which reduces inflate's memory footprint. If the stream
 * does not complete, either because not all of the stream is provided
 * or not enough output space is provided, then a sliding window will be
 * allocated and inflate() can be called again to continue the operation
 * as if Z_NO_FLUSH had been used.
 *
 * In this implementation, inflate() always flushes as much output as
 * possible to the output buffer, and always uses the faster approach on
 * the first call. So the effects of the flush parameter in this
 * implementation are on the return value of inflate() as noted below,
 * when inflate() returns early when Z_BLOCK or Z_TREES is used, and
 * when inflate() avoids the allocation of memory for a sliding window
 * when Z_FINISH is used.
 *
 * If a preset dictionary is needed after this call (see
 * inflateSetDictionary below), inflate sets strm->adler to the Adler-32
 * checksum of the dictionary chosen by the compressor and returns
 * Z_NEED_DICT; otherwise it sets strm->adler to the Adler-32 checksum
 * of all output produced so far (that is, total_out bytes) and returns
 * Z_OK, Z_STREAM_END or an error code as described below. At the end of
 * the stream, inflate() checks that its computed Adler-32 checksum is
 * equal to that saved by the compressor and returns Z_STREAM_END only
 * if the checksum is correct.
 *
 * inflate() can decompress and check either zlib-wrapped or
 * gzip-wrapped deflate data. The header type is detected automatically,
 * if requested when initializing with inflateInit2(). Any information
 * contained in the gzip header is not retained unless
 * inflateGetHeader() is used. When processing gzip-wrapped deflate
 * data, strm->adler32 is set to the CRC-32 of the output produced so
 * far. The CRC-32 is checked against the gzip trailer, as is the
 * uncompressed length, modulo 2^32.
 *
 * @return Z_OK if some progress has been made (more input processed or
 *     more output produced), Z_STREAM_END if the end of the compressed
 *     data has been reached and all uncompressed output has been
 *     produced, Z_NEED_DICT if a preset dictionary is needed at this
 *     point, Z_DATA_ERROR if the input data was corrupted (input stream
 *     not conforming to the zlib format or incorrect check value, in
 *     which case strm->msg points to a string with a more specific
 *     error), Z_STREAM_ERROR if the stream structure was inconsistent
 *     (for example next_in or next_out was Z_NULL, or the state was
 *     inadvertently written over by the application), Z_MEM_ERROR if
 *     there was not enough memory, Z_BUF_ERROR if no progress was
 *     possible or if there was not enough room in the output buffer
 *     when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and
 *     inflate() can be called again with more input and more output
 *     space to continue decompressing. If Z_DATA_ERROR is returned, the
 *     application may then call inflateSync() to look for a good
 *     compression block if a partial recovery of the data is to be
 *     attempted.
 */
int inflate(z_streamp strm, int flush);

/**
 * All dynamically allocated data structures for this stream are freed.
 * This function discards any unprocessed input and does not flush any
 * pending output.
 *
 * @return Z_OK or Z_STREAM_ERROR if stream state inconsistent
 */
int inflateEnd(z_streamp strm);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § zlib » special functions                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  the following functions are needed only in some special applications */

/**
 * This is another version of deflateInit with more compression options.
 * The fields next_in, zalloc, zfree and opaque must be initialized
 * before by the caller.
 *
 * The method parameter is the compression method. It must be Z_DEFLATED
 * in this version of the library.
 *
 * The windowBits parameter is the base two logarithm of the window size
 * (the size of the history buffer). It should be in the range 8..15 for
 * this version of the library. Larger values of this parameter result
 * in better compression at the expense of memory usage. The default
 * value is 15 if deflateInit is used instead.
 *
 * For the current implementation of deflate(), a windowBits value of 8
 * (a window size of 256 bytes) is not supported. As a result, a request
 * for 8 will result in 9 (a 512-byte window). In that case, providing 8
 * to inflateInit2() will result in an error when the zlib header with 9
 * is checked against the initialization of inflate(). The remedy is to
 * not use 8 with deflateInit2() with this initialization, or at least
 * in that case use 9 with inflateInit2().
 *
 * windowBits can also be -8..-15 for raw deflate. In this case,
 * -windowBits determines the window size. deflate() will then generate
 * raw deflate data with no zlib header or trailer, and will not compute
 * a check value.
 *
 * windowBits can also be greater than 15 for optional gzip encoding.
 * Add 16 to windowBits to write a simple gzip header and trailer around
 * the compressed data instead of a zlib wrapper. The gzip header will
 * have no file name, no extra data, no comment, no modification time
 * (set to zero), no header crc, and the operating system will be set to
 * the appropriate value, if the operating system was determined at
 * compile time. If a gzip stream is being written, strm->adler is a
 * CRC-32 instead of an Adler-32.
 *
 * For raw deflate or gzip encoding, a request for a 256-byte window is
 * rejected as invalid, since only the zlib header provides a means of
 * transmitting the window size to the decompressor.
 *
 * The memLevel parameter specifies how much memory should be allocated
 * for the internal compression state. memLevel=1 uses minimum memory
 * but is slow and reduces compression ratio; memLevel=9 uses maximum
 * memory for optimal speed. The default value is 8. See zconf.h for
 * total memory usage as a function of windowBits and memLevel.
 *
 * The strategy parameter is used to tune the compression algorithm. Use
 * the value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data
 * produced by a filter (or predictor), Z_HUFFMAN_ONLY to force Huffman
 * encoding only (no string match), or Z_RLE to limit match distances to
 * one (run-length encoding). Filtered data consists mostly of small
 * values with a somewhat random distribution. In this case, the
 * compression algorithm is tuned to compress them better. The effect of
 * Z_FILTERED is to force more Huffman coding and less string matching;
 * it is somewhat intermediate between Z_DEFAULT_STRATEGY and
 * Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as fast as
 * Z_HUFFMAN_ONLY, but give better compression for PNG image data. The
 * strategy parameter only affects the compression ratio but not the
 * correctness of the compressed output even if it is not set
 * appropriately. Z_FIXED prevents the use of dynamic Huffman codes,
 * allowing for a simpler decoder for special applications.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     or Z_STREAM_ERROR if any parameter is invalid (such as an invalid
 *     method). msg is set to null if there is no error message.
 *     deflateInit2 does not perform any compression: this will be done
 *     by deflate().
 */
int deflateInit2(z_streamp strm, int level, int method, int windowBits,
                 int memLevel, int strategy);

/**
 * Initializes the compression dictionary from the given byte sequence
 * without producing any compressed output. When using the zlib format,
 * this function must be called immediately after deflateInit,
 * deflateInit2 or deflateReset, and before any call of deflate. When
 * doing raw deflate, this function must be called either before any
 * call of deflate, or immediately after the completion of a deflate
 * block, i.e. after all input has been consumed and all output has been
 * delivered when using any of the flush options Z_BLOCK,
 * Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH. The compressor and
 * decompressor must use exactly the same dictionary (see
 * inflateSetDictionary).
 *
 * The dictionary should consist of strings (byte sequences) that are
 * likely to be encountered later in the data to be compressed, with the
 * most commonly used strings preferably put towards the end of the
 * dictionary. Using a dictionary is most useful when the data to be
 * compressed is short and can be predicted with good accuracy; the data
 * can then be compressed better than with the default empty dictionary.
 *
 * Depending on the size of the compression data structures selected by
 * deflateInit or deflateInit2, a part of the dictionary may in effect
 * be discarded, for example if the dictionary is larger than the window
 * size provided in deflateInit or deflateInit2. Thus the strings most
 * likely to be useful should be put at the end of the dictionary, not
 * at the front. In addition, the current implementation of deflate will
 * use at most the window size minus 262 bytes of the provided
 * dictionary.
 *
 * Upon return of this function, strm->adler is set to the Adler-32
 * value of the dictionary; the decompressor may later use this value to
 * determine which dictionary has been used by the compressor. (The
 * Adler-32 value applies to the whole dictionary even if only a subset
 * of the dictionary is actually used by the compressor.) If a raw
 * deflate was requested, then the Adler-32 value is not computed and
 * strm->adler is not set.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if a parameter is invalid
 *     (e.g. dictionary being Z_NULL) or the stream state is
 *     inconsistent (for example if deflate has already been called for
 *     this stream or if not at a block boundary for raw deflate).
 *     deflateSetDictionary does not perform any compression: this will
 *     be done by deflate().
 */
int deflateSetDictionary(z_streamp strm, const Bytef *dictionary,
                         uInt dictLength);

/**
 * Returns the sliding dictionary being maintained by deflate.  dictLength is
 * set to the number of bytes in the dictionary, and that many bytes are copied
 * to dictionary.  dictionary must have enough space, where 32768 bytes is
 * always enough.  If deflateGetDictionary() is called with dictionary equal to
 * Z_NULL, then only the dictionary length is returned, and nothing is copied.
 * Similary, if dictLength is Z_NULL, then it is not set.
 *
 * deflateGetDictionary() may return a length less than the window size, even
 * when more than the window size in input has been provided. It may return up
 * to 258 bytes less in that case, due to how zlib's implementation of deflate
 * manages the sliding window and lookahead for matches, where matches can be
 * up to 258 bytes long. If the application needs the last window-size bytes of
 * input, then that would need to be saved by the application outside of zlib.
 *
 * @return Z_OK on success, or Z_STREAM_ERROR if the stream state is
 *     inconsistent.
 */
int deflateGetDictionary(z_streamp strm, Bytef *dictionary, uInt *dictLength);

/**
 * Sets destination stream as a complete copy of the source stream.
 *
 * This function can be useful when several compression strategies will be
 * tried, for example when there are several ways of pre-processing the input
 * data with a filter.  The streams that will be discarded should then be freed
 * by calling deflateEnd.  Note that deflateCopy duplicates the internal
 * compression state which can be quite large, so this strategy is slow and can
 * consume lots of memory.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_STREAM_ERROR if the source stream state was inconsistent (such
 *     as zalloc being Z_NULL). msg is left unchanged in both source and
 *     destination.
 */
int deflateCopy(z_streamp dest, z_streamp source);

/**
 * This function is equivalent to deflateEnd followed by deflateInit, but
 * does not free and reallocate the internal compression state.  The stream
 * will leave the compression level and any other attributes that may have been
 * set unchanged.
 *
 * deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
 * stream state was inconsistent (such as zalloc or state being Z_NULL).
 */
int deflateReset(z_streamp strm);

/**
 * Dynamically update the compression level and compression strategy.  The
 * interpretation of level and strategy is as in deflateInit2().  This can be
 * used to switch between compression and straight copy of the input data, or
 * to switch to a different kind of input data requiring a different strategy.
 * If the compression approach (which is a function of the level) or the
 * strategy is changed, and if any input has been consumed in a previous
 * deflate() call, then the input available so far is compressed with the old
 * level and strategy using deflate(strm, Z_BLOCK).  There are three approaches
 * for the compression levels 0, 1..3, and 4..9 respectively.  The new level
 * and strategy will take effect at the next call of deflate().
 *
 * If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
 * not have enough output space to complete, then the parameter change will not
 * take effect.  In this case, deflateParams() can be called again with the
 * same parameters and more output space to try again.
 *
 * In order to assure a change in the parameters on the first try, the
 * deflate stream should be flushed using deflate() with Z_BLOCK or other flush
 * request until strm.avail_out is not zero, before calling deflateParams().
 * Then no more input data should be provided before the deflateParams() call.
 * If this is done, the old level and strategy will be applied to the data
 * compressed before deflateParams(), and the new level and strategy will be
 * applied to the the data compressed after deflateParams().
 *
 * deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
 * state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
 * there was not enough output space to complete the compression of the
 * available input data before a change in the strategy or approach.  Note that
 * in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
 * value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
 * retried with more output space.
 */
int deflateParams(z_streamp strm, int level, int strategy);

/**
 * Fine tune deflate's internal compression parameters. This should only
 * be used by someone who understands the algorithm used by zlib's
 * deflate for searching for the best matching string, and even then
 * only by the most fanatic optimizer trying to squeeze out the last
 * compressed bit for their specific input data. Read the deflate.c
 * source code for the meaning of the max_lazy, good_length,
 * nice_length, and max_chain parameters.
 *
 * deflateTune() can be called after deflateInit() or deflateInit2(), and
 * returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
 */
int deflateTune(z_streamp strm, int good_length, int max_lazy, int nice_length,
                int max_chain);

/**
 * deflateBound() returns an upper bound on the compressed size after
 * deflation of sourceLen bytes. It must be called after deflateInit()
 * or deflateInit2(), and after deflateSetHeader(), if used. This would
 * be used to allocate an output buffer for deflation in a single pass,
 * and so would be called before deflate(). If that first deflate() call
 * is provided the sourceLen input bytes, an output buffer allocated to
 * the size returned by deflateBound(), and the flush value Z_FINISH,
 * then deflate() is guaranteed to return Z_STREAM_END. Note that it is
 * possible for the compressed size to be larger than the value returned
 * by deflateBound() if flush options other than Z_FINISH or Z_NO_FLUSH
 * are used.
 */
uLong deflateBound(z_streamp strm, uLong sourceLen);

/**
 * deflatePending() returns the number of bytes and bits of output that
 * have been generated, but not yet provided in the available output.
 * The bytes not provided would be due to the available output space
 * having being consumed. The number of bits of output not provided are
 * between 0 and 7, where they await more bits to join them in order to
 * fill out a full byte. If pending or bits are Z_NULL, then those
 * values are not set.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent.
 */
int deflatePending(z_streamp strm, unsigned *pending, int *bits);

/**
 * deflatePrime() inserts bits in the deflate output stream.  The intent
 * is that this function is used to start off the deflate output with the bits
 * leftover from a previous deflate stream when appending to it.  As such, this
 * function can only be used for raw deflate, and must be used before the first
 * deflate() call after a deflateInit2() or deflateReset().  bits must be less
 * than or equal to 16, and that many of the least significant bits of value
 * will be inserted in the output.
 *
 * @return Z_OK if success, Z_BUF_ERROR if there was not enough room in
 *     the internal buffer to insert the bits, or Z_STREAM_ERROR if the
 *     source stream state was inconsistent.
 */
int deflatePrime(z_streamp strm, int bits, int value);

/**
 * Provides gzip header information for when a gzip stream is requested
 * by deflateInit2(). deflateSetHeader() may be called after
 * deflateInit2() or deflateReset() and before the first call of
 * deflate(). The text, time, os, extra field, name, and comment
 * information in the provided gz_header structure are written to the
 * gzip header (xflag is ignored -- the extra flags are set according to
 * the compression level). The caller must assure that, if not Z_NULL,
 * name and comment are terminated with a zero byte, and that if extra
 * is not Z_NULL, that extra_len bytes are available there. If hcrc is
 * true, a gzip header crc is included. Note that the current versions
 * of the command-line version of gzip (up through version 1.3.x) do not
 * support header crc's, and will report that it is a "multi-part gzip
 * file" and give up.
 *
 * If deflateSetHeader is not used, the default gzip header has text
 * false, the time set to zero, and os set to 255, with no extra, name,
 * or comment fields. The gzip header is returned to the default state
 * by deflateReset().
 *
 * deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the
 * source stream state was inconsistent.
 */
int deflateSetHeader(z_streamp strm, gz_headerp head);

/**
 * This is another version of inflateInit with an extra parameter. The
 * fields next_in, avail_in, zalloc, zfree and opaque must be
 * initialized before by the caller.
 *
 * The windowBits parameter is the base two logarithm of the maximum
 * window size (the size of the history buffer). It should be in the
 * range 8..15 for this version of the library. The default value is 15
 * if inflateInit is used instead. windowBits must be greater than or
 * equal to the windowBits value provided to deflateInit2() while
 * compressing, or it must be equal to 15 if deflateInit2() was not
 * used. If a compressed stream with a larger window size is given as
 * input, inflate() will return with the error code Z_DATA_ERROR instead
 * of trying to allocate a larger window.
 *
 * windowBits can also be zero to request that inflate use the window
 * size in the zlib header of the compressed stream.
 *
 * windowBits can also be -8..-15 for raw inflate. In this case,
 * -windowBits determines the window size. inflate() will then process
 * raw deflate data, not looking for a zlib or gzip header, not
 * generating a check value, and not looking for any check values for
 * comparison at the end of the stream. This is for use with other
 * formats that use the deflate compressed data format such as zip.
 * Those formats provide their own check values. If a custom format is
 * developed using the raw deflate format for compressed data, it is
 * recommended that a check value such as an Adler-32 or a CRC-32 be
 * applied to the uncompressed data as is done in the zlib, gzip, and
 * zip formats. For most applications, the zlib format should be used as
 * is. Note that comments above on the use in deflateInit2() applies to
 * the magnitude of windowBits.
 *
 * windowBits can also be greater than 15 for optional gzip decoding.
 * Add 32 to windowBits to enable zlib and gzip decoding with automatic
 * header detection, or add 16 to decode only the gzip format (the zlib
 * format will return a Z_DATA_ERROR). If a gzip stream is being
 * decoded, strm->adler is a CRC-32 instead of an Adler-32. Unlike the
 * gunzip utility and gzread() (see below), inflate() will not
 * automatically decode concatenated gzip streams. inflate() will return
 * Z_STREAM_END at the end of the gzip stream. The state would need to
 * be reset to continue decoding a subsequent gzip stream.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     or Z_STREAM_ERROR if the parameters are invalid, such as a null
 *     pointer to the structure. msg is set to null if there is no error
 *     message. inflateInit2 does not perform any decompression apart
 *     from possibly reading the zlib header if present: actual
 *     decompression will be done by inflate(). (So next_in and avail_in
 *     may be modified, but next_out and avail_out are unused and
 *     unchanged.) The current implementation of inflateInit2() does not
 *     process any header information -- that is deferred until
 *     inflate() is called.
 */
int inflateInit2(z_streamp strm, int windowBits);

/**
 * Initializes the decompression dictionary from the given uncompressed
 * byte sequence. This function must be called immediately after a call
 * of inflate, if that call returned Z_NEED_DICT. The dictionary chosen
 * by the compressor can be determined from the Adler-32 value returned
 * by that call of inflate. The compressor and decompressor must use
 * exactly the same dictionary (see deflateSetDictionary). For raw
 * inflate, this function can be called at any time to set the
 * dictionary. If the provided dictionary is smaller than the window and
 * there is already data in the window, then the provided dictionary
 * will amend what's there. The application must insure that the
 * dictionary that was used for compression is provided.
 *
 * @return Z_OK if success, Z_STREAM_ERROR if a parameter is invalid
 *     (e.g. dictionary being Z_NULL) or the stream state is
 *     inconsistent, Z_DATA_ERROR if the given dictionary doesn't match
 *     the expected one (incorrect Adler-32 value). inflateSetDictionary
 *     does not perform any decompression: this will be done by
 *     subsequent calls of inflate().
 */
int inflateSetDictionary(z_streamp strm, const Bytef *dictionary,
                         uInt dictLength);

/**
 * Returns the sliding dictionary being maintained by inflate.  dictLength is
 * set to the number of bytes in the dictionary, and that many bytes are copied
 * to dictionary.  dictionary must have enough space, where 32768 bytes is
 * always enough.  If inflateGetDictionary() is called with dictionary equal to
 * Z_NULL, then only the dictionary length is returned, and nothing is copied.
 * Similary, if dictLength is Z_NULL, then it is not set.
 *
 * @return Z_OK on success, or Z_STREAM_ERROR if the stream state is
 *     inconsistent.
 */
int inflateGetDictionary(z_streamp strm, Bytef *dictionary, uInt *dictLength);

/**
 * Skips invalid compressed data until a possible full flush point (see
 * above for the description of deflate with Z_FULL_FLUSH) can be found,
 * or until all available input is skipped. No output is provided.
 *
 * inflateSync searches for a 00 00 FF FF pattern in the compressed
 * data. All full flush points have this pattern, but not all
 * occurrences of this pattern are full flush points.
 *
 * @return Z_OK if a possible full flush point has been found,
 *     Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no
 *     flush point has been found, or Z_STREAM_ERROR if the stream
 *     structure was inconsistent. In the success case, the application
 *     may save the current current value of total_in which indicates
 *     where valid compressed data was found. In the error case, the
 *     application may repeatedly call inflateSync, providing more input
 *     each time, until success or end of the input data.
 */
int inflateSync(z_streamp strm);

/**
 * Sets the destination stream as a complete copy of the source stream.
 *
 * This function can be useful when randomly accessing a large stream.
 * The first pass through the stream can periodically record the inflate
 * state, allowing restarting inflate at those points when randomly
 * accessing the stream.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_STREAM_ERROR if the source stream state was inconsistent (such
 *     as zalloc being Z_NULL). msg is left unchanged in both source and
 *     destination.
 */
int inflateCopy(z_streamp dest, z_streamp source);

/**
 * This function is equivalent to inflateEnd followed by inflateInit,
 * but does not free and reallocate the internal decompression state.  The
 * stream will keep attributes that may have been set by inflateInit2.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent (such as zalloc or state being Z_NULL).
 */
int inflateReset(z_streamp strm);

/**
 * This function is the same as inflateReset, but it also permits changing
 * the wrap and window size requests.  The windowBits parameter is interpreted
 * the same as it is for inflateInit2.  If the window size is changed, then the
 * memory allocated for the window is freed, and the window will be reallocated
 * by inflate() if needed.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent (such as zalloc or state being Z_NULL), or if
 *     the windowBits parameter is invalid.
 */
int inflateReset2(z_streamp strm, int windowBits);

/**
 * This function inserts bits in the inflate input stream.  The intent is
 * that this function is used to start inflating at a bit position in the
 * middle of a byte.  The provided bits will be used before any bytes are used
 * from next_in.  This function should only be used with raw inflate, and
 * should be used before the first inflate() call after inflateInit2() or
 * inflateReset().  bits must be less than or equal to 16, and that many of the
 * least significant bits of value will be inserted in the input.
 *
 * If bits is negative, then the input stream bit buffer is emptied.  Then
 * inflatePrime() can be called again to put bits in the buffer.  This is used
 * to clear out bits leftover after feeding inflate a block description prior
 * to feeding inflate codes.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent.
 */
int inflatePrime(z_streamp strm, int bits, int value);

/**
 * Returns two values, one in the lower 16 bits of the return value, and
 * the other in the remaining upper bits, obtained by shifting the
 * return value down 16 bits. If the upper value is -1 and the lower
 * value is zero, then inflate() is currently decoding information
 * outside of a block. If the upper value is -1 and the lower value is
 * non-zero, then inflate is in the middle of a stored block, with the
 * lower value equaling the number of bytes from the input remaining to
 * copy. If the upper value is not -1, then it is the number of bits
 * back from the current bit position in the input of the code (literal
 * or length/distance pair) currently being processed. In that case the
 * lower value is the number of bytes already emitted for that code.
 *
 * A code is being processed if inflate is waiting for more input to
 * complete decoding of the code, or if it has completed decoding but is
 * waiting for more output space to write the literal or match data.
 *
 * inflateMark() is used to mark locations in the input data for random
 * access, which may be at bit positions, and to note those cases where
 * the output of a code may span boundaries of random access blocks. The
 * current location in the input stream can be determined from avail_in
 * and data_type as noted in the description for the Z_BLOCK flush
 * parameter for inflate.
 *
 * @return the value noted above, or -65536 if the provided source
 *     stream state was inconsistent.
 */
long inflateMark(z_streamp strm);

/**
 * inflateGetHeader() requests that gzip header information be stored in
 * the provided gz_header structure. inflateGetHeader() may be called
 * after inflateInit2() or inflateReset(), and before the first call of
 * inflate(). As inflate() processes the gzip stream, head->done is zero
 * until the header is completed, at which time head->done is set to
 * one. If a zlib stream is being decoded, then head->done is set to -1
 * to indicate that there will be no gzip header information
 * forthcoming. Note that Z_BLOCK or Z_TREES can be used to force
 * inflate() to return immediately after header processing is complete
 * and before any actual data is decompressed.
 *
 * The text, time, xflags, and os fields are filled in with the gzip
 * header contents. hcrc is set to true if there is a header CRC. (The
 * header CRC was valid if done is set to one.) If extra is not Z_NULL,
 * then extra_max contains the maximum number of bytes to write to
 * extra. Once done is true, extra_len contains the actual extra field
 * length, and extra contains the extra field, or that field truncated
 * if extra_max is less than extra_len. If name is not Z_NULL, then up
 * to name_max characters are written there, terminated with a zero
 * unless the length is greater than name_max. If comment is not Z_NULL,
 * then up to comm_max characters are written there, terminated with a
 * zero unless the length is greater than comm_max. When any of extra,
 * name, or comment are not Z_NULL and the respective field is not
 * present in the header, then that field is set to Z_NULL to signal its
 * absence. This allows the use of deflateSetHeader() with the returned
 * structure to duplicate the header. However if those fields are set to
 * allocated memory, then the application will need to save those
 * pointers elsewhere so that they can be eventually freed.
 *
 * If inflateGetHeader is not used, then the header information is
 * simply discarded. The header is always checked for validity,
 * including the header CRC if present. inflateReset() will reset the
 * process to discard the header information. The application would need
 * to call inflateGetHeader() again to retrieve the header from the next
 * gzip stream.
 *
 * @return Z_OK if success, or Z_STREAM_ERROR if the source stream state
 *     was inconsistent.
 */
int inflateGetHeader(z_streamp strm, gz_headerp head);

/**
 * Initialize internal stream state for decompression using
 * inflateBack() calls. The fields zalloc, zfree and opaque in strm must
 * be initialized before the call. If zalloc and zfree are Z_NULL, then
 * the default library- derived memory allocation routines are used.
 * windowBits is the base two logarithm of the window size, in the range
 * 8..15. window is a caller supplied buffer of that size. Except for
 * special applications where it is assured that deflate was used with
 * small window sizes, windowBits must be 15 and a 32K byte window must
 * be supplied to be able to decompress general deflate streams.
 *
 * See inflateBack() for the usage of these routines.
 *
 * @return Z_OK on success, Z_STREAM_ERROR if any of the parameters are
 *     invalid, or Z_MEM_ERROR if the internal state could not be
 *     allocated.
 */
int inflateBackInit(z_streamp strm, int windowBits, unsigned char *window);

typedef unsigned (*in_func)(void *, const unsigned char **);
typedef int (*out_func)(void *, unsigned char *, unsigned);

/**
 * inflateBack() does a raw inflate with a single call using a call-back
 * interface for input and output. This is potentially more efficient
 * than inflate() for file i/o applications, in that it avoids copying
 * between the output and the sliding window by simply making the window
 * itself the output buffer. inflate() can be faster on modern CPUs when
 * used with large buffers. inflateBack() trusts the application to not
 * change the output buffer passed by the output function, at least
 * until inflateBack() returns.
 *
 * inflateBackInit() must be called first to allocate the internal state
 * and to initialize the state with the user-provided window buffer.
 * inflateBack() may then be used multiple times to inflate a complete,
 * raw deflate stream with each call. inflateBackEnd() is then called to
 * free the allocated state.
 *
 * A raw deflate stream is one with no zlib or gzip header or trailer.
 * This routine would normally be used in a utility that reads zip or
 * gzip files and writes out uncompressed files. The utility would
 * decode the header and process the trailer on its own, hence this
 * routine expects only the raw deflate stream to decompress. This is
 * different from the default behavior of inflate(), which expects a
 * zlib header and trailer around the deflate stream.
 *
 * inflateBack() uses two subroutines supplied by the caller that are
 * then called by inflateBack() for input and output. inflateBack()
 * calls those routines until it reads a complete deflate stream and
 * writes out all of the uncompressed data, or until it encounters an
 * error. The function's parameters and return types are defined above
 * in the in_func and out_func typedefs. inflateBack() will call
 * in(in_desc, &buf) which should return the number of bytes of provided
 * input, and a pointer to that input in buf. If there is no input
 * available, in() must return zero -- buf is ignored in that case --
 * and inflateBack() will return a buffer error. inflateBack() will call
 * out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
 * out() should return zero on success, or non-zero on failure. If out()
 * returns non-zero, inflateBack() will return with an error. Neither
 * in() nor out() are permitted to change the contents of the window
 * provided to inflateBackInit(), which is also the buffer that out()
 * uses to write from. The length written by out() will be at most the
 * window size. Any non-zero amount of input may be provided by in().
 *
 * For convenience, inflateBack() can be provided input on the first
 * call by setting strm->next_in and strm->avail_in. If that input is
 * exhausted, then in() will be called. Therefore strm->next_in must be
 * initialized before calling inflateBack(). If strm->next_in is Z_NULL,
 * then in() will be called immediately for input. If strm->next_in is
 * not Z_NULL, then strm->avail_in must also be initialized, and then if
 * strm->avail_in is not zero, input will initially be taken from
 * strm->next_in[0 .. strm->avail_in - 1].
 *
 * The in_desc and out_desc parameters of inflateBack() is passed as the
 * first parameter of in() and out() respectively when they are called.
 * These descriptors can be optionally used to pass any information that
 * the caller- supplied in() and out() functions need to do their job.
 *
 * On return, inflateBack() will set strm->next_in and strm->avail_in to
 * pass back any unused input that was provided by the last in() call.
 * The return values of inflateBack() can be Z_STREAM_END on success,
 * Z_BUF_ERROR if in() or out() returned an error, Z_DATA_ERROR if there
 * was a format error in the deflate stream (in which case strm->msg is
 * set to indicate the nature of the error), or Z_STREAM_ERROR if the
 * stream was not properly initialized. In the case of Z_BUF_ERROR, an
 * input or output error can be distinguished using strm->next_in which
 * will be Z_NULL only if in() returned an error. If strm->next_in is
 * not Z_NULL, then the Z_BUF_ERROR was due to out() returning non-zero.
 * (in() will always be called before out(), so strm->next_in is assured
 * to be defined if out() returns non-zero.) Note that inflateBack()
 * cannot return Z_OK.
 */
int inflateBack(z_streamp strm, in_func in, void *in_desc, out_func out,
                void *out_desc);

/**
 * All memory allocated by inflateBackInit() is freed.
 *
 * @return Z_OK on success, or Z_STREAM_ERROR if the stream state was
 *     inconsistent.
 */
int inflateBackEnd(z_streamp strm);

/*
 * Return flags indicating compile-time options.
 *
 * Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
 *   1.0: size of uInt
 *   3.2: size of uLong
 *   5.4: size of voidpf (pointer)
 *   7.6: size of off_t
 *
 * Compiler, assembler, and debug options:
 *   8: ZLIB_DEBUG
 *   9: ASMV or ASMINF -- use ASM code
 *   10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
 *   11: 0 (reserved)
 *
 * One-time table building (smaller code, but not thread-safe if true):
 *   12: BUILDFIXED -- build static block decoding tables when needed
 *   13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
 *   14,15: 0 (reserved)
 *
 * Library content (indicates missing functionality):
 *
 *   16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
 *   deflate code when not needed)
 *
 *   17: NO_GZIP -- deflate can't write gzip streams, and inflate can't
 *   detect and decode gzip streams (to avoid linking crc code)
 *
 *   18-19: 0 (reserved)
 *
 * Operation variations (changes in library functionality):
 *   20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
 *   21: FASTEST -- deflate algorithm with only one, lowest compression level
 *   22,23: 0 (reserved)
 *
 * The sprintf variant used by gzprintf (zero is best):
 *   24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
 *   25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
 *   26: 0 = returns value, 1 = void -- 1 means inferred string length returned
 *
 * Remainder is:
 *   27-31: 0 (reserved)
 */
uLong zlibCompileFlags(void);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § zlib » utility functions                                  ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  The following utility functions are implemented on top of the basic
  stream-oriented functions. To simplify the interface, some default
  options are assumed (compression level and memory usage, standard
  memory allocation functions). The source code of these utility
  functions can be modified if you need special options. */

/**
 * Compresses source buffer into the destination buffer. sourceLen is
 * the byte length of the source buffer. Upon entry, destLen is the
 * total size of the destination buffer, which must be at least the
 * value returned by compressBound(sourceLen). Upon exit, destLen is the
 * actual size of the compressed data. compress() is equivalent to
 * compress2() with a level parameter of Z_DEFAULT_COMPRESSION.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_BUF_ERROR if there was not enough room in the output buffer.
 */
int compress(Bytef *dest, uLongf *destLen, const Bytef *source,
             uLong sourceLen);

/**
 * Compresses source buffer into the destination buffer. The level
 * parameter has the same meaning as in deflateInit. sourceLen is the
 * byte length of the source buffer. Upon entry, destLen is the total
 * size of the destination buffer, which must be at least the value
 * returned by compressBound(sourceLen). Upon exit, destLen is the
 * actual size of the compressed data.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_BUF_ERROR if there was not enough room in the output buffer,
 *     Z_STREAM_ERROR if the level parameter is invalid.
 */
int compress2(Bytef *dest, uLongf *destLen, const Bytef *source,
              uLong sourceLen, int level);

/**
 * Returns an upper bound on the compressed size after compress() or
 * compress2() on sourceLen bytes. It would be used before a compress()
 * or compress2() call to allocate the destination buffer.
 */
uLong compressBound(uLong sourceLen);

/**
 * Decompresses the source buffer into the destination buffer.  sourceLen is
 * the byte length of the source buffer.  Upon entry, destLen is the total size
 * of the destination buffer, which must be large enough to hold the entire
 * uncompressed data.  (The size of the uncompressed data must have been saved
 * previously by the compressor and transmitted to the decompressor by some
 * mechanism outside the scope of this compression library.) Upon exit, destLen
 * is the actual size of the uncompressed data.
 *
 * @return Z_OK if success, Z_MEM_ERROR if there was not enough memory,
 *     Z_BUF_ERROR if there was not enough room in the output buffer, or
 *     Z_DATA_ERROR if the input data was corrupted or incomplete. In
 *     the case where there is not enough room, uncompress() will fill
 *     the output buffer with the uncompressed data up to that point.
 */
int uncompress(Bytef *dest, uLongf *destLen, const Bytef *source,
               uLong sourceLen);

/**
 * Same as uncompress, except that sourceLen is a pointer, where the
 * length of the source is *sourceLen.  On return, *sourceLen is the number of
 * source bytes consumed.
 */
int uncompress2(Bytef *dest, uLongf *destLen, const Bytef *source,
                uLong *sourceLen);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § zlib » gzip                                               ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│─╝
  This library supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio, using the functions that
  start with "gz". The gzip format is different from the zlib format.
  gzip is a gzip wrapper, documented in RFC 1952, wrapped around a
  deflate stream. */

typedef struct gzFile_s *gzFile; /* semi-opaque gzip file descriptor */

/**
 * Opens a gzip (.gz) file for reading or writing.
 *
 * The mode parameter is as in fopen ("rb" or "wb") but can also include
 * a compression level ("wb9") or a strategy: 'f' for filtered data as
 * in "wb6f", 'h' for Huffman-only compression as in "wb1h", 'R' for
 * run-length encoding as in "wb1R", or 'F' for fixed code compression
 * as in "wb9F". (See the description of deflateInit2 for more
 * information about the strategy parameter.) 'T' will request
 * transparent writing or appending with no compression and not using
 * the gzip format.
 *
 * "a" can be used instead of "w" to request that the gzip stream that
 * will be written be appended to the file. "+" will result in an error,
 * since reading and writing to the same gzip file is not supported. The
 * addition of "x" when writing will create the file exclusively, which
 * fails if the file already exists. On systems that support it, the
 * addition of "e" when reading or writing will set the flag to close
 * the file on an execve() call.
 *
 * These functions, as well as gzip, will read and decode a sequence of
 * gzip streams in a file. The append function of gzopen() can be used
 * to create such a file. (Also see gzflush() for another way to do
 * this.) When appending, gzopen does not test whether the file begins
 * with a gzip stream, nor does it look for the end of the gzip streams
 * to begin appending. gzopen will simply append a gzip stream to the
 * existing file.
 *
 * gzopen can be used to read a file which is not in gzip format; in
 * this case gzread will directly read from the file without
 * decompression. When reading, this will be detected automatically by
 * looking for the magic two- byte gzip header.
 *
 * @return Z_OK if the file could not be opened, if there was insufficient
 *     memory to allocate the gzFile state, or if an invalid mode was
 *     specified (an 'r', 'w', or 'a' was not provided, or '+' was
 *     provided). errno can be checked to determine if the reason gzopen
 *     failed was that the file could not be opened.
 */
gzFile gzopen(const char *path, const char *mode);

/**
 * Associates gzFile with the file descriptor.
 *
 * File descriptors are obtained from calls like open, dup, creat, pipe
 * or fileno (if the file has been previously opened with fopen). The
 * mode parameter is as in gzopen.
 *
 * The next call of gzclose on the returned gzFile will also close the file
 * descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
 * fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
 * mode);.  The duplicated descriptor should be saved to avoid a leak, since
 * gzdopen does not close fd if it fails.  If you are using fileno() to get the
 * file descriptor from a FILE *, then you will have to use dup() to avoid
 * double-close()ing the file descriptor.  Both gzclose() and fclose() will
 * close the associated file descriptor, so they need to have different file
 * descriptors.
 *
 * @return Z_OK if there was insufficient memory to allocate the gzFile
 *     state, if an invalid mode was specified (an 'r', 'w', or 'a' was
 *     not provided, or '+' was provided), or if fd is -1. The file
 *     descriptor is not used until the next gz* read, write, seek, or
 *     close operation, so gzdopen will not detect if fd is invalid
 *     (unless fd is -1).
 */
gzFile gzdopen(int fd, const char *mode);

/**
 * Sets internal buffer size used by this library's functions. The
 * default buffer size is 8192 bytes. This function must be called after
 * gzopen() or gzdopen(), and before any other calls that read or write
 * the file. The buffer memory allocation is always deferred to the
 * first read or write. Three times that size in buffer space is
 * allocated. A larger buffer size of, for example, 64K or 128K bytes
 * will noticeably increase the speed of decompression (reading).
 *
 * The new buffer size also affects the maximum length for gzprintf().
 *
 * @return Z_OK on success, or -1 on failure, such as being called too
 *     late.
 */
int gzbuffer(gzFile file, unsigned size);

/**
 * Dynamically update the compression level or strategy.  See the description
 * of deflateInit2 for the meaning of these parameters.  Previously provided
 * data is flushed before the parameter change.
 *
 * @return Z_OK if success, Z_STREAM_ERROR if the file was not opened for
 *     writing, Z_ERRNO if there is an error writing the flushed data,
 *     or Z_MEM_ERROR if there is a memory allocation error.
 */
int gzsetparams(gzFile file, int level, int strategy);

/**
 * Reads given number of uncompressed bytes from the compressed file. If
 * the input file is not in gzip format, gzread copies the given number
 * of bytes into the buffer directly from the file.
 *
 * After reaching the end of a gzip stream in the input, gzread will continue
 * to read, looking for another gzip stream.  Any number of gzip streams may be
 * concatenated in the input file, and will all be decompressed by gzread().
 * If something other than a gzip stream is encountered after a gzip stream,
 * that remaining trailing garbage is ignored (and no error is returned).
 *
 * gzread can be used to read a gzip file that is being concurrently written.
 * Upon reaching the end of the input, gzread will return with the available
 * data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
 * gzclearerr can be used to clear the end of file indicator in order to permit
 * gzread to be tried again.  Z_OK indicates that a gzip stream was completed
 * on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
 * middle of a gzip stream.  Note that gzread does not return -1 in the event
 * of an incomplete gzip stream.  This error is deferred until gzclose(), which
 * will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
 * stream.  Alternatively, gzerror can be used before gzclose to detect this
 * case.
 *
 * @return Z_OK number of uncompressed bytes actually read, less than
 *     len for end of file, or -1 for error. If len is too large to fit
 *     in an int, then nothing is read, -1 is returned, and the error
 *     state is set to Z_STREAM_ERROR.
 */
int gzread(gzFile file, voidp buf, unsigned len);

/**
 * Read up to nitems items of size size from file to buf, otherwise operating
 * as gzread() does.  This duplicates the interface of stdio's fread(), with
 * size_t request and return types.  If the library defines size_t, then
 * size_t is identical to size_t.  If not, then size_t is an unsigned
 * integer type that can contain a pointer.
 *
 * gzfread() returns the number of full items read of size size, or zero if
 * the end of the file was reached and a full item could not be read, or if
 * there was an error.  gzerror() must be consulted if zero is returned in
 * order to determine if there was an error.  If the multiplication of size and
 * nitems overflows, i.e. the product does not fit in a size_t, then nothing
 * is read, zero is returned, and the error state is set to Z_STREAM_ERROR.
 *
 * In the event that the end of file is reached and only a partial item is
 * available at the end, i.e. the remaining uncompressed data length is not a
 * multiple of size, then the final partial item is nevetheless read into buf
 * and the end-of-file flag is set.  The length of the partial item read is not
 * provided, but could be inferred from the result of gztell().  This behavior
 * is the same as the behavior of fread() implementations in common libraries,
 * but it prevents the direct use of gzfread() to read a concurrently written
 * file, reseting and retrying on end-of-file, when size is not 1.
 */
size_t gzfread(voidp buf, size_t size, size_t nitems, gzFile file);

/**
 * Writes given number of uncompressed bytes into the compressed file.
 * gzwrite returns the number of uncompressed bytes written or 0 in case
 * of error.
 */
int gzwrite(gzFile file, voidpc buf, unsigned len);

/**
 * Writes nitems items of size size from buf to file, duplicating the
 * interface of stdio's fwrite(), with size_t request and return types.
 * If the library defines size_t, then size_t is identical to size_t. If
 * not, then size_t is an unsigned integer type that can contain a
 * pointer.
 *
 * gzfwrite() returns the number of full items written of size size, or zero
 * if there was an error.  If the multiplication of size and nitems overflows,
 * i.e. the product does not fit in a size_t, then nothing is written, zero
 * is returned, and the error state is set to Z_STREAM_ERROR.
 */
size_t gzfwrite(voidpc buf, size_t size, size_t nitems, gzFile file);

/**
 * Converts, formats, and writes the arguments to the compressed file
 * under control of the format string, as in fprintf. gzprintf returns
 * the number of uncompressed bytes actually written, or a negative zlib
 * error code in case of error. The number of uncompressed bytes written
 * is limited to 8191, or one less than the buffer size given to
 * gzbuffer(). The caller should assure that this limit is not exceeded.
 * If it is exceeded, then gzprintf() will return an error (0) with
 * nothing written. In this case, there may also be a buffer overflow
 * with unpredictable consequences, which is possible only if zlib was
 * compiled with the insecure functions sprintf() or vsprintf() because
 * the secure snprintf() or vsnprintf() functions were not available.
 * This can be determined using zlibCompileFlags().
 */
int gzprintf(gzFile file, const char *format, ...);

/**
 * Writes the given null-terminated string to the compressed file, excluding
 * the terminating null character.
 *
 * @return Z_OK number of characters written, or -1 in case of error.
 */
int gzputs(gzFile file, const char *s);

/**
 * Reads bytes from the compressed file until len-1 characters are read,
 * or a newline character is read and transferred to buf, or an
 * end-of-file condition is encountered. If any characters are read or
 * if len == 1, the string is terminated with a null character. If no
 * characters are read due to an end-of-file or len < 1, then the buffer
 * is left untouched.
 *
 * @return buf which is a null-terminated string, or it returns NULL for
 *     end-of-file or in case of error. If there was an error, the
 *     contents at buf are indeterminate.
 */
char *gzgets(gzFile file, char *buf, int len);

/**
 * Writes character converted to an unsigned char into compressed file.
 * @return value that was written, or -1 on error
 */
int gzputc(gzFile file, int c);

/**
 * Reads one byte from the compressed file. gzgetc returns this byte or
 * -1 in case of end of file or error. This is implemented as a macro
 * for speed. As such, it does not do all of the checking the other
 * functions do. I.e. it does not check to see if file is NULL, nor
 * whether the structure file points to has been clobbered or not.
 */
int gzgetc(gzFile file);

/**
 * Pushes one character back onto the stream to be read as the first
 * character on the next read. At least one character of push-back is
 * allowed. gzungetc() returns the character pushed, or -1 on failure.
 * gzungetc() will fail if c is -1, and may fail if a character has been
 * pushed but not read yet. If gzungetc is used immediately after gzopen
 * or gzdopen, at least the output buffer size of pushed characters is
 * allowed. (See gzbuffer above.) The pushed character will be discarded
 * if the stream is repositioned with gzseek() or gzrewind().
 */
int gzungetc(int c, gzFile file);

/**
 * Flushes all pending output into the compressed file. The parameter
 * flush is as in the deflate() function. The return value is the zlib
 * error number (see function gzerror below). gzflush is only permitted
 * when writing.
 *
 * If the flush parameter is Z_FINISH, the remaining data is written and
 * the gzip stream is completed in the output. If gzwrite() is called
 * again, a new gzip stream will be started in the output. gzread() is
 * able to read such concatenated gzip streams.
 *
 * gzflush should be called only when strictly necessary because it will
 * degrade compression if called too often.
 */
int gzflush(gzFile file, int flush);

/**
 * Sets starting position for the next gzread or gzwrite on the given
 * compressed file. The offset represents a number of bytes in the
 * uncompressed data stream. The whence parameter is defined as in
 * lseek(2); the value SEEK_END is not supported.
 *
 * If the file is opened for reading, this function is emulated but can be
 * extremely slow.  If the file is opened for writing, only forward seeks are
 * supported; gzseek then compresses a sequence of zeroes up to the new
 * starting position.
 *
 * @return resulting offset location as measured in bytes from the
 *     beginning of the uncompressed stream, or -1 in case of error, in
 *     particular if the file is opened for writing and the new starting
 *     position would be before the current position.
 */
ssize_t gzseek(gzFile file, int64_t offset, int whence);

/**
 * Rewinds file.
 *
 * This function is supported only for reading.
 *
 * @note gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
 */
int gzrewind(gzFile file);

/**
 * Returns starting position for the next gzread or gzwrite on the given
 * compressed file. This position represents a number of bytes in the
 * uncompressed data stream, and is zero when starting, even if
 * appending or reading a gzip stream from the middle of a file using
 * gzdopen().
 *
 * @note gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
 */
ssize_t gztell(gzFile file);

/**
 * Returns current offset in the file being read or written. This offset
 * includes the count of bytes that precede the gzip stream, for example
 * when appending or when using gzdopen() for reading. When reading, the
 * offset does not include as yet unused buffered input. This
 * information can be used for a progress indicator. On error,
 * gzoffset() returns -1.
 */
ssize_t gzoffset(gzFile file);

/**
 * Returns true (1) if the end-of-file indicator has been set while
 * reading, false (0) otherwise. Note that the end-of-file indicator is
 * set only if the read tried to go past the end of the input, but came
 * up short. Therefore, just like feof(), gzeof() may return false even
 * if there is no more data to read, in the event that the last read
 * request was for the exact number of bytes remaining in the input
 * file. This will happen if the input file size is an exact multiple of
 * the buffer size.
 *
 * If gzeof() returns true, then the read functions will return no more
 * data, unless the end-of-file indicator is reset by gzclearerr() and
 * the input file has grown since the previous end of file was detected.
 */
int gzeof(gzFile file);

/**
 * Returns true (1) if file is being copied directly while reading, or
 * false (0) if file is a gzip stream being decompressed.
 *
 * If the input file is empty, gzdirect() will return true, since the
 * input does not contain a gzip stream.
 *
 * If gzdirect() is used immediately after gzopen() or gzdopen() it will
 * cause buffers to be allocated to allow reading the file to determine
 * if it is a gzip file. Therefore if gzbuffer() is used, it should be
 * called before gzdirect().
 *
 * When writing, gzdirect() returns true (1) if transparent writing was
 * requested ("wT" for the gzopen() mode), or false (0) otherwise.
 * (Note: gzdirect() is not needed when writing. Transparent writing
 * must be explicitly requested, so the application already knows the
 * answer. When linking statically, using gzdirect() will include all of
 * the zlib code for gzip file reading and decompression, which may not
 * be desired.)
 */
int gzdirect(gzFile file);

/**
 * Flushes all pending output if necessary, closes the compressed file
 * and deallocates the (de)compression state. Note that once file is
 * closed, you cannot call gzerror with file, since its structures have
 * been deallocated. gzclose must not be called more than once on the
 * same file, just as free must not be called more than once on the same
 * allocation.
 *
 * @return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a file
 *     operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
 *     last read ended in the middle of a gzip stream, or Z_OK on
 *     success.
 */
int gzclose(gzFile file);

/**
 * Same as gzclose(), but gzclose_r() is only for use when reading, and
 * gzclose_w() is only for use when writing or appending. The advantage
 * to using these instead of gzclose() is that they avoid linking in
 * zlib compression or decompression code that is not used when only
 * reading or only writing respectively. If gzclose() is used, then both
 * compression and decompression code will be included the application
 * when linking to a static zlib library.
 */
int gzclose_r(gzFile file);
int gzclose_w(gzFile file);

/**
 * Returns the error message for the last error which occurred on the given
 * compressed file.  errnum is set to zlib error number.  If an error occurred
 * in the file system and not in the compression library, errnum is set to
 * Z_ERRNO and the application may consult errno to get the exact error code.
 *
 * The application must not modify the returned string.  Future calls to
 * this function may invalidate the previously returned string.  If file is
 * closed, then the string previously returned by gzerror will no longer be
 * available.
 *
 * gzerror() should be used to distinguish errors from end-of-file for those
 * functions above that do not distinguish those cases in their return values.
 */
const char *gzerror(gzFile file, int *errnum);

/**
 * Clears the error and end-of-file flags for file.  This is analogous to the
 * clearerr() function in stdio.  This is useful for continuing to read a gzip
 * file that is being written concurrently.
 */
void gzclearerr(gzFile file);

/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § zlib » checksums                                          ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/

/**
 * Updates running Adler-32 checksum with the bytes buf[0..len-1] and
 * return the updated checksum. If buf is Z_NULL, this function returns
 * the required initial value for the checksum.
 */
uLong adler32(uLong adler, const Bytef *buf, uInt len);

/**
 * Same as adler32(), but with a size_t length.
 */
uLong adler32_z(uLong adler, const Bytef *buf, size_t len);

/**
 * Combine two Adler-32 checksums into one. For two sequences of bytes,
 * seq1 and seq2 with lengths len1 and len2, Adler-32 checksums were
 * calculated for each, adler1 and adler2. adler32_combine() returns the
 * Adler-32 checksum of seq1 and seq2 concatenated, requiring only
 * adler1, adler2, and len2. Note that the off_t type (like off_t) is a
 * signed integer. If len2 is negative, the result has no meaning or
 * utility.
 */
uLong adler32_combine(uLong adler1, uLong adler2, int64_t len2);

/**
 * Update a running CRC-32 with the bytes buf[0..len-1] and return the
 * updated CRC-32.  If buf is Z_NULL, this function returns the required
 * initial value for the crc.  Pre- and post-conditioning (one's complement) is
 * performed within this function so it shouldn't be done by the application.
 *
 * Usage example:
 *
 *     uLong crc = crc32(0L, Z_NULL, 0);
 *     while (read_buffer(buffer, length) != EOF) {
 *       crc = crc32(crc, buffer, length);
 *     }
 *     if (crc != original_crc) error();
 */
uLong crc32(uLong crc, const Bytef *buf, uInt len);

/**
 * Combine two CRC-32 check values into one. For two sequences of bytes,
 * seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
 * calculated for each, crc1 and crc2. crc32_combine() returns the
 * CRC-32 check value of seq1 and seq2 concatenated, requiring only
 * crc1, crc2, and len2.
 */
uLong crc32_combine(uLong crc1, uLong crc2, int64_t len2);

/**
 * gzgetc() macro and its supporting function and exposed data
 * structure. Note that the real internal state is much larger than the
 * exposed structure. This abbreviated structure exposes just enough for
 * the gzgetc() macro. The user should not mess with these exposed
 * elements, since their names or behavior could change in the future,
 * perhaps even capriciously. They can only be used by the gzgetc()
 * macro. You have been warned.
 */
struct gzFile_s {
  unsigned have;
  unsigned char *next;
  int64_t pos;
};

int gzgetc_(gzFile file); /* backward compatibility */
#ifdef Z_PREFIX_SET
#undef z_gzgetc
#define z_gzgetc(g) \
  ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
#elif defined(Z_CR_PREFIX_SET)
#undef gzgetc
#define gzgetc(g) \
  ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (Cr_z_gzgetc)(g))
#else
#define gzgetc(g) \
  ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
#endif

/* undocumented functions */
const char *zError(int);
int inflateSyncPoint(z_streamp);
int inflateUndermine(z_streamp, int);
int inflateValidate(z_streamp, int);
unsigned long inflateCodesUsed(z_streamp);
int inflateResetKeep(z_streamp);
int deflateResetKeep(z_streamp);
int gzvprintf(gzFile file, const char *format, va_list va);
void inflate_fast_chunk(z_streamp strm, unsigned start);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */


/*!BEGIN third_party/regex/regex.h */

#define COSMOPOLITAN_LIBC_REGEX_REGEX_H_
#if !(__ASSEMBLER__ + __LINKER__ + 0)
COSMOPOLITAN_C_START_

#if 0
/*───────────────────────────────────────────────────────────────────────────│─╗
│ cosmopolitan § regular expressions                                       ─╬─│┼
╚────────────────────────────────────────────────────────────────────────────│*/
#endif

#define REG_EXTENDED 1
#define REG_ICASE    2
#define REG_NEWLINE  4
#define REG_NOSUB    8

#define REG_NOTBOL 1
#define REG_NOTEOL 2

#define REG_OK       0
#define REG_NOMATCH  1
#define REG_BADPAT   2
#define REG_ECOLLATE 3
#define REG_ECTYPE   4
#define REG_EESCAPE  5
#define REG_ESUBREG  6
#define REG_EBRACK   7
#define REG_EPAREN   8
#define REG_EBRACE   9
#define REG_BADBR    10
#define REG_ERANGE   11
#define REG_ESPACE   12
#define REG_BADRPT   13

#define REG_ENOSYS -1

typedef long regoff_t;

struct Regex {
  size_t re_nsub;
  void *__opaque, *__padding[4];
  size_t __nsub2;
  char __padding2;
};

struct RegexMatch {
  regoff_t rm_so;
  regoff_t rm_eo;
};

typedef struct Regex regex_t;
typedef struct RegexMatch regmatch_t;

int regcomp(regex_t *, const char *, int);
int regexec(const regex_t *, const char *, size_t, regmatch_t *, int);
size_t regerror(int, const regex_t *, char *, size_t);
void regfree(regex_t *);

COSMOPOLITAN_C_END_
#endif /* !(__ASSEMBLER__ + __LINKER__ + 0) */

#endif /* COSMOPOLITAN_H_ */
